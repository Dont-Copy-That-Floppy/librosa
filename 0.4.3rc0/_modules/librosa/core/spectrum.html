

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>librosa.core.spectrum &mdash; librosa 0.4.3rc0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../../_static/banner.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="librosa 0.4.3rc0 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> librosa
          

          
          </a>

          
            
            
              <div class="version">
                0.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../core.html">Core IO and DSP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../display.html">Display</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../feature.html">Feature extraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../onset.html">Onset detection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../beat.html">Beat and tempo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../decompose.html">Spectrogram decomposition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../effects.html">Effects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../output.html">Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../segment.html">Temporal segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../util.html">Utilities</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../filters.html">Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cache.html">Caching</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">librosa</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>librosa.core.spectrum</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for librosa.core.spectrum</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&#39;&#39;&#39;Utilities for spectral processing&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.fftpack</span> <span class="k">as</span> <span class="nn">fft</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span>
<span class="kn">import</span> <span class="nn">six</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">time_frequency</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">cache</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">..util.exceptions</span> <span class="k">import</span> <span class="n">ParameterError</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;stft&#39;</span><span class="p">,</span> <span class="s1">&#39;istft&#39;</span><span class="p">,</span> <span class="s1">&#39;magphase&#39;</span><span class="p">,</span>
           <span class="s1">&#39;ifgram&#39;</span><span class="p">,</span>
           <span class="s1">&#39;phase_vocoder&#39;</span><span class="p">,</span>
           <span class="s1">&#39;logamplitude&#39;</span><span class="p">,</span> <span class="s1">&#39;perceptual_weighting&#39;</span><span class="p">,</span>
           <span class="s1">&#39;fmt&#39;</span><span class="p">]</span>


<span class="nd">@cache</span>
<div class="viewcode-block" id="stft"><a class="viewcode-back" href="../../../generated/librosa.core.stft.html#librosa.core.stft">[docs]</a><span class="k">def</span> <span class="nf">stft</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
         <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Short-time Fourier transform (STFT)</span>

<span class="sd">    Returns a complex-valued matrix D such that</span>
<span class="sd">        `np.abs(D[f, t])` is the magnitude of frequency bin `f`</span>
<span class="sd">        at frame `t`</span>

<span class="sd">        `np.angle(D[f, t])` is the phase of frequency bin `f`</span>
<span class="sd">        at frame `t`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)], real-valued</span>
<span class="sd">        the input signal (audio time series)</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        number audio of frames between STFT columns.</span>
<span class="sd">        If unspecified, defaults `win_length / 4`.</span>

<span class="sd">    win_length  : int &lt;= n_fft [scalar]</span>
<span class="sd">        Each frame of audio is windowed by `window()`.</span>
<span class="sd">        The window will be of length `win_length` and then padded</span>
<span class="sd">        with zeros to match `n_fft`.</span>

<span class="sd">        If unspecified, defaults to ``win_length = n_fft``.</span>

<span class="sd">    window : None, function, np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - None (default): use an asymmetric Hann window</span>
<span class="sd">        - a window function, such as `scipy.signal.hanning`</span>
<span class="sd">        - a vector or array of length `n_fft`</span>

<span class="sd">    center      : boolean</span>
<span class="sd">        - If `True`, the signal `y` is padded so that frame</span>
<span class="sd">          `D[:, t]` is centered at `y[t * hop_length]`.</span>
<span class="sd">        - If `False`, then `D[:, t]` begins at `y[t * hop_length]`</span>

<span class="sd">    dtype       : numeric type</span>
<span class="sd">        Complex numeric type for `D`.  Default is 64-bit complex.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    D : np.ndarray [shape=(1 + n_fft/2, t), dtype=dtype]</span>
<span class="sd">        STFT matrix</span>


<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If `window` is supplied as a vector of length `n_fft`.</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    istft : Inverse STFT</span>

<span class="sd">    ifgram : Instantaneous frequency spectrogram</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; D = librosa.stft(y)</span>
<span class="sd">    &gt;&gt;&gt; D</span>
<span class="sd">    array([[  2.576e-03 -0.000e+00j,   4.327e-02 -0.000e+00j, ...,</span>
<span class="sd">              3.189e-04 -0.000e+00j,  -5.961e-06 -0.000e+00j],</span>
<span class="sd">           [  2.441e-03 +2.884e-19j,   5.145e-02 -5.076e-03j, ...,</span>
<span class="sd">             -3.885e-04 -7.253e-05j,   7.334e-05 +3.868e-04j],</span>
<span class="sd">          ...,</span>
<span class="sd">           [ -7.120e-06 -1.029e-19j,  -1.951e-09 -3.568e-06j, ...,</span>
<span class="sd">             -4.912e-07 -1.487e-07j,   4.438e-06 -1.448e-05j],</span>
<span class="sd">           [  7.136e-06 -0.000e+00j,   3.561e-06 -0.000e+00j, ...,</span>
<span class="sd">             -5.144e-07 -0.000e+00j,  -1.514e-05 -0.000e+00j]], dtype=complex64)</span>


<span class="sd">    Use left-aligned frames, instead of centered frames</span>


<span class="sd">    &gt;&gt;&gt; D_left = librosa.stft(y, center=False)</span>


<span class="sd">    Use a shorter hop length</span>


<span class="sd">    &gt;&gt;&gt; D_short = librosa.stft(y, hop_length=64)</span>


<span class="sd">    Display a spectrogram</span>


<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.logamplitude(np.abs(D)**2,</span>
<span class="sd">    ...                                               ref_power=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar(format=&#39;%+2.0f dB&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># By default, use the entire frame</span>
    <span class="k">if</span> <span class="n">win_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">win_length</span> <span class="o">=</span> <span class="n">n_fft</span>

    <span class="c1"># Set the default hop, if it&#39;s not already specified</span>
    <span class="k">if</span> <span class="n">hop_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hop_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">win_length</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Default is an asymmetric Hann window</span>
        <span class="n">fft_window</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">hann</span><span class="p">(</span><span class="n">win_length</span><span class="p">,</span> <span class="n">sym</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">six</span><span class="o">.</span><span class="n">callable</span><span class="p">(</span><span class="n">window</span><span class="p">):</span>
        <span class="c1"># User supplied a window function</span>
        <span class="n">fft_window</span> <span class="o">=</span> <span class="n">window</span><span class="p">(</span><span class="n">win_length</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># User supplied a window vector.</span>
        <span class="c1"># Make sure it&#39;s an array:</span>
        <span class="n">fft_window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>

        <span class="c1"># validate length compatibility</span>
        <span class="k">if</span> <span class="n">fft_window</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">n_fft</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Size mismatch between n_fft and len(window)&#39;</span><span class="p">)</span>

    <span class="c1"># Pad the window out to n_fft size</span>
    <span class="n">fft_window</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">pad_center</span><span class="p">(</span><span class="n">fft_window</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">)</span>

    <span class="c1"># Reshape so that the window can be broadcast</span>
    <span class="n">fft_window</span> <span class="o">=</span> <span class="n">fft_window</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Pad the time series so that frames are centered</span>
    <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
        <span class="n">util</span><span class="o">.</span><span class="n">valid_audio</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">)</span>

    <span class="c1"># Window the time series.</span>
    <span class="n">y_frames</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">frame</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">frame_length</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">)</span>

    <span class="c1"># Pre-allocate the STFT matrix</span>
    <span class="n">stft_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">y_frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                           <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

    <span class="c1"># how many columns can we fit within MAX_MEM_BLOCK?</span>
    <span class="n">n_columns</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">MAX_MEM_BLOCK</span> <span class="o">/</span> <span class="p">(</span><span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span>
                                          <span class="n">stft_matrix</span><span class="o">.</span><span class="n">itemsize</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">bl_s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">n_columns</span><span class="p">):</span>
        <span class="n">bl_t</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">bl_s</span> <span class="o">+</span> <span class="n">n_columns</span><span class="p">,</span> <span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># RFFT and Conjugate here to match phase from DPWE code</span>
        <span class="n">stft_matrix</span><span class="p">[:,</span> <span class="n">bl_s</span><span class="p">:</span><span class="n">bl_t</span><span class="p">]</span> <span class="o">=</span> <span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">fft_window</span> <span class="o">*</span>
                                            <span class="n">y_frames</span><span class="p">[:,</span> <span class="n">bl_s</span><span class="p">:</span><span class="n">bl_t</span><span class="p">],</span>
                                            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:</span><span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">stft_matrix</span></div>


<span class="nd">@cache</span>
<div class="viewcode-block" id="istft"><a class="viewcode-back" href="../../../generated/librosa.core.istft.html#librosa.core.istft">[docs]</a><span class="k">def</span> <span class="nf">istft</span><span class="p">(</span><span class="n">stft_matrix</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inverse short-time Fourier transform (ISTFT).</span>

<span class="sd">    Converts a complex-valued spectrogram `stft_matrix` to time-series `y`</span>
<span class="sd">    by minimizing the mean squared error between `stft_matrix` and STFT of</span>
<span class="sd">    `y` as described in [1]_.</span>

<span class="sd">    In general, window function, hop length and other parameters should be same</span>
<span class="sd">    as in stft, which mostly leads to perfect reconstruction of a signal from</span>
<span class="sd">    unmodified `stft_matrix`.</span>

<span class="sd">    .. [1] D. W. Griffin and J. S. Lim,</span>
<span class="sd">        &quot;Signal estimation from modified short-time Fourier transform,&quot;</span>
<span class="sd">        IEEE Trans. ASSP, vol.32, no.2, pp.236–243, Apr. 1984.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    stft_matrix : np.ndarray [shape=(1 + n_fft/2, t)]</span>
<span class="sd">        STFT matrix from `stft`</span>

<span class="sd">    hop_length  : int &gt; 0 [scalar]</span>
<span class="sd">        Number of frames between STFT columns.</span>
<span class="sd">        If unspecified, defaults to `win_length / 4`.</span>

<span class="sd">    win_length  : int &lt;= n_fft = 2 * (stft_matrix.shape[0] - 1)</span>
<span class="sd">        When reconstructing the time series, each frame is windowed</span>
<span class="sd">        and each sample is normalized by the sum of squared window</span>
<span class="sd">        according to the `window` function (see below).</span>

<span class="sd">        If unspecified, defaults to `n_fft`.</span>

<span class="sd">    window      : None, function, np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - None (default): use an asymmetric Hann window</span>
<span class="sd">        - a window function, such as `scipy.signal.hanning`</span>
<span class="sd">        - a user-specified window vector of length `n_fft`</span>

<span class="sd">    center      : boolean</span>
<span class="sd">        - If `True`, `D` is assumed to have centered frames.</span>
<span class="sd">        - If `False`, `D` is assumed to have left-aligned frames.</span>

<span class="sd">    dtype       : numeric type</span>
<span class="sd">        Real numeric type for `y`.  Default is 32-bit float.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : np.ndarray [shape=(n,)]</span>
<span class="sd">        time domain signal reconstructed from `stft_matrix`</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If `window` is supplied as a vector of length `n_fft`</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    stft : Short-time Fourier Transform</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; D = librosa.stft(y)</span>
<span class="sd">    &gt;&gt;&gt; y_hat = librosa.istft(D)</span>
<span class="sd">    &gt;&gt;&gt; y_hat</span>
<span class="sd">    array([ -4.812e-06,  -4.267e-06, ...,   6.271e-06,   2.827e-07], dtype=float32)</span>

<span class="sd">    Exactly preserving length of the input signal requires explicit padding.</span>
<span class="sd">    Otherwise, a partial frame at the end of `y` will not be represented.</span>

<span class="sd">    &gt;&gt;&gt; n = len(y)</span>
<span class="sd">    &gt;&gt;&gt; n_fft = 2048</span>
<span class="sd">    &gt;&gt;&gt; y_pad = librosa.util.fix_length(y, n + n_fft // 2)</span>
<span class="sd">    &gt;&gt;&gt; D = librosa.stft(y_pad, n_fft=n_fft)</span>
<span class="sd">    &gt;&gt;&gt; y_out = librosa.util.fix_length(librosa.istft(D), n)</span>
<span class="sd">    &gt;&gt;&gt; np.max(np.abs(y - y_out))</span>
<span class="sd">    1.4901161e-07</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_fft</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># By default, use the entire frame</span>
    <span class="k">if</span> <span class="n">win_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">win_length</span> <span class="o">=</span> <span class="n">n_fft</span>

    <span class="c1"># Set the default hop, if it&#39;s not already specified</span>
    <span class="k">if</span> <span class="n">hop_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hop_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">win_length</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Default is an asymmetric Hann window.</span>
        <span class="n">ifft_window</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">hann</span><span class="p">(</span><span class="n">win_length</span><span class="p">,</span> <span class="n">sym</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">six</span><span class="o">.</span><span class="n">callable</span><span class="p">(</span><span class="n">window</span><span class="p">):</span>
        <span class="c1"># User supplied a windowing function</span>
        <span class="n">ifft_window</span> <span class="o">=</span> <span class="n">window</span><span class="p">(</span><span class="n">win_length</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># User supplied a window vector.</span>
        <span class="c1"># Make it into an array</span>
        <span class="n">ifft_window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>

        <span class="c1"># Verify that the shape matches</span>
        <span class="k">if</span> <span class="n">ifft_window</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">n_fft</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Size mismatch between n_fft and window size&#39;</span><span class="p">)</span>

    <span class="c1"># Pad out to match n_fft</span>
    <span class="n">ifft_window</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">pad_center</span><span class="p">(</span><span class="n">ifft_window</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">)</span>

    <span class="n">n_frames</span> <span class="o">=</span> <span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">expected_signal_len</span> <span class="o">=</span> <span class="n">n_fft</span> <span class="o">+</span> <span class="n">hop_length</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_frames</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">expected_signal_len</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">ifft_window_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">expected_signal_len</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">ifft_window_square</span> <span class="o">=</span> <span class="n">ifft_window</span> <span class="o">*</span> <span class="n">ifft_window</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_frames</span><span class="p">):</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">hop_length</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">stft_matrix</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">spec</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">spec</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">ytmp</span> <span class="o">=</span> <span class="n">ifft_window</span> <span class="o">*</span> <span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>

        <span class="n">y</span><span class="p">[</span><span class="n">sample</span><span class="p">:(</span><span class="n">sample</span> <span class="o">+</span> <span class="n">n_fft</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">sample</span><span class="p">:(</span><span class="n">sample</span> <span class="o">+</span> <span class="n">n_fft</span><span class="p">)]</span> <span class="o">+</span> <span class="n">ytmp</span>
        <span class="n">ifft_window_sum</span><span class="p">[</span><span class="n">sample</span><span class="p">:(</span><span class="n">sample</span> <span class="o">+</span> <span class="n">n_fft</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">ifft_window_square</span>

    <span class="c1"># Normalize by sum of squared window</span>
    <span class="n">approx_nonzero_indices</span> <span class="o">=</span> <span class="n">ifft_window_sum</span> <span class="o">&gt;</span> <span class="n">util</span><span class="o">.</span><span class="n">SMALL_FLOAT</span>
    <span class="n">y</span><span class="p">[</span><span class="n">approx_nonzero_indices</span><span class="p">]</span> <span class="o">/=</span> <span class="n">ifft_window_sum</span><span class="p">[</span><span class="n">approx_nonzero_indices</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">y</span></div>


<div class="viewcode-block" id="ifgram"><a class="viewcode-back" href="../../../generated/librosa.core.ifgram.html#librosa.core.ifgram">[docs]</a><span class="k">def</span> <span class="nf">ifgram</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
           <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ref_power</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">clip</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Compute the instantaneous frequency (as a proportion of the sampling rate)</span>
<span class="sd">    obtained as the time-derivative of the phase of the complex spectrum as</span>
<span class="sd">    described by [1]_.</span>

<span class="sd">    Calculates regular STFT as a side effect.</span>

<span class="sd">    .. [1] Abe, Toshihiko, Takao Kobayashi, and Satoshi Imai.</span>
<span class="sd">        &quot;Harmonics tracking and pitch extraction based on instantaneous</span>
<span class="sd">        frequency.&quot;</span>
<span class="sd">        International Conference on Acoustics, Speech, and Signal Processing,</span>
<span class="sd">        ICASSP-95., Vol. 1. IEEE, 1995.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)]</span>
<span class="sd">        audio time series</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        sampling rate of `y`</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length, number samples between subsequent frames.</span>
<span class="sd">        If not supplied, defaults to `win_length / 4`.</span>

<span class="sd">    win_length : int &gt; 0, &lt;= n_fft</span>
<span class="sd">        Window length. Defaults to `n_fft`.</span>
<span class="sd">        See `stft` for details.</span>

<span class="sd">    norm : bool</span>
<span class="sd">        Normalize the STFT.</span>

<span class="sd">    center      : boolean</span>
<span class="sd">        - If `True`, the signal `y` is padded so that frame</span>
<span class="sd">            `D[:, t]` (and `if_gram`) is centered at `y[t * hop_length]`.</span>
<span class="sd">        - If `False`, then `D[:, t]` at `y[t * hop_length]`</span>

<span class="sd">    ref_power : float &gt;= 0 or callable</span>
<span class="sd">        Minimum power threshold for estimating instantaneous frequency.</span>
<span class="sd">        Any bin with `np.abs(D[f, t])**2 &lt; ref_power` will receive the</span>
<span class="sd">        default frequency estimate.</span>

<span class="sd">        If callable, the threshold is set to `ref_power(np.abs(D)**2)`.</span>

<span class="sd">    clip : boolean</span>
<span class="sd">        - If `True`, clip estimated frequencies to the range `[0, 0.5 * sr]`.</span>
<span class="sd">        - If `False`, estimated frequencies can be negative or exceed</span>
<span class="sd">          `0.5 * sr`.</span>

<span class="sd">    dtype : numeric type</span>
<span class="sd">        Complex numeric type for `D`.  Default is 64-bit complex.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    if_gram : np.ndarray [shape=(1 + n_fft/2, t), dtype=real]</span>
<span class="sd">        Instantaneous frequency spectrogram:</span>
<span class="sd">        `if_gram[f, t]` is the frequency at bin `f`, time `t`</span>

<span class="sd">    D : np.ndarray [shape=(1 + n_fft/2, t), dtype=complex]</span>
<span class="sd">        Short-time Fourier transform</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    stft : Short-time Fourier Transform</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; frequencies, D = librosa.ifgram(y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; frequencies</span>
<span class="sd">    array([[  0.000e+00,   0.000e+00, ...,   0.000e+00,   0.000e+00],</span>
<span class="sd">           [  3.150e+01,   3.070e+01, ...,   1.077e+01,   1.077e+01],</span>
<span class="sd">           ...,</span>
<span class="sd">           [  1.101e+04,   1.101e+04, ...,   1.101e+04,   1.101e+04],</span>
<span class="sd">           [  1.102e+04,   1.102e+04, ...,   1.102e+04,   1.102e+04]])</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">win_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">win_length</span> <span class="o">=</span> <span class="n">n_fft</span>

    <span class="k">if</span> <span class="n">hop_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hop_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">win_length</span> <span class="o">//</span> <span class="mi">4</span><span class="p">)</span>

    <span class="c1"># Construct a padded hann window</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">pad_center</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">hann</span><span class="p">(</span><span class="n">win_length</span><span class="p">,</span> <span class="n">sym</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">n_fft</span><span class="p">)</span>

    <span class="c1"># Window for discrete differentiation</span>
    <span class="n">freq_angular</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">d_window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">freq_angular</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">n_fft</span>

    <span class="n">stft_matrix</span> <span class="o">=</span> <span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
                       <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">diff_stft</span> <span class="o">=</span> <span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
                     <span class="n">window</span><span class="o">=</span><span class="n">d_window</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>

    <span class="c1"># Compute power normalization. Suppress zeros.</span>
    <span class="n">mag</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">magphase</span><span class="p">(</span><span class="n">stft_matrix</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">callable</span><span class="p">(</span><span class="n">ref_power</span><span class="p">):</span>
        <span class="n">ref_power</span> <span class="o">=</span> <span class="n">ref_power</span><span class="p">(</span><span class="n">mag</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ref_power</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;ref_power must be non-negative or callable.&#39;</span><span class="p">)</span>

    <span class="c1"># Pylint does not correctly infer the type here, but it&#39;s correct.</span>
    <span class="c1"># pylint: disable=maybe-no-member</span>
    <span class="n">freq_angular</span> <span class="o">=</span> <span class="n">freq_angular</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">bin_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">phase</span> <span class="o">*</span> <span class="n">diff_stft</span><span class="p">)</span><span class="o">.</span><span class="n">imag</span> <span class="o">/</span> <span class="n">mag</span>

    <span class="n">bin_offset</span><span class="p">[</span><span class="n">mag</span> <span class="o">&lt;</span> <span class="n">ref_power</span><span class="o">**</span><span class="mf">0.5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">if_gram</span> <span class="o">=</span> <span class="n">freq_angular</span><span class="p">[:</span><span class="n">n_fft</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">bin_offset</span>

    <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
        <span class="n">stft_matrix</span> <span class="o">=</span> <span class="n">stft_matrix</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">window</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">clip</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">if_gram</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">if_gram</span><span class="p">)</span>

    <span class="n">if_gram</span> <span class="o">*=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sr</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

    <span class="k">return</span> <span class="n">if_gram</span><span class="p">,</span> <span class="n">stft_matrix</span></div>


<div class="viewcode-block" id="magphase"><a class="viewcode-back" href="../../../generated/librosa.core.magphase.html#librosa.core.magphase">[docs]</a><span class="k">def</span> <span class="nf">magphase</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Separate a complex-valued spectrogram D into its magnitude (S)</span>
<span class="sd">    and phase (P) components, so that `D = S * P`.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    D       : np.ndarray [shape=(d, t), dtype=complex]</span>
<span class="sd">        complex-valued spectrogram</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    D_mag   : np.ndarray [shape=(d, t), dtype=real]</span>
<span class="sd">        magnitude of `D`</span>
<span class="sd">    D_phase : np.ndarray [shape=(d, t), dtype=complex]</span>
<span class="sd">        `exp(1.j * phi)` where `phi` is the phase of `D`</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; D = librosa.stft(y)</span>
<span class="sd">    &gt;&gt;&gt; magnitude, phase = librosa.magphase(D)</span>
<span class="sd">    &gt;&gt;&gt; magnitude</span>
<span class="sd">    array([[  2.524e-03,   4.329e-02, ...,   3.217e-04,   3.520e-05],</span>
<span class="sd">           [  2.645e-03,   5.152e-02, ...,   3.283e-04,   3.432e-04],</span>
<span class="sd">           ...,</span>
<span class="sd">           [  1.966e-05,   9.828e-06, ...,   3.164e-07,   9.370e-06],</span>
<span class="sd">           [  1.966e-05,   9.830e-06, ...,   3.161e-07,   9.366e-06]], dtype=float32)</span>
<span class="sd">    &gt;&gt;&gt; phase</span>
<span class="sd">    array([[  1.000e+00 +0.000e+00j,   1.000e+00 +0.000e+00j, ...,</span>
<span class="sd">             -1.000e+00 +8.742e-08j,  -1.000e+00 +8.742e-08j],</span>
<span class="sd">           [  1.000e+00 +1.615e-16j,   9.950e-01 -1.001e-01j, ...,</span>
<span class="sd">              9.794e-01 +2.017e-01j,   1.492e-02 -9.999e-01j],</span>
<span class="sd">           ...,</span>
<span class="sd">           [  1.000e+00 -5.609e-15j,  -5.081e-04 +1.000e+00j, ...,</span>
<span class="sd">             -9.549e-01 -2.970e-01j,   2.938e-01 -9.559e-01j],</span>
<span class="sd">           [ -1.000e+00 +8.742e-08j,  -1.000e+00 +8.742e-08j, ...,</span>
<span class="sd">             -1.000e+00 +8.742e-08j,  -1.000e+00 +8.742e-08j]], dtype=complex64)</span>


<span class="sd">    Or get the phase angle (in radians)</span>

<span class="sd">    &gt;&gt;&gt; np.angle(phase)</span>
<span class="sd">    array([[  0.000e+00,   0.000e+00, ...,   3.142e+00,   3.142e+00],</span>
<span class="sd">           [  1.615e-16,  -1.003e-01, ...,   2.031e-01,  -1.556e+00],</span>
<span class="sd">           ...,</span>
<span class="sd">           [ -5.609e-15,   1.571e+00, ...,  -2.840e+00,  -1.273e+00],</span>
<span class="sd">           [  3.142e+00,   3.142e+00, ...,   3.142e+00,   3.142e+00]], dtype=float32)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">D</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">mag</span><span class="p">,</span> <span class="n">phase</span></div>


<span class="nd">@cache</span>
<div class="viewcode-block" id="phase_vocoder"><a class="viewcode-back" href="../../../generated/librosa.core.phase_vocoder.html#librosa.core.phase_vocoder">[docs]</a><span class="k">def</span> <span class="nf">phase_vocoder</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Phase vocoder.  Given an STFT matrix D, speed up by a factor of `rate`</span>

<span class="sd">    Based on the implementation provided by [1]_.</span>

<span class="sd">    .. [1] Ellis, D. P. W. &quot;A phase vocoder in Matlab.&quot;</span>
<span class="sd">        Columbia University, 2002.</span>
<span class="sd">        http://www.ee.columbia.edu/~dpwe/resources/matlab/pvoc/</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Play at double speed</span>
<span class="sd">    &gt;&gt;&gt; y, sr   = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; D       = librosa.stft(y, n_fft=2048, hop_length=512)</span>
<span class="sd">    &gt;&gt;&gt; D_fast  = librosa.phase_vocoder(D, 2.0, hop_length=512)</span>
<span class="sd">    &gt;&gt;&gt; y_fast  = librosa.istft(D_fast, hop_length=512)</span>

<span class="sd">    &gt;&gt;&gt; # Or play at 1/3 speed</span>
<span class="sd">    &gt;&gt;&gt; y, sr   = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; D       = librosa.stft(y, n_fft=2048, hop_length=512)</span>
<span class="sd">    &gt;&gt;&gt; D_slow  = librosa.phase_vocoder(D, 1./3, hop_length=512)</span>
<span class="sd">    &gt;&gt;&gt; y_slow  = librosa.istft(D_slow, hop_length=512)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    D : np.ndarray [shape=(d, t), dtype=complex]</span>
<span class="sd">        STFT matrix</span>

<span class="sd">    rate :  float &gt; 0 [scalar]</span>
<span class="sd">        Speed-up factor: `rate &gt; 1` is faster, `rate &lt; 1` is slower.</span>

<span class="sd">    hop_length : int &gt; 0 [scalar] or None</span>
<span class="sd">        The number of samples between successive columns of `D`.</span>

<span class="sd">        If None, defaults to `n_fft/4 = (D.shape[0]-1)/2`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    D_stretched  : np.ndarray [shape=(d, t / rate), dtype=complex]</span>
<span class="sd">        time-stretched STFT</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_fft</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">hop_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hop_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_fft</span> <span class="o">//</span> <span class="mi">4</span><span class="p">)</span>

    <span class="n">time_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rate</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="c1"># Create an empty output array</span>
    <span class="n">d_stretch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_steps</span><span class="p">)),</span> <span class="n">D</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

    <span class="c1"># Expected phase advance in each bin</span>
    <span class="n">phi_advance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">hop_length</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Phase accumulator; initialize to the first sample</span>
    <span class="n">phase_acc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">D</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Pad 0 columns to simplify boundary logic</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">time_steps</span><span class="p">):</span>

        <span class="n">columns</span> <span class="o">=</span> <span class="n">D</span><span class="p">[:,</span> <span class="nb">int</span><span class="p">(</span><span class="n">step</span><span class="p">):</span><span class="nb">int</span><span class="p">(</span><span class="n">step</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)]</span>

        <span class="c1"># Weighting for linear magnitude interpolation</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">columns</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
               <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">columns</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># Store to output array</span>
        <span class="n">d_stretch</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">mag</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.</span><span class="n">j</span> <span class="o">*</span> <span class="n">phase_acc</span><span class="p">)</span>

        <span class="c1"># Compute phase advance</span>
        <span class="n">dphase</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">columns</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
                  <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">columns</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
                  <span class="o">-</span> <span class="n">phi_advance</span><span class="p">)</span>

        <span class="c1"># Wrap to -pi:pi range</span>
        <span class="n">dphase</span> <span class="o">=</span> <span class="n">dphase</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">dphase</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>

        <span class="c1"># Accumulate phase</span>
        <span class="n">phase_acc</span> <span class="o">+=</span> <span class="n">phi_advance</span> <span class="o">+</span> <span class="n">dphase</span>

    <span class="k">return</span> <span class="n">d_stretch</span></div>


<span class="nd">@cache</span>
<div class="viewcode-block" id="logamplitude"><a class="viewcode-back" href="../../../generated/librosa.core.logamplitude.html#librosa.core.logamplitude">[docs]</a><span class="k">def</span> <span class="nf">logamplitude</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">ref_power</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">amin</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">top_db</span><span class="o">=</span><span class="mf">80.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Log-scale the amplitude of a spectrogram.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : np.ndarray [shape=(d, t)]</span>
<span class="sd">        input spectrogram</span>

<span class="sd">    ref_power : scalar or function</span>
<span class="sd">        If scalar, `log(abs(S))` is compared to `log(ref_power)`.</span>

<span class="sd">        If a function, `log(abs(S))` is compared to `log(ref_power(abs(S)))`.</span>

<span class="sd">        This is primarily useful for comparing to the maximum value of `S`.</span>

<span class="sd">    amin    : float &gt; 0[scalar]</span>
<span class="sd">        minimum amplitude threshold for `abs(S)` and `ref_power`</span>

<span class="sd">    top_db  : float &gt;= 0 [scalar]</span>
<span class="sd">        threshold log amplitude at top_db below the peak:</span>
<span class="sd">        ``max(log(S)) - top_db``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    log_S   : np.ndarray [shape=(d, t)]</span>
<span class="sd">        ``log_S ~= 10 * log10(S) - 10 * log10(abs(ref_power))``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    perceptual_weighting</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Get a power spectrogram from a waveform ``y``</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; S = np.abs(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; librosa.logamplitude(S**2)</span>
<span class="sd">    array([[-33.293, -27.32 , ..., -33.293, -33.293],</span>
<span class="sd">           [-33.293, -25.723, ..., -33.293, -33.293],</span>
<span class="sd">           ...,</span>
<span class="sd">           [-33.293, -33.293, ..., -33.293, -33.293],</span>
<span class="sd">           [-33.293, -33.293, ..., -33.293, -33.293]], dtype=float32)</span>

<span class="sd">    Compute dB relative to peak power</span>

<span class="sd">    &gt;&gt;&gt; librosa.logamplitude(S**2, ref_power=np.max)</span>
<span class="sd">    array([[-80.   , -74.027, ..., -80.   , -80.   ],</span>
<span class="sd">           [-80.   , -72.431, ..., -80.   , -80.   ],</span>
<span class="sd">           ...,</span>
<span class="sd">           [-80.   , -80.   , ..., -80.   , -80.   ],</span>
<span class="sd">           [-80.   , -80.   , ..., -80.   , -80.   ]], dtype=float32)</span>


<span class="sd">    Or compare to median power</span>

<span class="sd">    &gt;&gt;&gt; librosa.logamplitude(S**2, ref_power=np.median)</span>
<span class="sd">    array([[-0.189,  5.784, ..., -0.189, -0.189],</span>
<span class="sd">           [-0.189,  7.381, ..., -0.189, -0.189],</span>
<span class="sd">           ...,</span>
<span class="sd">           [-0.189, -0.189, ..., -0.189, -0.189],</span>
<span class="sd">           [-0.189, -0.189, ..., -0.189, -0.189]], dtype=float32)</span>


<span class="sd">    And plot the results</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(S**2, sr=sr, y_axis=&#39;log&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.logamplitude(S**2, ref_power=np.max),</span>
<span class="sd">    ...                          sr=sr, y_axis=&#39;log&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar(format=&#39;%+2.0f dB&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Log-Power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">amin</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;amin must be strictly positive&#39;</span><span class="p">)</span>

    <span class="n">magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">callable</span><span class="p">(</span><span class="n">ref_power</span><span class="p">):</span>
        <span class="c1"># User supplied a function to calculate reference power</span>
        <span class="n">__ref</span> <span class="o">=</span> <span class="n">ref_power</span><span class="p">(</span><span class="n">magnitude</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">__ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ref_power</span><span class="p">)</span>

    <span class="n">log_spec</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">amin</span><span class="p">,</span> <span class="n">magnitude</span><span class="p">))</span>
    <span class="n">log_spec</span> <span class="o">-=</span> <span class="mf">10.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">amin</span><span class="p">,</span> <span class="n">__ref</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">top_db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">top_db</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;top_db must be non-negative positive&#39;</span><span class="p">)</span>
        <span class="n">log_spec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">log_spec</span><span class="p">,</span> <span class="n">log_spec</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">top_db</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">log_spec</span></div>


<span class="nd">@cache</span>
<div class="viewcode-block" id="perceptual_weighting"><a class="viewcode-back" href="../../../generated/librosa.core.perceptual_weighting.html#librosa.core.perceptual_weighting">[docs]</a><span class="k">def</span> <span class="nf">perceptual_weighting</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Perceptual weighting of a power spectrogram:</span>

<span class="sd">    `S_p[f] = A_weighting(f) + 10*log(S[f] / ref_power)`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : np.ndarray [shape=(d, t)]</span>
<span class="sd">        Power spectrogram</span>

<span class="sd">    frequencies : np.ndarray [shape=(d,)]</span>
<span class="sd">        Center frequency for each row of `S`</span>

<span class="sd">    kwargs : additional keyword arguments</span>
<span class="sd">        Additional keyword arguments to `logamplitude`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S_p : np.ndarray [shape=(d, t)]</span>
<span class="sd">        perceptually weighted version of `S`</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    logamplitude</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Re-weight a CQT power spectrum, using peak power as reference</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; CQT = librosa.cqt(y, sr=sr, fmin=librosa.note_to_hz(&#39;A1&#39;))</span>
<span class="sd">    &gt;&gt;&gt; freqs = librosa.cqt_frequencies(CQT.shape[0],</span>
<span class="sd">    ...                                 fmin=librosa.note_to_hz(&#39;A1&#39;))</span>
<span class="sd">    &gt;&gt;&gt; perceptual_CQT = librosa.perceptual_weighting(CQT**2,</span>
<span class="sd">    ...                                               freqs,</span>
<span class="sd">    ...                                               ref_power=np.max)</span>
<span class="sd">    &gt;&gt;&gt; perceptual_CQT</span>
<span class="sd">    array([[ -80.076,  -80.049, ..., -104.735, -104.735],</span>
<span class="sd">           [ -78.344,  -78.555, ..., -103.725, -103.725],</span>
<span class="sd">           ...,</span>
<span class="sd">           [ -76.272,  -76.272, ...,  -76.272,  -76.272],</span>
<span class="sd">           [ -76.485,  -76.485, ...,  -76.485,  -76.485]])</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.logamplitude(CQT**2,</span>
<span class="sd">    ...                                               ref_power=np.max),</span>
<span class="sd">    ...                          fmin=librosa.note_to_hz(&#39;A1&#39;),</span>
<span class="sd">    ...                          y_axis=&#39;cqt_hz&#39;,</span>
<span class="sd">    ...                          x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Log CQT power&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar(format=&#39;%+2.0f dB&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(perceptual_CQT, y_axis=&#39;cqt_hz&#39;,</span>
<span class="sd">    ...                          fmin=librosa.note_to_hz(&#39;A1&#39;),</span>
<span class="sd">    ...                          x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Perceptually weighted log CQT&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar(format=&#39;%+2.0f dB&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">offset</span> <span class="o">=</span> <span class="n">time_frequency</span><span class="o">.</span><span class="n">A_weighting</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">logamplitude</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="nd">@cache</span>
<div class="viewcode-block" id="fmt"><a class="viewcode-back" href="../../../generated/librosa.core.fmt.html#librosa.core.fmt">[docs]</a><span class="k">def</span> <span class="nf">fmt</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t_min</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">n_fmt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">over_sample</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The fast Mellin transform (FMT) [1]_ of a uniformly sampled signal y.</span>

<span class="sd">    When the Mellin parameter (beta) is 1/2, it is also known as the scale transform [2]_.</span>
<span class="sd">    The scale transform can be useful for audio analysis because its magnitude is invariant</span>
<span class="sd">    to scaling of the domain (e.g., time stretching or compression).  This is analogous</span>
<span class="sd">    to the magnitude of the Fourier transform being invariant to shifts in the input domain.</span>


<span class="sd">    .. [1] De Sena, Antonio, and Davide Rocchesso.</span>
<span class="sd">        &quot;A fast Mellin and scale transform.&quot;</span>
<span class="sd">        EURASIP Journal on Applied Signal Processing 2007.1 (2007): 75-75.</span>

<span class="sd">    .. [2] Cohen, L.</span>
<span class="sd">        &quot;The scale representation.&quot;</span>
<span class="sd">        IEEE Transactions on Signal Processing 41, no. 12 (1993): 3275-3292.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray, real-valued</span>
<span class="sd">        The input signal(s).  Can be multidimensional.</span>
<span class="sd">        The target axis must contain at least 3 samples.</span>

<span class="sd">    t_min : float &gt; 0</span>
<span class="sd">        The minimum time spacing (in samples).</span>
<span class="sd">        This value should generally be less than 1 to preserve as much information as</span>
<span class="sd">        possible.</span>

<span class="sd">    n_fmt : int &gt; 2 or None</span>
<span class="sd">        The number of scale transform bins to use.</span>
<span class="sd">        If None, then `n_bins = over_sample * ceil(n * log((n-1)/t_min))` is taken,</span>
<span class="sd">        where `n = y.shape[axis]`</span>

<span class="sd">    kind : str</span>
<span class="sd">        The type of interpolation to use when re-sampling the input.</span>
<span class="sd">        See `scipy.interpolate.interp1d` for possible values.</span>

<span class="sd">    beta : float</span>
<span class="sd">        The Mellin parameter.  beta=0.5 provides the scale transform.</span>

<span class="sd">    over_sample : float &gt;= 1</span>
<span class="sd">        Over-sampling factor for exponential resampling.</span>

<span class="sd">    axis : int</span>
<span class="sd">        The axis along which to transform `y`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x_scale : np.ndarray [dtype=complex]</span>
<span class="sd">        The scale transform of `y` along the `axis` dimension.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        if `n_fmt &lt; 2` or `t_min &lt;= 0`</span>
<span class="sd">        or if `y` is not finite</span>
<span class="sd">        or if `y.shape[axis] &lt; 3`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Generate a signal and time-stretch it (with energy normalization)</span>
<span class="sd">    &gt;&gt;&gt; scale = 1.25</span>
<span class="sd">    &gt;&gt;&gt; freq = 3.0</span>
<span class="sd">    &gt;&gt;&gt; x1 = np.linspace(0, 1, num=1024, endpoint=False)</span>
<span class="sd">    &gt;&gt;&gt; x2 = np.linspace(0, 1, num=scale * len(x1), endpoint=False)</span>
<span class="sd">    &gt;&gt;&gt; y1 = np.sin(2 * np.pi * freq * x1)</span>
<span class="sd">    &gt;&gt;&gt; y2 = np.sin(2 * np.pi * freq * x2) / np.sqrt(scale)</span>
<span class="sd">    &gt;&gt;&gt; # Verify that the two signals have the same energy</span>
<span class="sd">    &gt;&gt;&gt; np.sum(np.abs(y1)**2), np.sum(np.abs(y2)**2)</span>
<span class="sd">        (255.99999999999997, 255.99999999999969)</span>
<span class="sd">    &gt;&gt;&gt; scale1 = librosa.fmt(y1, n_fmt=512)</span>
<span class="sd">    &gt;&gt;&gt; scale2 = librosa.fmt(y2, n_fmt=512)</span>
<span class="sd">    &gt;&gt;&gt; # And plot the results</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(8, 4))</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(1, 2, 1)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(y1, label=&#39;Original&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(y2, linestyle=&#39;--&#39;, label=&#39;Stretched&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;time (samples)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Input signals&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(frameon=True)</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(1, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogy(np.abs(scale1), label=&#39;Original&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogy(np.abs(scale2), linestyle=&#39;--&#39;, label=&#39;Stretched&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;scale coefficients&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Scale transform magnitude&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(frameon=True)</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &gt;&gt;&gt; # Plot the scale transform of an onset strength autocorrelation</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file(),</span>
<span class="sd">    ...                      offset=10.0, duration=30.0)</span>
<span class="sd">    &gt;&gt;&gt; odf = librosa.onset.onset_strength(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; # Auto-correlate with up to 10 seconds lag</span>
<span class="sd">    &gt;&gt;&gt; odf_ac = librosa.autocorrelate(odf, max_size=10 * sr // 512)</span>
<span class="sd">    &gt;&gt;&gt; # Normalize</span>
<span class="sd">    &gt;&gt;&gt; odf_ac = librosa.util.normalize(odf_ac, norm=np.inf)</span>
<span class="sd">    &gt;&gt;&gt; # Compute the scale transform</span>
<span class="sd">    &gt;&gt;&gt; odf_ac_scale = librosa.fmt(librosa.util.normalize(odf_ac), n_fmt=512)</span>
<span class="sd">    &gt;&gt;&gt; # Plot the results</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(3, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(odf, label=&#39;Onset strength&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Time (frames)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xticks([])</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(frameon=True)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(3, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(odf_ac, label=&#39;Onset autocorrelation&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Lag (frames)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xticks([])</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(frameon=True)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(3, 1, 3)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogy(np.abs(odf_ac_scale), label=&#39;Scale transform magnitude&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;scale coefficients&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(frameon=True)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;y.shape[</span><span class="si">{:}</span><span class="s1">]==</span><span class="si">{:}</span><span class="s1"> &lt; 3&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">t_min</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;t_min must be a positive number&#39;</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">n_fmt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">over_sample</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;over_sample must be &gt;= 1&#39;</span><span class="p">)</span>

        <span class="c1"># The base is the maximum ratio between adjacent samples</span>
        <span class="c1"># Since the sample spacing is increasing, this is simply the</span>
        <span class="c1"># ratio between the positions of the last two samples: (n-1)/(n-2)</span>
        <span class="n">log_base</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">n_fmt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">over_sample</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">t_min</span><span class="p">))</span> <span class="o">/</span> <span class="n">log_base</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">n_fmt</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;n_fmt==</span><span class="si">{:}</span><span class="s1"> &lt; 3&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_fmt</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">log_base</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n_fmt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n_fmt</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">over_sample</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;y must be finite everywhere&#39;</span><span class="p">)</span>

    <span class="n">base</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_base</span><span class="p">)</span>
    <span class="c1"># original grid: signal covers [0, 1).  This range is arbitrary, but convenient.</span>
    <span class="c1"># The final sample is positioned at (n-1)/n, so we omit the endpoint</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># build the interpolator</span>
    <span class="n">f_interp</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="c1"># build the new sampling grid</span>
    <span class="c1"># exponentially spaced between t_min/n and 1 (exclusive)</span>
    <span class="c1"># we&#39;ll go one past where we need, and drop the last sample</span>
    <span class="c1"># When over-sampling, the last input sample contributions n_over samples.</span>
    <span class="c1"># To keep the spacing consistent, we over-sample by n_over, and then</span>
    <span class="c1"># trim the final samples.</span>
    <span class="n">n_over</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">over_sample</span><span class="p">))</span>
    <span class="n">x_exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">t_min</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">/</span> <span class="n">log_base</span><span class="p">,</span>
                        <span class="mi">0</span><span class="p">,</span>
                        <span class="n">num</span><span class="o">=</span><span class="n">n_fmt</span> <span class="o">+</span> <span class="n">n_over</span><span class="p">,</span>
                        <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">)[:</span><span class="o">-</span><span class="n">n_over</span><span class="p">]</span>

    <span class="c1"># Clean up any rounding errors at the boundaries of the interpolation</span>
    <span class="c1"># The interpolator gets angry if we try to extrapolate, so clipping is necessary here.</span>
    <span class="k">if</span> <span class="n">x_exp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">t_min</span> <span class="ow">or</span> <span class="n">x_exp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">x_exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">x_exp</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">t_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Make sure that all sample points are unique</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">x_exp</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_exp</span><span class="p">)</span>

    <span class="c1"># Resample the signal</span>
    <span class="n">y_res</span> <span class="o">=</span> <span class="n">f_interp</span><span class="p">(</span><span class="n">x_exp</span><span class="p">)</span>

    <span class="c1"># Broadcast the window correctly</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">y_res</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># Apply the window and fft</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">y_res</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_exp</span><span class="o">**</span><span class="n">beta</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span>
                     <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">overwrite_x</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Slice out the positive-scale component</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">idx</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">n_fmt</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Truncate and length-normalize</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_fmt</span></div>


<span class="nd">@cache</span>
<span class="k">def</span> <span class="nf">_spectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Helper function to retrieve a magnitude spectrogram.</span>

<span class="sd">    This is primarily used in feature extraction functions that can operate on</span>
<span class="sd">    either audio time-series or spectrogram input.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : None or np.ndarray [ndim=1]</span>
<span class="sd">        If provided, an audio time series</span>

<span class="sd">    S : None or np.ndarray</span>
<span class="sd">        Spectrogram input, optional</span>

<span class="sd">    n_fft : int &gt; 0</span>
<span class="sd">        STFT window size</span>

<span class="sd">    hop_length : int &gt; 0</span>
<span class="sd">        STFT hop length</span>

<span class="sd">    power : float &gt; 0</span>
<span class="sd">        Exponent for the magnitude spectrogram,</span>
<span class="sd">        e.g., 1 for energy, 2 for power, etc.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S_out : np.ndarray [dtype=np.float32]</span>
<span class="sd">        - If `S` is provided as input, then `S_out == S`</span>
<span class="sd">        - Else, `S_out = |stft(y, n_fft=n_fft, hop_length=hop_length)|**power`</span>

<span class="sd">    n_fft : int &gt; 0</span>
<span class="sd">        - If `S` is provided, then `n_fft` is inferred from `S`</span>
<span class="sd">        - Else, copied from input</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Infer n_fft from spectrogram shape</span>
        <span class="n">n_fft</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Otherwise, compute a magnitude spectrogram from input</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">))</span><span class="o">**</span><span class="n">power</span>

    <span class="k">return</span> <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, librosa development team.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
        <span class="fa fa-book"> Other Versions</span>
        v: 0.4.3rc0
        <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
        <dl>
            <dt>Tags</dt>
            <dd><a href="../../../../0.4.0rc1/index.html">0.4.0rc1</a></dd>
            <dd><a href="../../../../0.4.0rc2/index.html">0.4.0rc2</a></dd>
            <dd><a href="../../../../0.4.1/index.html">0.4.1</a></dd>
            <dd><a href="../../../../0.4.1rc0/index.html">0.4.1rc0</a></dd>
            <dd><a href="../../../../0.4.2/index.html">0.4.2</a></dd>
            <dd><a href="../../../../0.4.3/index.html">0.4.3</a></dd>
            <dd><a href="spectrum.html">0.4.3rc0</a></dd>
            <dd><a href="../../../../0.5.0/index.html">0.5.0</a></dd>
            <dd><a href="../../../../0.5.0rc0/index.html">0.5.0rc0</a></dd>
            <dd><a href="../../../../0.5.1/index.html">0.5.1</a></dd>
            <dd><a href="../../../../0.6.0rc0/index.html">0.6.0rc0</a></dd>
            <dd><a href="../../../../v0.1.0/index.html">v0.1.0</a></dd>
            <dd><a href="../../../../v0.4.0/index.html">v0.4.0</a></dd>
        </dl>
        <dl>
            <dt>Branches</dt>
            <dd><a href="../../../../display-bin-centering/index.html">display-bin-centering</a></dd>
            <dd><a href="../../../../master/index.html">master</a></dd>
        </dl>
    </div>
</div>


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.4.3rc0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>