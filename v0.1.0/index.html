
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Core methods &#8212; librosa 0.1.0 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/banner.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">librosa 0.1.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  


    
    



    <p class="scv-banner"><a href="../0.7.1/index.html"><b>Warning:</b> This document is for an old version of librosa. The latest version is 0.7.1.</a></p>
<div class="toctree-wrapper compound">
</div>
<div class="section" id="module-librosa.core">
<span id="core-methods"></span><h1>Core methods<a class="headerlink" href="#module-librosa.core" title="Permalink to this headline">¶</a></h1>
<div class="section" id="core-io-and-dsp">
<h2>Core IO and DSP<a class="headerlink" href="#core-io-and-dsp" title="Permalink to this headline">¶</a></h2>
<div class="section" id="audio-processing">
<h3>Audio processing<a class="headerlink" href="#audio-processing" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="spectral-representations">
<h3>Spectral representations<a class="headerlink" href="#spectral-representations" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="magnitude-scaling">
<h3>Magnitude scaling<a class="headerlink" href="#magnitude-scaling" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="time-and-frequency-conversion">
<h3>Time and frequency conversion<a class="headerlink" href="#time-and-frequency-conversion" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="pitch-and-tuning">
<h3>Pitch and tuning<a class="headerlink" href="#pitch-and-tuning" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="deprecated">
<h3>Deprecated<a class="headerlink" href="#deprecated" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="librosa.core.A_weighting">
<code class="descclassname">librosa.core.</code><code class="descname">A_weighting</code><span class="sig-paren">(</span><em>frequencies</em>, <em>min_db=-80.0</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.A_weighting" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the A-weighting of a set of frequencies.</p>
<dl class="docutils">
<dt>frequencies <span class="classifier-delimiter">:</span> <span class="classifier">scalar or np.ndarray [shape=(n,)]</span></dt>
<dd>One or more frequencies (in Hz)</dd>
<dt>min_db <span class="classifier-delimiter">:</span> <span class="classifier">float [scalar] or None</span></dt>
<dd>Clip weights below this threshold.
If <cite>None</cite>, no clipping is performed.</dd>
</dl>
<dl class="docutils">
<dt>A_weighting <span class="classifier-delimiter">:</span> <span class="classifier">scalar or np.ndarray [shape=(n,)]</span></dt>
<dd><cite>A_weighting[i]</cite> is the A-weighting of <cite>frequencies[i]</cite></dd>
</dl>
<p>perceptual_weighting</p>
<p>Get the A-weighting for CQT frequencies</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">cqt_frequencies</span><span class="p">(</span><span class="mi">108</span><span class="p">,</span> <span class="n">librosa</span><span class="o">.</span><span class="n">note_to_hz</span><span class="p">(</span><span class="s1">&#39;C1&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aw</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">A_weighting</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">aw</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Weighting (log10)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;A-Weighting of CQT frequencies&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.amplitude_to_db">
<code class="descclassname">librosa.core.</code><code class="descname">amplitude_to_db</code><span class="sig-paren">(</span><em>S</em>, <em>ref=1.0</em>, <em>amin=1e-05</em>, <em>top_db=80.0</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.amplitude_to_db" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an amplitude spectrogram to dB-scaled spectrogram.</p>
<p>This is equivalent to <code class="docutils literal notranslate"><span class="pre">power_to_db(S**2)</span></code>, but is provided for convenience.</p>
<dl class="docutils">
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>input amplitude</dd>
<dt>ref <span class="classifier-delimiter">:</span> <span class="classifier">scalar or callable</span></dt>
<dd><p class="first">If scalar, the amplitude <cite>abs(S)</cite> is scaled relative to <cite>ref</cite>:
<cite>20 * log10(S / ref)</cite>.
Zeros in the output correspond to positions where <cite>S == ref</cite>.</p>
<p class="last">If callable, the reference value is computed as <cite>ref(S)</cite>.</p>
</dd>
<dt>amin <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd>minimum threshold for <cite>S</cite> and <cite>ref</cite></dd>
<dt>top_db <span class="classifier-delimiter">:</span> <span class="classifier">float &gt;= 0 [scalar]</span></dt>
<dd>threshold the output at <cite>top_db</cite> below the peak:
<code class="docutils literal notranslate"><span class="pre">max(20</span> <span class="pre">*</span> <span class="pre">log10(S))</span> <span class="pre">-</span> <span class="pre">top_db</span></code></dd>
</dl>
<dl class="docutils">
<dt>S_db <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><code class="docutils literal notranslate"><span class="pre">S</span></code> measured in dB</dd>
</dl>
<p>power_to_db, db_to_amplitude</p>
<p>This function caches at level 30.</p>
</dd></dl>

<dl class="function">
<dt id="librosa.core.autocorrelate">
<code class="descclassname">librosa.core.</code><code class="descname">autocorrelate</code><span class="sig-paren">(</span><em>y</em>, <em>max_size=None</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.autocorrelate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bounded auto-correlation</p>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>array to autocorrelate</dd>
<dt>max_size <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 or None</span></dt>
<dd>maximum correlation lag.
If unspecified, defaults to <cite>y.shape[axis]</cite> (unbounded)</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The axis along which to autocorrelate.
By default, the last axis (-1) is taken.</dd>
</dl>
<dl class="docutils">
<dt>z <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>truncated autocorrelation <cite>y*y</cite> along the specified axis.
If <cite>max_size</cite> is specified, then <cite>z.shape[axis]</cite> is bounded
to <cite>max_size</cite>.</dd>
</dl>
<p>This function caches at level 20.</p>
<p>Compute full autocorrelation of y</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">(),</span> <span class="n">offset</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">autocorrelate</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">array([  3.226e+03,   3.217e+03, ...,   8.277e-04,   3.575e-04], dtype=float32)</span>
</pre></div>
</div>
<p>Compute onset strength auto-correlation up to 4 seconds</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">odf</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">onset</span><span class="o">.</span><span class="n">onset_strength</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ac</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">autocorrelate</span><span class="p">(</span><span class="n">odf</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="mi">4</span><span class="o">*</span> <span class="n">sr</span> <span class="o">/</span> <span class="mi">512</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ac</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Auto-correlation&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Lag (frames)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.blocks_to_frames">
<code class="descclassname">librosa.core.</code><code class="descname">blocks_to_frames</code><span class="sig-paren">(</span><em>blocks</em>, <em>block_length</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.blocks_to_frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert block indices to frame indices</p>
<dl class="docutils">
<dt>blocks <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>Block index or array of block indices</dd>
<dt>block_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>The number of frames per block</dd>
</dl>
<dl class="docutils">
<dt>frames <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=samples.shape, dtype=int]</span></dt>
<dd>The index or indices of frames corresponding to the beginning
of each provided block.</dd>
</dl>
<p>blocks_to_samples
blocks_to_time</p>
<p>Get frame indices for each block in a stream</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">get_samplerate</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stream</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">block_length</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> 
<span class="gp">... </span>                        <span class="n">frame_length</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stream</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">n_frame</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">blocks_to_frames</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">block_length</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.blocks_to_samples">
<code class="descclassname">librosa.core.</code><code class="descname">blocks_to_samples</code><span class="sig-paren">(</span><em>blocks</em>, <em>block_length</em>, <em>hop_length</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.blocks_to_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert block indices to sample indices</p>
<dl class="docutils">
<dt>blocks <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>Block index or array of block indices</dd>
<dt>block_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>The number of frames per block</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>The number of samples to advance between frames</dd>
</dl>
<dl class="docutils">
<dt>samples <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=samples.shape, dtype=int]</span></dt>
<dd><p class="first">The index or indices of samples corresponding to the beginning
of each provided block.</p>
<p class="last">Note that these correspond to the <em>first</em> sample index in
each block, and are not frame-centered.</p>
</dd>
</dl>
<p>blocks_to_frames
blocks_to_time</p>
<p>Get sample indices for each block in a stream</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">get_samplerate</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stream</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">block_length</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> 
<span class="gp">... </span>                        <span class="n">frame_length</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stream</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">n_sample</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">blocks_to_samples</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">block_length</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>
<span class="gp">... </span>                                         <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.blocks_to_time">
<code class="descclassname">librosa.core.</code><code class="descname">blocks_to_time</code><span class="sig-paren">(</span><em>blocks</em>, <em>block_length</em>, <em>hop_length</em>, <em>sr</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.blocks_to_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert block indices to time (in seconds)</p>
<dl class="docutils">
<dt>blocks <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>Block index or array of block indices</dd>
<dt>block_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>The number of frames per block</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>The number of samples to advance between frames</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>The sampling rate (samples per second)</dd>
</dl>
<dl class="docutils">
<dt>times <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=samples.shape]</span></dt>
<dd><p class="first">The time index or indices (in seconds) corresponding to the 
beginning of each provided block.</p>
<p class="last">Note that these correspond to the time of the <em>first</em> sample 
in each block, and are not frame-centered.</p>
</dd>
</dl>
<p>blocks_to_frames
blocks_to_samples</p>
<p>Get time indices for each block in a stream</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">get_samplerate</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stream</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">block_length</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> 
<span class="gp">... </span>                        <span class="n">frame_length</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stream</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">n_time</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">blocks_to_time</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">block_length</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.chirp">
<code class="descclassname">librosa.core.</code><code class="descname">chirp</code><span class="sig-paren">(</span><em>fmin</em>, <em>fmax</em>, <em>sr=22050</em>, <em>length=None</em>, <em>duration=None</em>, <em>linear=False</em>, <em>phi=None</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.chirp" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a chirp signal that goes from frequency <cite>fmin</cite> to frequency <cite>fmax</cite></p>
<dl class="docutils">
<dt>fmin <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd>initial frequency</dd>
<dt>fmax <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd>final frequency</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0</span></dt>
<dd>desired sampling rate of the output signal</dd>
<dt>length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>desired number of samples in the output signal.
When both <cite>duration</cite> and <cite>length</cite> are defined, <cite>length</cite> would take priority.</dd>
<dt>duration <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd>desired duration in seconds.
When both <cite>duration</cite> and <cite>length</cite> are defined, <cite>length</cite> would take priority.</dd>
<dt>linear <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><ul class="first simple">
<li>If <cite>True</cite>, use a linear sweep, i.e., frequency changes linearly with time</li>
<li>If <cite>False</cite>, use a exponential sweep.</li>
</ul>
<p class="last">Default is <cite>False</cite>.</p>
</dd>
<dt>phi <span class="classifier-delimiter">:</span> <span class="classifier">float or None</span></dt>
<dd>phase offset, in radians.
If unspecified, defaults to <cite>-np.pi * 0.5</cite>.</dd>
</dl>
<dl class="docutils">
<dt>chirp_signal <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(length,), dtype=float64]</span></dt>
<dd>Synthesized chirp signal</dd>
</dl>
<dl class="docutils">
<dt>ParameterError</dt>
<dd><ul class="first last simple">
<li>If either <cite>fmin</cite> or <cite>fmax</cite> are not provided.</li>
<li>If neither <cite>length</cite> nor <cite>duration</cite> are provided.</li>
</ul>
</dd>
</dl>
<p>scipy.signal.chirp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate a exponential chirp from A4 to A5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exponential_chirp</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">chirp</span><span class="p">(</span><span class="mi">440</span><span class="p">,</span> <span class="mi">880</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Or generate the same signal using `length`</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exponential_chirp</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">chirp</span><span class="p">(</span><span class="mi">440</span><span class="p">,</span> <span class="mi">880</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">22050</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Or generate a linear chirp instead</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_chirp</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">chirp</span><span class="p">(</span><span class="mi">440</span><span class="p">,</span> <span class="mi">880</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Display spectrogram for both exponential and linear chirps</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S_exponential</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">melspectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">exponential_chirp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">power_to_db</span><span class="p">(</span><span class="n">S_exponential</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">),</span>
<span class="gp">... </span>                         <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;mel&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S_linear</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">melspectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">linear_chirp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">power_to_db</span><span class="p">(</span><span class="n">S_linear</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">),</span>
<span class="gp">... </span>                         <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;mel&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.clicks">
<code class="descclassname">librosa.core.</code><code class="descname">clicks</code><span class="sig-paren">(</span><em>times=None</em>, <em>frames=None</em>, <em>sr=22050</em>, <em>hop_length=512</em>, <em>click_freq=1000.0</em>, <em>click_duration=0.1</em>, <em>click=None</em>, <em>length=None</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.clicks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a signal with the signal <cite>click</cite> placed at each specified time</p>
<dl class="docutils">
<dt>times <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray or None</span></dt>
<dd>times to place clicks, in seconds</dd>
<dt>frames <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray or None</span></dt>
<dd>frame indices to place clicks</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0</span></dt>
<dd>desired sampling rate of the output signal</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>if positions are specified by <cite>frames</cite>, the number of samples between frames.</dd>
<dt>click_freq <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd>frequency (in Hz) of the default click signal.  Default is 1KHz.</dd>
<dt>click_duration <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd>duration (in seconds) of the default click signal.  Default is 100ms.</dd>
<dt>click <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray or None</span></dt>
<dd>optional click signal sample to use instead of the default blip.</dd>
<dt>length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>desired number of samples in the output signal</dd>
</dl>
<dl class="docutils">
<dt>click_signal <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>Synthesized click signal</dd>
</dl>
<dl class="docutils">
<dt>ParameterError</dt>
<dd><ul class="first last simple">
<li>If neither <cite>times</cite> nor <cite>frames</cite> are provided.</li>
<li>If any of <cite>click_freq</cite>, <cite>click_duration</cite>, or <cite>length</cite> are out of range.</li>
</ul>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Sonify detected beat events</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tempo</span><span class="p">,</span> <span class="n">beats</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">beat_track</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_beats</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">clicks</span><span class="p">(</span><span class="n">frames</span><span class="o">=</span><span class="n">beats</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Or generate a signal of the same length as y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_beats</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">clicks</span><span class="p">(</span><span class="n">frames</span><span class="o">=</span><span class="n">beats</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Or use timing instead of frame indices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">times</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">frames_to_time</span><span class="p">(</span><span class="n">beats</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_beat_times</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">clicks</span><span class="p">(</span><span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Or with a click frequency of 880Hz and a 500ms sample</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_beat_times880</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">clicks</span><span class="p">(</span><span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
<span class="gp">... </span>                                 <span class="n">click_freq</span><span class="o">=</span><span class="mi">880</span><span class="p">,</span> <span class="n">click_duration</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>Display click waveform next to the spectrogram</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">melspectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">power_to_db</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">),</span>
<span class="gp">... </span>                         <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;mel&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">waveplot</span><span class="p">(</span><span class="n">y_beat_times</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Beat clicks&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.cqt">
<code class="descclassname">librosa.core.</code><code class="descname">cqt</code><span class="sig-paren">(</span><em>y</em>, <em>sr=22050</em>, <em>hop_length=512</em>, <em>fmin=None</em>, <em>n_bins=84</em>, <em>bins_per_octave=12</em>, <em>tuning=0.0</em>, <em>filter_scale=1</em>, <em>norm=1</em>, <em>sparsity=0.01</em>, <em>window='hann'</em>, <em>scale=True</em>, <em>pad_mode='reflect'</em>, <em>res_type=None</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.cqt" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the constant-Q transform of an audio signal.</p>
<p>This implementation is based on the recursive sub-sampling method
described by <a href="#id76"><span class="problematic" id="id1">[1]_</span></a>.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Schoerkhuber, Christian, and Anssi Klapuri.
“Constant-Q transform toolbox for music processing.”
7th Sound and Music Computing Conference, Barcelona, Spain. 2010.</td></tr>
</tbody>
</table>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd>audio time series</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>sampling rate of <cite>y</cite></dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>number of samples between successive CQT columns.</dd>
<dt>fmin <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd>Minimum frequency. Defaults to C1 ~= 32.70 Hz</dd>
<dt>n_bins <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>Number of frequency bins, starting at <cite>fmin</cite></dd>
<dt>bins_per_octave <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>Number of bins per octave</dd>
<dt>tuning <span class="classifier-delimiter">:</span> <span class="classifier">None or float</span></dt>
<dd><p class="first">Tuning offset in fractions of a bin.</p>
<p>If <cite>None</cite>, tuning will be automatically estimated from the signal.</p>
<p class="last">The minimum frequency of the resulting CQT will be modified to
<cite>fmin * 2**(tuning / bins_per_octave)</cite>.</p>
</dd>
<dt>filter_scale <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd>Filter scale factor. Small values (&lt;1) use shorter windows
for improved time resolution.</dd>
<dt>norm <span class="classifier-delimiter">:</span> <span class="classifier">{inf, -inf, 0, float &gt; 0}</span></dt>
<dd>Type of norm to use for basis function normalization.
See <cite>librosa.util.normalize</cite>.</dd>
<dt>sparsity <span class="classifier-delimiter">:</span> <span class="classifier">float in [0, 1)</span></dt>
<dd><p class="first">Sparsify the CQT basis by discarding up to <cite>sparsity</cite>
fraction of the energy in each basis.</p>
<p class="last">Set <cite>sparsity=0</cite> to disable sparsification.</p>
</dd>
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">str, tuple, number, or function</span></dt>
<dd>Window specification for the basis filters.
See <cite>filters.get_window</cite> for details.</dd>
<dt>scale <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first">If <cite>True</cite>, scale the CQT response by square-root the length of
each channel’s filter.  This is analogous to <cite>norm=’ortho’</cite> in FFT.</p>
<p class="last">If <cite>False</cite>, do not scale the CQT. This is analogous to
<cite>norm=None</cite> in FFT.</p>
</dd>
<dt>pad_mode <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first">Padding mode for centered frame analysis.</p>
<p class="last">See also: <cite>librosa.core.stft</cite> and <cite>np.pad</cite>.</p>
</dd>
<dt>res_type <span class="classifier-delimiter">:</span> <span class="classifier">string [optional]</span></dt>
<dd><p class="first">The resampling mode for recursive downsampling.</p>
<p>By default, <cite>cqt</cite> will adaptively select a resampling mode
which trades off accuracy at high frequencies for efficiency at low frequencies.</p>
<p class="last">You can override this by specifying a resampling mode as supported by
<cite>librosa.core.resample</cite>.  For example, <cite>res_type=’fft’</cite> will use a high-quality,
but potentially slow FFT-based down-sampling, while <cite>res_type=’polyphase’</cite> will
use a fast, but potentially inaccurate down-sampling.</p>
</dd>
</dl>
<dl class="docutils">
<dt>CQT <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n_bins, t), dtype=np.complex or np.float]</span></dt>
<dd>Constant-Q value each frequency at each time.</dd>
</dl>
<dl class="docutils">
<dt>ParameterError</dt>
<dd><p class="first">If <cite>hop_length</cite> is not an integer multiple of
<cite>2**(n_bins / bins_per_octave)</cite></p>
<p class="last">Or if <cite>y</cite> is too short to support the frequency range of the CQT.</p>
</dd>
</dl>
<p>librosa.core.resample
librosa.util.normalize</p>
<p>This function caches at level 20.</p>
<p>Generate and plot a constant-Q power spectrum</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">cqt</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">amplitude_to_db</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">),</span>
<span class="gp">... </span>                         <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;cqt_note&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%+2.0f</span><span class="s1"> dB&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Constant-Q power spectrum&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Limit the frequency range</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">cqt</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="n">librosa</span><span class="o">.</span><span class="n">note_to_hz</span><span class="p">(</span><span class="s1">&#39;C2&#39;</span><span class="p">),</span>
<span class="gp">... </span>                <span class="n">n_bins</span><span class="o">=</span><span class="mi">60</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span>
<span class="go">array([[  8.827e-04,   9.293e-04, ...,   3.133e-07,   2.942e-07],</span>
<span class="go">       [  1.076e-03,   1.068e-03, ...,   1.153e-06,   1.148e-06],</span>
<span class="go">       ...,</span>
<span class="go">       [  1.042e-07,   4.087e-07, ...,   1.612e-07,   1.928e-07],</span>
<span class="go">       [  2.363e-07,   5.329e-07, ...,   1.294e-07,   1.611e-07]])</span>
</pre></div>
</div>
<p>Using a higher frequency resolution</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">cqt</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="n">librosa</span><span class="o">.</span><span class="n">note_to_hz</span><span class="p">(</span><span class="s1">&#39;C2&#39;</span><span class="p">),</span>
<span class="gp">... </span>                <span class="n">n_bins</span><span class="o">=</span><span class="mi">60</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">bins_per_octave</span><span class="o">=</span><span class="mi">12</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span>
<span class="go">array([[  1.536e-05,   5.848e-05, ...,   3.241e-07,   2.453e-07],</span>
<span class="go">       [  1.856e-03,   1.854e-03, ...,   2.397e-08,   3.549e-08],</span>
<span class="go">       ...,</span>
<span class="go">       [  2.034e-07,   4.245e-07, ...,   6.213e-08,   1.463e-07],</span>
<span class="go">       [  4.896e-08,   5.407e-07, ...,   9.176e-08,   1.051e-07]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.cqt_frequencies">
<code class="descclassname">librosa.core.</code><code class="descname">cqt_frequencies</code><span class="sig-paren">(</span><em>n_bins</em>, <em>fmin</em>, <em>bins_per_octave=12</em>, <em>tuning=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.cqt_frequencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the center frequencies of Constant-Q bins.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Get the CQT frequencies for 24 notes, starting at C2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">cqt_frequencies</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="n">librosa</span><span class="o">.</span><span class="n">note_to_hz</span><span class="p">(</span><span class="s1">&#39;C2&#39;</span><span class="p">))</span>
<span class="go">array([  65.406,   69.296,   73.416,   77.782,   82.407,   87.307,</span>
<span class="go">         92.499,   97.999,  103.826,  110.   ,  116.541,  123.471,</span>
<span class="go">        130.813,  138.591,  146.832,  155.563,  164.814,  174.614,</span>
<span class="go">        184.997,  195.998,  207.652,  220.   ,  233.082,  246.942])</span>
</pre></div>
</div>
<dl class="docutils">
<dt>n_bins <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>Number of constant-Q bins</dd>
<dt>fmin <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd>Minimum frequency</dd>
<dt>bins_per_octave <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>Number of bins per octave</dd>
<dt>tuning <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Deviation from A440 tuning in fractional bins</dd>
</dl>
<dl class="docutils">
<dt>frequencies <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n_bins,)]</span></dt>
<dd>Center frequency for each CQT bin</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="librosa.core.db_to_amplitude">
<code class="descclassname">librosa.core.</code><code class="descname">db_to_amplitude</code><span class="sig-paren">(</span><em>S_db</em>, <em>ref=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.db_to_amplitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a dB-scaled spectrogram to an amplitude spectrogram.</p>
<p>This effectively inverts <cite>amplitude_to_db</cite>:</p>
<blockquote>
<div><cite>db_to_amplitude(S_db) ~= 10.0**(0.5 * (S_db + log10(ref)/10))</cite></div></blockquote>
<dl class="docutils">
<dt>S_db <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>dB-scaled spectrogram</dd>
<dt>ref: number &gt; 0</dt>
<dd>Optional reference power.</dd>
</dl>
<dl class="docutils">
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>Linear magnitude spectrogram</dd>
</dl>
<p>This function caches at level 30.</p>
</dd></dl>

<dl class="function">
<dt id="librosa.core.db_to_power">
<code class="descclassname">librosa.core.</code><code class="descname">db_to_power</code><span class="sig-paren">(</span><em>S_db</em>, <em>ref=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.db_to_power" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a dB-scale spectrogram to a power spectrogram.</p>
<p>This effectively inverts <cite>power_to_db</cite>:</p>
<blockquote>
<div><cite>db_to_power(S_db) ~= ref * 10.0**(S_db / 10)</cite></div></blockquote>
<dl class="docutils">
<dt>S_db <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>dB-scaled spectrogram</dd>
<dt>ref <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0</span></dt>
<dd>Reference power: output will be scaled by this value</dd>
</dl>
<dl class="docutils">
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>Power spectrogram</dd>
</dl>
<p>This function caches at level 30.</p>
</dd></dl>

<dl class="function">
<dt id="librosa.core.estimate_tuning">
<code class="descclassname">librosa.core.</code><code class="descname">estimate_tuning</code><span class="sig-paren">(</span><em>y=None</em>, <em>sr=22050</em>, <em>S=None</em>, <em>n_fft=2048</em>, <em>resolution=0.01</em>, <em>bins_per_octave=12</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.estimate_tuning" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the tuning of an audio time series or spectrogram input.</p>
<dl class="docutils">
<dt>y: np.ndarray [shape=(n,)] or None</dt>
<dd>audio signal</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>audio sampling rate of <cite>y</cite></dd>
<dt>S: np.ndarray [shape=(d, t)] or None</dt>
<dd>magnitude or power spectrogram</dd>
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar] or None</span></dt>
<dd>number of FFT bins to use, if <cite>y</cite> is provided.</dd>
<dt>resolution <span class="classifier-delimiter">:</span> <span class="classifier">float in <cite>(0, 1)</cite></span></dt>
<dd>Resolution of the tuning as a fraction of a bin.
0.01 corresponds to measurements in cents.</dd>
<dt>bins_per_octave <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>How many frequency bins per octave</dd>
<dt>kwargs <span class="classifier-delimiter">:</span> <span class="classifier">additional keyword arguments</span></dt>
<dd>Additional arguments passed to <cite>piptrack</cite></dd>
</dl>
<dl class="docutils">
<dt>tuning: float in <cite>[-0.5, 0.5)</cite></dt>
<dd>estimated tuning deviation (fractions of a bin)</dd>
</dl>
<dl class="docutils">
<dt>piptrack</dt>
<dd>Pitch tracking by parabolic interpolation</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># With time-series input</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">estimate_tuning</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="go">0.089999999999999969</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># In tenths of a cent</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">estimate_tuning</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">)</span>
<span class="go">0.093999999999999972</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Using spectrogram input</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">estimate_tuning</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="go">0.089999999999999969</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Using pass-through arguments to `librosa.piptrack`</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">estimate_tuning</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">8192</span><span class="p">,</span>
<span class="gp">... </span>                        <span class="n">fmax</span><span class="o">=</span><span class="n">librosa</span><span class="o">.</span><span class="n">note_to_hz</span><span class="p">(</span><span class="s1">&#39;G#9&#39;</span><span class="p">))</span>
<span class="go">0.070000000000000062</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.fft_frequencies">
<code class="descclassname">librosa.core.</code><code class="descname">fft_frequencies</code><span class="sig-paren">(</span><em>sr=22050</em>, <em>n_fft=2048</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.fft_frequencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Alternative implementation of <cite>np.fft.fftfreq</cite></p>
<dl class="docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>Audio sampling rate</dd>
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>FFT window size</dd>
</dl>
<dl class="docutils">
<dt>freqs <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(1 + n_fft/2,)]</span></dt>
<dd>Frequencies <cite>(0, sr/n_fft, 2*sr/n_fft, …, sr/2)</cite></dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="go">array([     0.   ,   1378.125,   2756.25 ,   4134.375,</span>
<span class="go">         5512.5  ,   6890.625,   8268.75 ,   9646.875,  11025.   ])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.fmt">
<code class="descclassname">librosa.core.</code><code class="descname">fmt</code><span class="sig-paren">(</span><em>y</em>, <em>t_min=0.5</em>, <em>n_fmt=None</em>, <em>kind='cubic'</em>, <em>beta=0.5</em>, <em>over_sample=1</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.fmt" title="Permalink to this definition">¶</a></dt>
<dd><p>The fast Mellin transform (FMT) <a href="#id77"><span class="problematic" id="id3">[1]_</span></a> of a uniformly sampled signal y.</p>
<p>When the Mellin parameter (beta) is 1/2, it is also known as the scale transform <a href="#id78"><span class="problematic" id="id4">[2]_</span></a>.
The scale transform can be useful for audio analysis because its magnitude is invariant
to scaling of the domain (e.g., time stretching or compression).  This is analogous
to the magnitude of the Fourier transform being invariant to shifts in the input domain.</p>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>De Sena, Antonio, and Davide Rocchesso.
“A fast Mellin and scale transform.”
EURASIP Journal on Applied Signal Processing 2007.1 (2007): 75-75.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>Cohen, L.
“The scale representation.”
IEEE Transactions on Signal Processing 41, no. 12 (1993): 3275-3292.</td></tr>
</tbody>
</table>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, real-valued</span></dt>
<dd>The input signal(s).  Can be multidimensional.
The target axis must contain at least 3 samples.</dd>
<dt>t_min <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd>The minimum time spacing (in samples).
This value should generally be less than 1 to preserve as much information as
possible.</dd>
<dt>n_fmt <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 2 or None</span></dt>
<dd>The number of scale transform bins to use.
If None, then <cite>n_bins = over_sample * ceil(n * log((n-1)/t_min))</cite> is taken,
where <cite>n = y.shape[axis]</cite></dd>
<dt>kind <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first">The type of interpolation to use when re-sampling the input.
See <cite>scipy.interpolate.interp1d</cite> for possible values.</p>
<p class="last">Note that the default is to use high-precision (cubic) interpolation.
This can be slow in practice; if speed is preferred over accuracy,
then consider using <cite>kind=’linear’</cite>.</p>
</dd>
<dt>beta <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>The Mellin parameter.  <cite>beta=0.5</cite> provides the scale transform.</dd>
<dt>over_sample <span class="classifier-delimiter">:</span> <span class="classifier">float &gt;= 1</span></dt>
<dd>Over-sampling factor for exponential resampling.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The axis along which to transform <cite>y</cite></dd>
</dl>
<dl class="docutils">
<dt>x_scale <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [dtype=complex]</span></dt>
<dd>The scale transform of <cite>y</cite> along the <cite>axis</cite> dimension.</dd>
</dl>
<dl class="docutils">
<dt>ParameterError</dt>
<dd>if <cite>n_fmt &lt; 2</cite> or <cite>t_min &lt;= 0</cite>
or if <cite>y</cite> is not finite
or if <cite>y.shape[axis] &lt; 3</cite>.</dd>
</dl>
<p>This function caches at level 30.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate a signal and time-stretch it (with energy normalization)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scale</span> <span class="o">=</span> <span class="mf">1.25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="mf">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">scale</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">freq</span> <span class="o">*</span> <span class="n">x1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">freq</span> <span class="o">*</span> <span class="n">x2</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Verify that the two signals have the same energy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">    (255.99999999999997, 255.99999999999969)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scale1</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">fmt</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">n_fmt</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scale2</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">fmt</span><span class="p">(</span><span class="n">y2</span><span class="p">,</span> <span class="n">n_fmt</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># And plot the results</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Original&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">y2</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Stretched&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;time (samples)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Input signals&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">scale1</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Original&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">scale2</span><span class="p">),</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Stretched&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;scale coefficients&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Scale transform magnitude&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Plot the scale transform of an onset strength autocorrelation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">(),</span>
<span class="gp">... </span>                     <span class="n">offset</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mf">30.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">odf</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">onset</span><span class="o">.</span><span class="n">onset_strength</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Auto-correlate with up to 10 seconds lag</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">odf_ac</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">autocorrelate</span><span class="p">(</span><span class="n">odf</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="mi">10</span> <span class="o">*</span> <span class="n">sr</span> <span class="o">//</span> <span class="mi">512</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Normalize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">odf_ac</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">odf_ac</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute the scale transform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">odf_ac_scale</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">fmt</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">odf_ac</span><span class="p">),</span> <span class="n">n_fmt</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Plot the results</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">odf</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Onset strength&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (frames)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">odf_ac</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Onset autocorrelation&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Lag (frames)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">odf_ac_scale</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Scale transform magnitude&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;scale coefficients&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.fourier_tempo_frequencies">
<code class="descclassname">librosa.core.</code><code class="descname">fourier_tempo_frequencies</code><span class="sig-paren">(</span><em>sr=22050</em>, <em>win_length=384</em>, <em>hop_length=512</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.fourier_tempo_frequencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the frequencies (in beats per minute) corresponding
to a Fourier tempogram matrix.</p>
<dl class="docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0</span></dt>
<dd>The audio sampling rate</dd>
<dt>win_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>The number of frames per analysis window</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>The number of samples between each bin</dd>
</dl>
<dl class="docutils">
<dt>bin_frequencies <span class="classifier-delimiter">:</span> <span class="classifier">ndarray [shape=(win_length // 2 + 1 ,)]</span></dt>
<dd>vector of bin frequencies measured in BPM.</dd>
</dl>
<p>Get the tempo frequencies corresponding to a 384-bin (8-second) tempogram</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">fourier_tempo_frequencies</span><span class="p">(</span><span class="mi">384</span><span class="p">)</span>
<span class="go">array([ 0.   ,  0.117,  0.234, ..., 22.266, 22.383, 22.5  ])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.frames_to_samples">
<code class="descclassname">librosa.core.</code><code class="descname">frames_to_samples</code><span class="sig-paren">(</span><em>frames</em>, <em>hop_length=512</em>, <em>n_fft=None</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.frames_to_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts frame indices to audio sample indices.</p>
<dl class="docutils">
<dt>frames <span class="classifier-delimiter">:</span> <span class="classifier">number or np.ndarray [shape=(n,)]</span></dt>
<dd>frame index or vector of frame indices</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>number of samples between successive frames</dd>
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">None or int &gt; 0 [scalar]</span></dt>
<dd>Optional: length of the FFT window.
If given, time conversion will include an offset of <cite>n_fft / 2</cite>
to counteract windowing effects when using a non-centered STFT.</dd>
</dl>
<dl class="docutils">
<dt>times <span class="classifier-delimiter">:</span> <span class="classifier">number or np.ndarray</span></dt>
<dd>time (in samples) of each given frame number:
<cite>times[i] = frames[i] * hop_length</cite></dd>
</dl>
<p>frames_to_time : convert frame indices to time values
samples_to_frames : convert sample indices to frame indices</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tempo</span><span class="p">,</span> <span class="n">beats</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">beat_track</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">beat_samples</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">frames_to_samples</span><span class="p">(</span><span class="n">beats</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.frames_to_time">
<code class="descclassname">librosa.core.</code><code class="descname">frames_to_time</code><span class="sig-paren">(</span><em>frames</em>, <em>sr=22050</em>, <em>hop_length=512</em>, <em>n_fft=None</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.frames_to_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts frame counts to time (seconds).</p>
<dl class="docutils">
<dt>frames <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd>frame index or vector of frame indices</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>audio sampling rate</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>number of samples between successive frames</dd>
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">None or int &gt; 0 [scalar]</span></dt>
<dd>Optional: length of the FFT window.
If given, time conversion will include an offset of <cite>n_fft / 2</cite>
to counteract windowing effects when using a non-centered STFT.</dd>
</dl>
<dl class="docutils">
<dt>times <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd>time (in seconds) of each given frame number:
<cite>times[i] = frames[i] * hop_length / sr</cite></dd>
</dl>
<p>time_to_frames : convert time values to frame indices
frames_to_samples : convert frame indices to sample indices</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tempo</span><span class="p">,</span> <span class="n">beats</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">beat_track</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">beat_times</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">frames_to_time</span><span class="p">(</span><span class="n">beats</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.get_duration">
<code class="descclassname">librosa.core.</code><code class="descname">get_duration</code><span class="sig-paren">(</span><em>y=None</em>, <em>sr=22050</em>, <em>S=None</em>, <em>n_fft=2048</em>, <em>hop_length=512</em>, <em>center=True</em>, <em>filename=None</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.get_duration" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the duration (in seconds) of an audio time series,
feature matrix, or filename.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Load the example audio file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">get_duration</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="go">61.45886621315193</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Or directly from an audio file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">get_duration</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="go">61.4</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Or compute duration from an STFT matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">get_duration</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="go">61.44</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Or a non-centered STFT matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S_left</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">get_duration</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S_left</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="go">61.3471201814059</span>
</pre></div>
</div>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,), (2, n)] or None</span></dt>
<dd>audio time series</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>audio sampling rate of <cite>y</cite></dd>
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)] or None</span></dt>
<dd>STFT matrix, or any STFT-derived matrix (e.g., chromagram
or mel spectrogram).
Durations calculated from spectrogram inputs are only accurate
up to the frame resolution. If high precision is required,
it is better to use the audio time series directly.</dd>
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>FFT window size for <cite>S</cite></dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [ scalar]</span></dt>
<dd>number of audio samples between columns of <cite>S</cite></dd>
<dt>center <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><ul class="first last simple">
<li>If <cite>True</cite>, <cite>S[:, t]</cite> is centered at <cite>y[t * hop_length]</cite></li>
<li>If <cite>False</cite>, then <cite>S[:, t]</cite> begins at <cite>y[t * hop_length]</cite></li>
</ul>
</dd>
<dt>filename <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first">If provided, all other parameters are ignored, and the
duration is calculated directly from the audio file.
Note that this avoids loading the contents into memory,
and is therefore useful for querying the duration of
long files.</p>
<p class="last">As in <cite>load()</cite>, this can also be an integer or open file-handle
that can be processed by <cite>soundfile</cite>.</p>
</dd>
</dl>
<dl class="docutils">
<dt>d <span class="classifier-delimiter">:</span> <span class="classifier">float &gt;= 0</span></dt>
<dd>Duration (in seconds) of the input time series or spectrogram.</dd>
</dl>
<dl class="docutils">
<dt>ParameterError</dt>
<dd>if none of <cite>y</cite>, <cite>S</cite>, or <cite>filename</cite> are provided.</dd>
</dl>
<p><cite>get_duration</cite> can be applied to a file (<cite>filename</cite>), a spectrogram (<cite>S</cite>),
or audio buffer (<cite>y, sr</cite>).  Only one of these three options should be
provided.  If you do provide multiple options (e.g., <cite>filename</cite> and <cite>S</cite>),
then <cite>filename</cite> takes precedence over <cite>S</cite>, and <cite>S</cite> takes precedence over
<cite>(y, sr)</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="librosa.core.get_fftlib">
<code class="descclassname">librosa.core.</code><code class="descname">get_fftlib</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.get_fftlib" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the FFT library currently used by librosa</p>
<dl class="docutils">
<dt>fft <span class="classifier-delimiter">:</span> <span class="classifier">module</span></dt>
<dd>The FFT library currently used by librosa.
Must API-compatible with <cite>numpy.fft</cite>.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="librosa.core.get_samplerate">
<code class="descclassname">librosa.core.</code><code class="descname">get_samplerate</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.get_samplerate" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the sampling rate for a given file.</p>
<dl class="docutils">
<dt>path <span class="classifier-delimiter">:</span> <span class="classifier">string, int, or file-like</span></dt>
<dd>The path to the file to be loaded
As in <cite>load()</cite>, this can also be an integer or open file-handle
that can be processed by <cite>soundfile</cite>.</dd>
</dl>
<dl class="docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0</span></dt>
<dd>The sampling rate of the given audio file</dd>
</dl>
<p>Get the sampling rate for the included audio file</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">get_samplerate</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="go">44100</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.griffinlim">
<code class="descclassname">librosa.core.</code><code class="descname">griffinlim</code><span class="sig-paren">(</span><em>S</em>, <em>n_iter=32</em>, <em>hop_length=None</em>, <em>win_length=None</em>, <em>window='hann'</em>, <em>center=True</em>, <em>dtype=&lt;class 'numpy.float32'&gt;</em>, <em>length=None</em>, <em>pad_mode='reflect'</em>, <em>momentum=0.99</em>, <em>init='random'</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.griffinlim" title="Permalink to this definition">¶</a></dt>
<dd><p>Approximate magnitude spectrogram inversion using the “fast” Griffin-Lim algorithm <a href="#id79"><span class="problematic" id="id7">[1]_</span></a> <a href="#id80"><span class="problematic" id="id8">[2]_</span></a>.</p>
<p>Given a short-time Fourier transform magnitude matrix (<cite>S</cite>), the algorithm randomly
initializes phase estimates, and then alternates forward- and inverse-STFT
operations.
Note that this assumes reconstruction of a real-valued time-domain signal, and
that <cite>S</cite> contains only the non-negative frequencies (as computed by
<cite>core.stft</cite>).</p>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Perraudin, N., Balazs, P., &amp; Søndergaard, P. L.
“A fast Griffin-Lim algorithm,”
IEEE Workshop on Applications of Signal Processing to Audio and Acoustics (pp. 1-4),
Oct. 2013.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>D. W. Griffin and J. S. Lim,
“Signal estimation from modified short-time Fourier transform,”
IEEE Trans. ASSP, vol.32, no.2, pp.236–243, Apr. 1984.</td></tr>
</tbody>
</table>
<dl class="docutils">
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n_fft / 2 + 1, t), non-negative]</span></dt>
<dd>An array of short-time Fourier transform magnitudes as produced by
<cite>core.stft</cite>.</dd>
<dt>n_iter <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>The number of iterations to run</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">None or int &gt; 0</span></dt>
<dd>The hop length of the STFT.  If not provided, it will default to <cite>n_fft // 4</cite></dd>
<dt>win_length <span class="classifier-delimiter">:</span> <span class="classifier">None or int &gt; 0</span></dt>
<dd>The window length of the STFT.  By default, it will equal <cite>n_fft</cite></dd>
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span></dt>
<dd>A window specification as supported by <cite>stft</cite> or <cite>istft</cite></dd>
<dt>center <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>If <cite>True</cite>, the STFT is assumed to use centered frames.
If <cite>False</cite>, the STFT is assumed to use left-aligned frames.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">np.dtype</span></dt>
<dd>Real numeric type for the time-domain signal.  Default is 32-bit float.</dd>
<dt>length <span class="classifier-delimiter">:</span> <span class="classifier">None or int &gt; 0</span></dt>
<dd>If provided, the output <cite>y</cite> is zero-padded or clipped to exactly <cite>length</cite>
samples.</dd>
<dt>pad_mode <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>If <cite>center=True</cite>, the padding mode to use at the edges of the signal.
By default, STFT uses reflection padding.</dd>
<dt>momentum <span class="classifier-delimiter">:</span> <span class="classifier">number &gt;= 0</span></dt>
<dd>The momentum parameter for fast Griffin-Lim.
Setting this to 0 recovers the original Griffin-Lim method <a href="#id81"><span class="problematic" id="id11">[1]_</span></a>.
Values near 1 can lead to faster convergence, but above 1 may not converge.</dd>
<dt>init <span class="classifier-delimiter">:</span> <span class="classifier">None or ‘random’ [default]</span></dt>
<dd><p class="first">If ‘random’ (the default), then phase values are initialized randomly
according to <cite>random_state</cite>.  This is recommended when the input <cite>S</cite> is
a magnitude spectrogram with no initial phase estimates.</p>
<p class="last">If <cite>None</cite>, then the phase is initialized from <cite>S</cite>.  This is useful when
an initial guess for phase can be provided, or when you want to resume
Griffin-Lim from a previous output.</p>
</dd>
<dt>random_state <span class="classifier-delimiter">:</span> <span class="classifier">None, int, or np.random.RandomState</span></dt>
<dd><p class="first">If int, random_state is the seed used by the random number generator
for phase initialization.</p>
<p>If <cite>np.random.RandomState</cite> instance, the random number
generator itself.</p>
<p class="last">If <cite>None</cite>, defaults to the current <cite>np.random</cite> object.</p>
</dd>
</dl>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd>time-domain signal reconstructed from <cite>S</cite></dd>
</dl>
<p>stft
istft
magphase
filters.get_window</p>
<p>A basic STFT inverse example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">(),</span> <span class="n">duration</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Get the magnitude spectrogram</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Invert using Griffin-Lim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_inv</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">griffinlim</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Invert without estimating phase</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_istft</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">istft</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
</pre></div>
</div>
<p>Wave-plot the results</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">waveplot</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Original&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">waveplot</span><span class="p">(</span><span class="n">y_inv</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Griffin-Lim reconstruction&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">waveplot</span><span class="p">(</span><span class="n">y_istft</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Magnitude-only istft reconstruction&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.griffinlim_cqt">
<code class="descclassname">librosa.core.</code><code class="descname">griffinlim_cqt</code><span class="sig-paren">(</span><em>C</em>, <em>n_iter=32</em>, <em>sr=22050</em>, <em>hop_length=512</em>, <em>fmin=None</em>, <em>bins_per_octave=12</em>, <em>tuning=0.0</em>, <em>filter_scale=1</em>, <em>norm=1</em>, <em>sparsity=0.01</em>, <em>window='hann'</em>, <em>scale=True</em>, <em>pad_mode='reflect'</em>, <em>res_type='kaiser_fast'</em>, <em>dtype=&lt;class 'numpy.float32'&gt;</em>, <em>length=None</em>, <em>momentum=0.99</em>, <em>init='random'</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.griffinlim_cqt" title="Permalink to this definition">¶</a></dt>
<dd><p>Approximate constant-Q magnitude spectrogram inversion using the “fast” Griffin-Lim
algorithm <a href="#id82"><span class="problematic" id="id12">[1]_</span></a> <a href="#id83"><span class="problematic" id="id13">[2]_</span></a>.</p>
<p>Given the magnitude of a constant-Q spectrogram (<cite>C</cite>), the algorithm randomly initializes
phase estimates, and then alternates forward- and inverse-CQT operations.</p>
<p>This implementation is based on the Griffin-Lim method for Short-time Fourier Transforms,
but adapted for use with constant-Q spectrograms.</p>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Perraudin, N., Balazs, P., &amp; Søndergaard, P. L.
“A fast Griffin-Lim algorithm,”
IEEE Workshop on Applications of Signal Processing to Audio and Acoustics (pp. 1-4),
Oct. 2013.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>D. W. Griffin and J. S. Lim,
“Signal estimation from modified short-time Fourier transform,”
IEEE Trans. ASSP, vol.32, no.2, pp.236–243, Apr. 1984.</td></tr>
</tbody>
</table>
<dl class="docutils">
<dt>C <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n_bins, n_frames)]</span></dt>
<dd>The constant-Q magnitude spectrogram</dd>
<dt>n_iter <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>The number of iterations to run</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0</span></dt>
<dd>Audio sampling rate</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>The hop length of the CQT</dd>
<dt>fmin <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 </span></dt>
<dd><p class="first">Minimum frequency for the CQT.</p>
<p class="last">If not provided, it defaults to C1.</p>
</dd>
<dt>bins_per_octave <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>Number of bins per octave</dd>
<dt>tuning <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Tuning deviation from A440, in fractions of a bin</dd>
<dt>filter_scale <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd>Filter scale factor. Small values (&lt;1) use shorter windows
for improved time resolution.</dd>
<dt>norm <span class="classifier-delimiter">:</span> <span class="classifier">{inf, -inf, 0, float &gt; 0}</span></dt>
<dd>Type of norm to use for basis function normalization.
See <cite>librosa.util.normalize</cite>.</dd>
<dt>sparsity <span class="classifier-delimiter">:</span> <span class="classifier">float in [0, 1)</span></dt>
<dd><p class="first">Sparsify the CQT basis by discarding up to <cite>sparsity</cite>
fraction of the energy in each basis.</p>
<p class="last">Set <cite>sparsity=0</cite> to disable sparsification.</p>
</dd>
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">str, tuple, or function</span></dt>
<dd>Window specification for the basis filters.
See <cite>filters.get_window</cite> for details.</dd>
<dt>scale <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first">If <cite>True</cite>, scale the CQT response by square-root the length
of each channel’s filter.  This is analogous to <cite>norm=’ortho’</cite>
in FFT.</p>
<p class="last">If <cite>False</cite>, do not scale the CQT. This is analogous to <cite>norm=None</cite>
in FFT.</p>
</dd>
<dt>pad_mode <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first">Padding mode for centered frame analysis.</p>
<p class="last">See also: <cite>librosa.core.stft</cite> and <cite>np.pad</cite></p>
</dd>
<dt>res_type <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first">The resampling mode for recursive downsampling.</p>
<p>By default, CQT uses an adaptive mode selection to
trade accuracy at high frequencies for efficiency at low
frequencies.</p>
<p>Griffin-Lim uses the efficient (fast) resampling mode by default.</p>
<p class="last">See <cite>librosa.core.resample</cite> for a list of available options.</p>
</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">numeric type</span></dt>
<dd>Real numeric type for <cite>y</cite>.  Default is 32-bit float.</dd>
<dt>length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0, optional</span></dt>
<dd>If provided, the output <cite>y</cite> is zero-padded or clipped to exactly
<cite>length</cite> samples.</dd>
<dt>momentum <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd>The momentum parameter for fast Griffin-Lim.
Setting this to 0 recovers the original Griffin-Lim method <a href="#id84"><span class="problematic" id="id16">[1]_</span></a>.
Values near 1 can lead to faster convergence, but above 1 may not converge.</dd>
<dt>init <span class="classifier-delimiter">:</span> <span class="classifier">None or ‘random’ [default]</span></dt>
<dd><p class="first">If ‘random’ (the default), then phase values are initialized randomly
according to <cite>random_state</cite>.  This is recommended when the input <cite>C</cite> is
a magnitude spectrogram with no initial phase estimates.</p>
<p class="last">If <cite>None</cite>, then the phase is initialized from <cite>C</cite>.  This is useful when
an initial guess for phase can be provided, or when you want to resume
Griffin-Lim from a previous output.</p>
</dd>
<dt>random_state <span class="classifier-delimiter">:</span> <span class="classifier">None, int, or np.random.RandomState</span></dt>
<dd><p class="first">If int, random_state is the seed used by the random number generator
for phase initialization.</p>
<p>If <cite>np.random.RandomState</cite> instance, the random number generator itself.</p>
<p class="last">If <cite>None</cite>, defaults to the current <cite>np.random</cite> object.</p>
</dd>
</dl>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd>time-domain signal reconstructed from <cite>C</cite></dd>
</dl>
<p>cqt
icqt
griffinlim
filters.get_window
resample</p>
<p>A basis CQT inverse example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">(),</span> <span class="n">duration</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Get the CQT magnitude, 7 octaves at 36 bins per octave</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">cqt</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">bins_per_octave</span><span class="o">=</span><span class="mi">36</span><span class="p">,</span> <span class="n">n_bins</span><span class="o">=</span><span class="mi">7</span><span class="o">*</span><span class="mi">36</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Invert using Griffin-Lim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_inv</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">griffinlim_cqt</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">bins_per_octave</span><span class="o">=</span><span class="mi">36</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># And invert without estimating phase</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_icqt</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">icqt</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">bins_per_octave</span><span class="o">=</span><span class="mi">36</span><span class="p">)</span>
</pre></div>
</div>
<p>Wave-plot the results</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">waveplot</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Original&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">waveplot</span><span class="p">(</span><span class="n">y_inv</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Griffin-Lim reconstruction&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">waveplot</span><span class="p">(</span><span class="n">y_icqt</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Magnitude-only icqt reconstruction&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.hybrid_cqt">
<code class="descclassname">librosa.core.</code><code class="descname">hybrid_cqt</code><span class="sig-paren">(</span><em>y</em>, <em>sr=22050</em>, <em>hop_length=512</em>, <em>fmin=None</em>, <em>n_bins=84</em>, <em>bins_per_octave=12</em>, <em>tuning=0.0</em>, <em>filter_scale=1</em>, <em>norm=1</em>, <em>sparsity=0.01</em>, <em>window='hann'</em>, <em>scale=True</em>, <em>pad_mode='reflect'</em>, <em>res_type=None</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.hybrid_cqt" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the hybrid constant-Q transform of an audio signal.</p>
<p>Here, the hybrid CQT uses the pseudo CQT for higher frequencies where
the hop_length is longer than half the filter length and the full CQT
for lower frequencies.</p>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd>audio time series</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>sampling rate of <cite>y</cite></dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>number of samples between successive CQT columns.</dd>
<dt>fmin <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd>Minimum frequency. Defaults to C1 ~= 32.70 Hz</dd>
<dt>n_bins <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>Number of frequency bins, starting at <cite>fmin</cite></dd>
<dt>bins_per_octave <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>Number of bins per octave</dd>
<dt>tuning <span class="classifier-delimiter">:</span> <span class="classifier">None or float</span></dt>
<dd><p class="first">Tuning offset in fractions of a bin.</p>
<p>If <cite>None</cite>, tuning will be automatically estimated from the signal.</p>
<p class="last">The minimum frequency of the resulting CQT will be modified to
<cite>fmin * 2**(tuning / bins_per_octave)</cite>.</p>
</dd>
<dt>filter_scale <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd>Filter filter_scale factor. Larger values use longer windows.</dd>
<dt>sparsity <span class="classifier-delimiter">:</span> <span class="classifier">float in [0, 1)</span></dt>
<dd><p class="first">Sparsify the CQT basis by discarding up to <cite>sparsity</cite>
fraction of the energy in each basis.</p>
<p class="last">Set <cite>sparsity=0</cite> to disable sparsification.</p>
</dd>
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">str, tuple, number, or function</span></dt>
<dd>Window specification for the basis filters.
See <cite>filters.get_window</cite> for details.</dd>
<dt>pad_mode <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first">Padding mode for centered frame analysis.</p>
<p class="last">See also: <cite>librosa.core.stft</cite> and <cite>np.pad</cite>.</p>
</dd>
<dt>res_type <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>Resampling mode.  See <cite>librosa.core.cqt</cite> for details.</dd>
</dl>
<dl class="docutils">
<dt>CQT <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n_bins, t), dtype=np.float]</span></dt>
<dd>Constant-Q energy for each frequency at each time.</dd>
</dl>
<dl class="docutils">
<dt>ParameterError</dt>
<dd><p class="first">If <cite>hop_length</cite> is not an integer multiple of
<cite>2**(n_bins / bins_per_octave)</cite></p>
<p class="last">Or if <cite>y</cite> is too short to support the frequency range of the CQT.</p>
</dd>
</dl>
<p>cqt
pseudo_cqt</p>
<p>This function caches at level 20.</p>
</dd></dl>

<dl class="function">
<dt id="librosa.core.hz_to_mel">
<code class="descclassname">librosa.core.</code><code class="descname">hz_to_mel</code><span class="sig-paren">(</span><em>frequencies</em>, <em>htk=False</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.hz_to_mel" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Hz to Mels</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">hz_to_mel</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
<span class="go">0.9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">hz_to_mel</span><span class="p">([</span><span class="mi">110</span><span class="p">,</span> <span class="mi">220</span><span class="p">,</span> <span class="mi">440</span><span class="p">])</span>
<span class="go">array([ 1.65,  3.3 ,  6.6 ])</span>
</pre></div>
</div>
<dl class="docutils">
<dt>frequencies <span class="classifier-delimiter">:</span> <span class="classifier">number or np.ndarray [shape=(n,)] , float</span></dt>
<dd>scalar or array of frequencies</dd>
<dt>htk <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>use HTK formula instead of Slaney</dd>
</dl>
<dl class="docutils">
<dt>mels <span class="classifier-delimiter">:</span> <span class="classifier">number or np.ndarray [shape=(n,)]</span></dt>
<dd>input frequencies in Mels</dd>
</dl>
<p>mel_to_hz</p>
</dd></dl>

<dl class="function">
<dt id="librosa.core.hz_to_midi">
<code class="descclassname">librosa.core.</code><code class="descname">hz_to_midi</code><span class="sig-paren">(</span><em>frequencies</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.hz_to_midi" title="Permalink to this definition">¶</a></dt>
<dd><p>Get MIDI note number(s) for given frequencies</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">hz_to_midi</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
<span class="go">34.506</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">hz_to_midi</span><span class="p">([</span><span class="mi">110</span><span class="p">,</span> <span class="mi">220</span><span class="p">,</span> <span class="mi">440</span><span class="p">])</span>
<span class="go">array([ 45.,  57.,  69.])</span>
</pre></div>
</div>
<dl class="docutils">
<dt>frequencies <span class="classifier-delimiter">:</span> <span class="classifier">float or np.ndarray [shape=(n,), dtype=float]</span></dt>
<dd>frequencies to convert</dd>
</dl>
<dl class="docutils">
<dt>note_nums <span class="classifier-delimiter">:</span> <span class="classifier">number or np.ndarray [shape=(n,), dtype=float]</span></dt>
<dd>MIDI notes to <cite>frequencies</cite></dd>
</dl>
<p>midi_to_hz
note_to_midi
hz_to_note</p>
</dd></dl>

<dl class="function">
<dt id="librosa.core.hz_to_note">
<code class="descclassname">librosa.core.</code><code class="descname">hz_to_note</code><span class="sig-paren">(</span><em>frequencies</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.hz_to_note" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert one or more frequencies (in Hz) to the nearest note names.</p>
<dl class="docutils">
<dt>frequencies <span class="classifier-delimiter">:</span> <span class="classifier">float or iterable of float</span></dt>
<dd>Input frequencies, specified in Hz</dd>
<dt>kwargs <span class="classifier-delimiter">:</span> <span class="classifier">additional keyword arguments</span></dt>
<dd>Arguments passed through to <cite>midi_to_note</cite></dd>
</dl>
<dl class="docutils">
<dt>notes <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><cite>notes[i]</cite> is the closest note name to <cite>frequency[i]</cite>
(or <cite>frequency</cite> if the input is scalar)</dd>
</dl>
<p>hz_to_midi
midi_to_note
note_to_hz</p>
<p>Get a single note name for a frequency</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">hz_to_note</span><span class="p">(</span><span class="mf">440.0</span><span class="p">)</span>
<span class="go">[&#39;A5&#39;]</span>
</pre></div>
</div>
<p>Get multiple notes with cent deviation</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">hz_to_note</span><span class="p">([</span><span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">],</span> <span class="n">cents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[&#39;C1-38&#39;, &#39;C2-38&#39;]</span>
</pre></div>
</div>
<p>Get multiple notes, but suppress octave labels</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">hz_to_note</span><span class="p">(</span><span class="mf">440.0</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">)),</span>
<span class="gp">... </span>                   <span class="n">octave</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[&#39;A&#39;, &#39;A#&#39;, &#39;B&#39;, &#39;C&#39;, &#39;C#&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;F#&#39;, &#39;G&#39;, &#39;G#&#39;, &#39;A&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.hz_to_octs">
<code class="descclassname">librosa.core.</code><code class="descname">hz_to_octs</code><span class="sig-paren">(</span><em>frequencies</em>, <em>tuning=0.0</em>, <em>bins_per_octave=12</em>, <em>A440=&lt;DEPRECATED parameter&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.hz_to_octs" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert frequencies (Hz) to (fractional) octave numbers.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">hz_to_octs</span><span class="p">(</span><span class="mf">440.0</span><span class="p">)</span>
<span class="go">4.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">hz_to_octs</span><span class="p">([</span><span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">256</span><span class="p">])</span>
<span class="go">array([ 0.219,  1.219,  2.219,  3.219])</span>
</pre></div>
</div>
<dl class="docutils">
<dt>frequencies <span class="classifier-delimiter">:</span> <span class="classifier">number &gt;0 or np.ndarray [shape=(n,)] or float</span></dt>
<dd>scalar or vector of frequencies</dd>
<dt>tuning <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Tuning deviation from A440 in (fractional) bins per octave.</dd>
<dt>bins_per_octave <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>Number of bins per octave.</dd>
<dt>A440 <span class="classifier-delimiter">:</span> <span class="classifier">float &lt;DEPRECATED&gt;</span></dt>
<dd><p class="first">frequency of A440 (in Hz)</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This parameter is deprecated in 0.7.1 and will be removed
in version 0.8.0.  Use <cite>tuning=</cite> instead.</p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>octaves <span class="classifier-delimiter">:</span> <span class="classifier">number or np.ndarray [shape=(n,)]</span></dt>
<dd>octave number for each frequency</dd>
</dl>
<p>octs_to_hz</p>
</dd></dl>

<dl class="function">
<dt id="librosa.core.icqt">
<code class="descclassname">librosa.core.</code><code class="descname">icqt</code><span class="sig-paren">(</span><em>C</em>, <em>sr=22050</em>, <em>hop_length=512</em>, <em>fmin=None</em>, <em>bins_per_octave=12</em>, <em>tuning=0.0</em>, <em>filter_scale=1</em>, <em>norm=1</em>, <em>sparsity=0.01</em>, <em>window='hann'</em>, <em>scale=True</em>, <em>length=None</em>, <em>amin=&lt;DEPRECATED parameter&gt;</em>, <em>res_type='fft'</em>, <em>dtype=&lt;class 'numpy.float32'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.icqt" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the inverse constant-Q transform.</p>
<p>Given a constant-Q transform representation <cite>C</cite> of an audio signal <cite>y</cite>,
this function produces an approximation <cite>y_hat</cite>.</p>
<dl class="docutils">
<dt>C <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, [shape=(n_bins, n_frames)]</span></dt>
<dd>Constant-Q representation as produced by <cite>core.cqt</cite></dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>number of samples between successive frames</dd>
<dt>fmin <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd>Minimum frequency. Defaults to C1 ~= 32.70 Hz</dd>
<dt>tuning <span class="classifier-delimiter">:</span> <span class="classifier">float [scalar]</span></dt>
<dd><p class="first">Tuning offset in fractions of a bin.</p>
<p class="last">The minimum frequency of the CQT will be modified to
<cite>fmin * 2**(tuning / bins_per_octave)</cite>.</p>
</dd>
<dt>filter_scale <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd>Filter scale factor. Small values (&lt;1) use shorter windows
for improved time resolution.</dd>
<dt>norm <span class="classifier-delimiter">:</span> <span class="classifier">{inf, -inf, 0, float &gt; 0}</span></dt>
<dd>Type of norm to use for basis function normalization.
See <cite>librosa.util.normalize</cite>.</dd>
<dt>sparsity <span class="classifier-delimiter">:</span> <span class="classifier">float in [0, 1)</span></dt>
<dd><p class="first">Sparsify the CQT basis by discarding up to <cite>sparsity</cite>
fraction of the energy in each basis.</p>
<p class="last">Set <cite>sparsity=0</cite> to disable sparsification.</p>
</dd>
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">str, tuple, number, or function</span></dt>
<dd>Window specification for the basis filters.
See <cite>filters.get_window</cite> for details.</dd>
<dt>scale <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first">If <cite>True</cite>, scale the CQT response by square-root the length
of each channel’s filter. This is analogous to <cite>norm=’ortho’</cite> in FFT.</p>
<p class="last">If <cite>False</cite>, do not scale the CQT. This is analogous to <cite>norm=None</cite>
in FFT.</p>
</dd>
<dt>length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0, optional</span></dt>
<dd>If provided, the output <cite>y</cite> is zero-padded or clipped to exactly
<cite>length</cite> samples.</dd>
</dl>
<p>amin : float or None [DEPRECATED]</p>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This parameter is deprecated in 0.7.0 and will be removed in 0.8.0.</p>
</div>
</div></blockquote>
<dl class="docutils">
<dt>res_type <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>Resampling mode.  By default, this uses <cite>fft</cite> mode for high-quality
reconstruction, but this may be slow depending on your signal duration.
See <cite>librosa.resample</cite> for supported modes.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">numeric type</span></dt>
<dd>Real numeric type for <cite>y</cite>.  Default is 32-bit float.</dd>
</dl>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, [shape=(n_samples), dtype=np.float]</span></dt>
<dd>Audio time-series reconstructed from the CQT representation.</dd>
</dl>
<p>cqt
core.resample</p>
<p>This function caches at level 40.</p>
<p>Using default parameters</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">(),</span> <span class="n">duration</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">cqt</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_hat</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">icqt</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
<p>Or with a different hop length and frequency resolution:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hop_length</span> <span class="o">=</span> <span class="mi">256</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bins_per_octave</span> <span class="o">=</span> <span class="mi">12</span> <span class="o">*</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">cqt</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">n_bins</span><span class="o">=</span><span class="mi">7</span><span class="o">*</span><span class="n">bins_per_octave</span><span class="p">,</span>
<span class="gp">... </span>                <span class="n">bins_per_octave</span><span class="o">=</span><span class="n">bins_per_octave</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_hat</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">icqt</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
<span class="gp">... </span>                <span class="n">bins_per_octave</span><span class="o">=</span><span class="n">bins_per_octave</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.ifgram">
<code class="descclassname">librosa.core.</code><code class="descname">ifgram</code><span class="sig-paren">(</span><em>y</em>, <em>sr=22050</em>, <em>n_fft=2048</em>, <em>hop_length=None</em>, <em>win_length=None</em>, <em>window='hann'</em>, <em>norm=False</em>, <em>center=True</em>, <em>ref_power=1e-06</em>, <em>clip=True</em>, <em>dtype=&lt;class 'numpy.complex64'&gt;</em>, <em>pad_mode='reflect'</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.ifgram" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the instantaneous frequency (as a proportion of the sampling rate)
obtained as the time-derivative of the phase of the complex spectrum as
described by <a href="#id85"><span class="problematic" id="id17">[1]_</span></a>.</p>
<p>Calculates regular STFT as a side effect.</p>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Abe, Toshihiko, Takao Kobayashi, and Satoshi Imai.
“Harmonics tracking and pitch extraction based on instantaneous
frequency.”
International Conference on Acoustics, Speech, and Signal Processing,
ICASSP-95., Vol. 1. IEEE, 1995.</td></tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function is deprecated in version 0.7.1, and will be removed
in version 0.8.0.  The function <cite>reassigned_spectrogram</cite> provides
comparable functionality, and should be used instead of <cite>ifgram</cite>.</p>
</div>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd>audio time series</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>sampling rate of <cite>y</cite></dd>
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>FFT window size</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>hop length, number samples between subsequent frames.
If not supplied, defaults to <cite>win_length / 4</cite>.</dd>
<dt>win_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0, &lt;= n_fft</span></dt>
<dd>Window length. Defaults to <cite>n_fft</cite>.
See <cite>stft</cite> for details.</dd>
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span></dt>
<dd><ul class="first simple">
<li>a window specification (string, tuple, number);
see <cite>scipy.signal.get_window</cite></li>
<li>a window function, such as <cite>scipy.signal.hanning</cite></li>
<li>a user-specified window vector of length <cite>n_fft</cite></li>
</ul>
<p class="last">See <cite>stft</cite> for details.</p>
</dd>
<dt>norm <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Normalize the STFT.</dd>
<dt>center <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt>If <cite>True</cite>, the signal <cite>y</cite> is padded so that frame</dt>
<dd><cite>D[:, t]</cite> (and <cite>if_gram</cite>) is centered at <cite>y[t * hop_length]</cite>.</dd>
</dl>
</li>
<li>If <cite>False</cite>, then <cite>D[:, t]</cite> at <cite>y[t * hop_length]</cite></li>
</ul>
</dd>
<dt>ref_power <span class="classifier-delimiter">:</span> <span class="classifier">float &gt;= 0 or callable</span></dt>
<dd><p class="first">Minimum power threshold for estimating instantaneous frequency.
Any bin with <cite>np.abs(D[f, t])**2 &lt; ref_power</cite> will receive the
default frequency estimate.</p>
<p class="last">If callable, the threshold is set to <cite>ref_power(np.abs(D)**2)</cite>.</p>
</dd>
<dt>clip <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><ul class="first last simple">
<li>If <cite>True</cite>, clip estimated frequencies to the range <cite>[0, 0.5 * sr]</cite>.</li>
<li>If <cite>False</cite>, estimated frequencies can be negative or exceed
<cite>0.5 * sr</cite>.</li>
</ul>
</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">numeric type</span></dt>
<dd>Complex numeric type for <cite>D</cite>.  Default is 64-bit complex.</dd>
<dt>pad_mode <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>If <cite>center=True</cite>, the padding mode to use at the edges of the signal.
By default, STFT uses reflection padding.</dd>
</dl>
<dl class="docutils">
<dt>if_gram <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(1 + n_fft/2, t), dtype=real]</span></dt>
<dd>Instantaneous frequency spectrogram:
<cite>if_gram[f, t]</cite> is the frequency at bin <cite>f</cite>, time <cite>t</cite></dd>
<dt>D <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(1 + n_fft/2, t), dtype=complex]</span></dt>
<dd>Short-time Fourier transform</dd>
</dl>
<p>stft : Short-time Fourier Transform
reassigned_spectrogram : Time-frequency reassigned spectrogram</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frequencies</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">ifgram</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frequencies</span>
<span class="go">array([[  0.000e+00,   0.000e+00, ...,   0.000e+00,   0.000e+00],</span>
<span class="go">       [  3.150e+01,   3.070e+01, ...,   1.077e+01,   1.077e+01],</span>
<span class="go">       ...,</span>
<span class="go">       [  1.101e+04,   1.101e+04, ...,   1.101e+04,   1.101e+04],</span>
<span class="go">       [  1.102e+04,   1.102e+04, ...,   1.102e+04,   1.102e+04]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.iirt">
<code class="descclassname">librosa.core.</code><code class="descname">iirt</code><span class="sig-paren">(</span><em>y</em>, <em>sr=22050</em>, <em>win_length=2048</em>, <em>hop_length=None</em>, <em>center=True</em>, <em>tuning=0.0</em>, <em>pad_mode='reflect'</em>, <em>flayout='sos'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.iirt" title="Permalink to this definition">¶</a></dt>
<dd><p>Time-frequency representation using IIR filters <a href="#id86"><span class="problematic" id="id19">[1]_</span></a>.</p>
<p>This function will return a time-frequency representation
using a multirate filter bank consisting of IIR filters.
First, <cite>y</cite> is resampled as needed according to the provided <cite>sample_rates</cite>.
Then, a filterbank with with <cite>n</cite> band-pass filters is designed.
The resampled input signals are processed by the filterbank as a whole.
(<cite>scipy.signal.filtfilt</cite> resp. <cite>sosfiltfilt</cite> is used to make the phase linear.)
The output of the filterbank is cut into frames.
For each band, the short-time mean-square power (STMSP) is calculated by
summing <cite>win_length</cite> subsequent filtered time samples.</p>
<p>When called with the default set of parameters, it will generate the TF-representation
as described in <a href="#id87"><span class="problematic" id="id20">[1]_</span></a> (pitch filterbank):</p>
<blockquote>
<div><ul class="simple">
<li>85 filters with MIDI pitches [24, 108] as <cite>center_freqs</cite>.</li>
<li>each filter having a bandwith of one semitone.</li>
</ul>
</div></blockquote>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Müller, Meinard.
“Information Retrieval for Music and Motion.”
Springer Verlag. 2007.</td></tr>
</tbody>
</table>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd>audio time series</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>sampling rate of <cite>y</cite></dd>
<dt>win_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0, &lt;= n_fft</span></dt>
<dd>Window length.</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>Hop length, number samples between subsequent frames.
If not supplied, defaults to <cite>win_length / 4</cite>.</dd>
<dt>center <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><ul class="first last simple">
<li>If <cite>True</cite>, the signal <cite>y</cite> is padded so that frame
<cite>D[:, t]</cite> is centered at <cite>y[t * hop_length]</cite>.</li>
<li>If <cite>False</cite>, then <cite>D[:, t]</cite> begins at <cite>y[t * hop_length]</cite></li>
</ul>
</dd>
<dt>tuning <span class="classifier-delimiter">:</span> <span class="classifier">float [scalar]</span></dt>
<dd>Tuning deviation from A440 in fractions of a bin.</dd>
<dt>pad_mode <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>If <cite>center=True</cite>, the padding mode to use at the edges of the signal.
By default, this function uses reflection padding.</dd>
<dt>flayout <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><ul class="first last simple">
<li>If <cite>sos</cite> (default), a series of second-order filters is used for filtering with <cite>scipy.signal.sosfiltfilt</cite>.
Minimizes numerical precision errors for high-order filters, but is slower.</li>
<li>If <cite>ba</cite>, the standard difference equation is used for filtering with <cite>scipy.signal.filtfilt</cite>.
Can be unstable for high-order filters.</li>
</ul>
</dd>
<dt>kwargs <span class="classifier-delimiter">:</span> <span class="classifier">additional keyword arguments</span></dt>
<dd>Additional arguments for <cite>librosa.filters.semitone_filterbank()</cite>
(e.g., could be used to provide another set of <cite>center_freqs</cite> and <cite>sample_rates</cite>).</dd>
</dl>
<dl class="docutils">
<dt>bands_power <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n, t), dtype=dtype]</span></dt>
<dd>Short-time mean-square power for the input signal.</dd>
</dl>
<dl class="docutils">
<dt>ParameterError</dt>
<dd>If <cite>flayout</cite> is not None, <cite>ba</cite>, or <cite>sos</cite>.</dd>
</dl>
<p>librosa.filters.semitone_filterbank
librosa.filters._multirate_fb
librosa.filters.mr_frequencies
librosa.core.cqt
scipy.signal.filtfilt
scipy.signal.sosfiltfilt</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">iirt</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">amplitude_to_db</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">),</span>
<span class="gp">... </span>                         <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;cqt_hz&#39;</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Semitone spectrogram&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%+2.0f</span><span class="s1"> dB&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.interp_harmonics">
<code class="descclassname">librosa.core.</code><code class="descname">interp_harmonics</code><span class="sig-paren">(</span><em>x</em>, <em>freqs</em>, <em>h_range</em>, <em>kind='linear'</em>, <em>fill_value=0</em>, <em>axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.interp_harmonics" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the energy at harmonics of time-frequency representation.</p>
<p>Given a frequency-based energy representation such as a spectrogram
or tempogram, this function computes the energy at the chosen harmonics
of the frequency axis.  (See examples below.)
The resulting harmonic array can then be used as input to a salience
computation.</p>
<dl class="docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>The input energy</dd>
<dt>freqs <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(X.shape[axis])</span></dt>
<dd>The frequency values corresponding to X’s elements along the
chosen axis.</dd>
<dt>h_range <span class="classifier-delimiter">:</span> <span class="classifier">list-like, non-negative</span></dt>
<dd>Harmonics to compute.  The first harmonic (1) corresponds to <cite>x</cite>
itself.
Values less than one (e.g., 1/2) correspond to sub-harmonics.</dd>
<dt>kind <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Interpolation type.  See <cite>scipy.interpolate.interp1d</cite>.</dd>
<dt>fill_value <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>The value to fill when extrapolating beyond the observed
frequency range.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The axis along which to compute harmonics</dd>
</dl>
<dl class="docutils">
<dt>x_harm <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(len(h_range), [x.shape])</span></dt>
<dd><cite>x_harm[i]</cite> will have the same shape as <cite>x</cite>, and measure
the energy at the <cite>h_range[i]</cite> harmonic of each frequency.</dd>
</dl>
<p>scipy.interpolate.interp1d</p>
<p>Estimate the harmonics of a time-averaged tempogram</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">(),</span>
<span class="gp">... </span>                     <span class="n">duration</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute the time-varying tempogram and average over time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tempi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">tempogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># We&#39;ll measure the first five harmonics</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h_range</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_tempo</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">tempo_frequencies</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tempi</span><span class="p">),</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Build the harmonic tensor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_harmonics</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">interp_harmonics</span><span class="p">(</span><span class="n">tempi</span><span class="p">,</span> <span class="n">f_tempo</span><span class="p">,</span> <span class="n">h_range</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">t_harmonics</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(5, 384)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># And plot the results</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">t_harmonics</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;tempo&#39;</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">h_range</span><span class="p">)),</span>
<span class="gp">... </span>           <span class="p">[</span><span class="s1">&#39;</span><span class="si">{:.3g}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">h_range</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Harmonic&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Tempo (BPM)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>We can also compute frequency harmonics for spectrograms.
To calculate sub-harmonic energy, use values &lt; 1.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h_range</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fft_freqs</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S_harm</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">interp_harmonics</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">fft_freqs</span><span class="p">,</span> <span class="n">h_range</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">S_harm</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(6, 1025, 646)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_sh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">S_harm</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">amplitude_to_db</span><span class="p">(</span><span class="n">_sh</span><span class="p">,</span>
<span class="gp">... </span>                                                     <span class="n">ref</span><span class="o">=</span><span class="n">S</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span>
<span class="gp">... </span>                             <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;h=</span><span class="si">{:.3g}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">h_range</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
<span class="gp">... </span>    <span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">([])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.istft">
<code class="descclassname">librosa.core.</code><code class="descname">istft</code><span class="sig-paren">(</span><em>stft_matrix</em>, <em>hop_length=None</em>, <em>win_length=None</em>, <em>window='hann'</em>, <em>center=True</em>, <em>dtype=&lt;class 'numpy.float32'&gt;</em>, <em>length=None</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.istft" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse short-time Fourier transform (ISTFT).</p>
<p>Converts a complex-valued spectrogram <cite>stft_matrix</cite> to time-series <cite>y</cite>
by minimizing the mean squared error between <cite>stft_matrix</cite> and STFT of
<cite>y</cite> as described in <a href="#id88"><span class="problematic" id="id22">[1]_</span></a> up to Section 2 (reconstruction from MSTFT).</p>
<p>In general, window function, hop length and other parameters should be same
as in stft, which mostly leads to perfect reconstruction of a signal from
unmodified <cite>stft_matrix</cite>.</p>
<table class="docutils footnote" frame="void" id="id23" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>D. W. Griffin and J. S. Lim,
“Signal estimation from modified short-time Fourier transform,”
IEEE Trans. ASSP, vol.32, no.2, pp.236–243, Apr. 1984.</td></tr>
</tbody>
</table>
<dl class="docutils">
<dt>stft_matrix <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(1 + n_fft/2, t)]</span></dt>
<dd>STFT matrix from <cite>stft</cite></dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>Number of frames between STFT columns.
If unspecified, defaults to <cite>win_length / 4</cite>.</dd>
<dt>win_length <span class="classifier-delimiter">:</span> <span class="classifier">int &lt;= n_fft = 2 * (stft_matrix.shape[0] - 1)</span></dt>
<dd><p class="first">When reconstructing the time series, each frame is windowed
and each sample is normalized by the sum of squared window
according to the <cite>window</cite> function (see below).</p>
<p class="last">If unspecified, defaults to <cite>n_fft</cite>.</p>
</dd>
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">string, tuple, number, function, np.ndarray [shape=(n_fft,)]</span></dt>
<dd><ul class="first last simple">
<li>a window specification (string, tuple, or number);
see <cite>scipy.signal.get_window</cite></li>
<li>a window function, such as <cite>scipy.signal.hanning</cite></li>
<li>a user-specified window vector of length <cite>n_fft</cite></li>
</ul>
</dd>
<dt>center <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><ul class="first last simple">
<li>If <cite>True</cite>, <cite>D</cite> is assumed to have centered frames.</li>
<li>If <cite>False</cite>, <cite>D</cite> is assumed to have left-aligned frames.</li>
</ul>
</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">numeric type</span></dt>
<dd>Real numeric type for <cite>y</cite>.  Default is 32-bit float.</dd>
<dt>length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0, optional</span></dt>
<dd>If provided, the output <cite>y</cite> is zero-padded or clipped to exactly
<cite>length</cite> samples.</dd>
</dl>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd>time domain signal reconstructed from <cite>stft_matrix</cite></dd>
</dl>
<p>stft : Short-time Fourier Transform</p>
<p>This function caches at level 30.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_hat</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">istft</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_hat</span>
<span class="go">array([ -4.812e-06,  -4.267e-06, ...,   6.271e-06,   2.827e-07], dtype=float32)</span>
</pre></div>
</div>
<p>Exactly preserving length of the input signal requires explicit padding.
Otherwise, a partial frame at the end of <cite>y</cite> will not be represented.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n_fft</span> <span class="o">=</span> <span class="mi">2048</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pad</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">fix_length</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y_pad</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_out</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">istft</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">y_out</span><span class="p">))</span>
<span class="go">1.4901161e-07</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.load">
<code class="descclassname">librosa.core.</code><code class="descname">load</code><span class="sig-paren">(</span><em>path</em>, <em>sr=22050</em>, <em>mono=True</em>, <em>offset=0.0</em>, <em>duration=None</em>, <em>dtype=&lt;class 'numpy.float32'&gt;</em>, <em>res_type='kaiser_best'</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load an audio file as a floating point time series.</p>
<p>Audio will be automatically resampled to the given rate
(default <cite>sr=22050</cite>).</p>
<p>To preserve the native sampling rate of the file, use <cite>sr=None</cite>.</p>
<dl class="docutils">
<dt>path <span class="classifier-delimiter">:</span> <span class="classifier">string, int, or file-like object</span></dt>
<dd><p class="first">path to the input file.</p>
<p>Any codec supported by <cite>soundfile</cite> or <cite>audioread</cite> will work.</p>
<p>If the codec is supported by <cite>soundfile</cite>, then <cite>path</cite> can also be
an open file descriptor (int), or any object implementing Python’s
file interface.</p>
<p class="last">If the codec is not supported by <cite>soundfile</cite> (e.g., MP3), then only
string file paths are supported.</p>
</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd><p class="first">target sampling rate</p>
<p class="last">‘None’ uses the native sampling rate</p>
</dd>
<dt>mono <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>convert signal to mono</dd>
<dt>offset <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>start reading after this time (in seconds)</dd>
<dt>duration <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>only load up to this much audio (in seconds)</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">numeric type</span></dt>
<dd>data type of <cite>y</cite></dd>
<dt>res_type <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first">resample type (see note)</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>By default, this uses <cite>resampy</cite>’s high-quality mode (‘kaiser_best’).</p>
<p class="last">For alternative resampling modes, see <cite>resample</cite></p>
</div>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p><cite>audioread</cite> may truncate the precision of the audio data to 16 bits.</p>
<p class="last">See <a class="reference external" href="https://librosa.github.io/librosa/ioformats.html">https://librosa.github.io/librosa/ioformats.html</a> for alternate
loading methods.</p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,) or (2, n)]</span></dt>
<dd>audio time series</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>sampling rate of <cite>y</cite></dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Load an ogg vorbis file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([ -4.756e-06,  -6.020e-06, ...,  -1.040e-06,   0.000e+00], dtype=float32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span>
<span class="go">22050</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Load a file and resample to 11 KHz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">11025</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([ -2.077e-06,  -2.928e-06, ...,  -4.395e-06,   0.000e+00], dtype=float32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span>
<span class="go">11025</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Load 5 seconds of a file, starting 15 seconds in</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mf">15.0</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([ 0.069,  0.1  , ..., -0.101,  0.   ], dtype=float32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span>
<span class="go">22050</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.lpc">
<code class="descclassname">librosa.core.</code><code class="descname">lpc</code><span class="sig-paren">(</span><em>y</em>, <em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.lpc" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear Prediction Coefficients via Burg’s method</p>
<p>This function applies Burg’s method to estimate coefficients of a linear
filter on <cite>y</cite> of order <cite>order</cite>.  Burg’s method is an extension to the
Yule-Walker approach, which are both sometimes referred to as LPC parameter
estimation by autocorrelation.</p>
<p>It follows the description and implementation approach described in the
introduction in <a href="#id89"><span class="problematic" id="id24">[1]_</span></a>.  N.B. This paper describes a different method, which
is not implemented here, but has been chosen for its clear explanation of
Burg’s technique in its introduction.</p>
<table class="docutils footnote" frame="void" id="id25" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Larry Marple
A New Autoregressive Spectrum Analysis Algorithm
IEEE Transactions on Accoustics, Speech, and Signal Processing
vol 28, no. 4, 1980</td></tr>
</tbody>
</table>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>Time series to fit</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>Order of the linear filter</dd>
</dl>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray of length order + 1</span></dt>
<dd>LP prediction error coefficients, i.e. filter denominator polynomial</dd>
</dl>
<dl class="docutils">
<dt>ParameterError</dt>
<dd><ul class="first last simple">
<li>If y is not valid audio as per <cite>util.valid_audio</cite></li>
<li>If order &lt; 1 or not integer</li>
</ul>
</dd>
<dt>FloatingPointError</dt>
<dd><ul class="first last simple">
<li>If y is ill-conditioned</li>
</ul>
</dd>
</dl>
<p>scipy.signal.lfilter</p>
<p>Compute LP coefficients of y at order 16 on entire series</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">(),</span> <span class="n">offset</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="n">duration</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">lpc</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
</pre></div>
</div>
<p>Compute LP coefficients, and plot LP estimate of original series</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">scipy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">(),</span> <span class="n">offset</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="n">duration</span><span class="o">=</span><span class="mf">0.020</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">lpc</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_hat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">lfilter</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">y_hat</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;y_hat&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;LP Model Forward Prediction&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.magphase">
<code class="descclassname">librosa.core.</code><code class="descname">magphase</code><span class="sig-paren">(</span><em>D</em>, <em>power=1</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.magphase" title="Permalink to this definition">¶</a></dt>
<dd><p>Separate a complex-valued spectrogram D into its magnitude (S)
and phase (P) components, so that <cite>D = S * P</cite>.</p>
<dl class="docutils">
<dt>D <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t), dtype=complex]</span></dt>
<dd>complex-valued spectrogram</dd>
<dt>power <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd>Exponent for the magnitude spectrogram,
e.g., 1 for energy, 2 for power, etc.</dd>
</dl>
<dl class="docutils">
<dt>D_mag <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t), dtype=real]</span></dt>
<dd>magnitude of <cite>D</cite>, raised to <cite>power</cite></dd>
<dt>D_phase <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t), dtype=complex]</span></dt>
<dd><cite>exp(1.j * phi)</cite> where <cite>phi</cite> is the phase of <cite>D</cite></dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">magnitude</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">magphase</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">magnitude</span>
<span class="go">array([[  2.524e-03,   4.329e-02, ...,   3.217e-04,   3.520e-05],</span>
<span class="go">       [  2.645e-03,   5.152e-02, ...,   3.283e-04,   3.432e-04],</span>
<span class="go">       ...,</span>
<span class="go">       [  1.966e-05,   9.828e-06, ...,   3.164e-07,   9.370e-06],</span>
<span class="go">       [  1.966e-05,   9.830e-06, ...,   3.161e-07,   9.366e-06]], dtype=float32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phase</span>
<span class="go">array([[  1.000e+00 +0.000e+00j,   1.000e+00 +0.000e+00j, ...,</span>
<span class="go">         -1.000e+00 +8.742e-08j,  -1.000e+00 +8.742e-08j],</span>
<span class="go">       [  1.000e+00 +1.615e-16j,   9.950e-01 -1.001e-01j, ...,</span>
<span class="go">          9.794e-01 +2.017e-01j,   1.492e-02 -9.999e-01j],</span>
<span class="go">       ...,</span>
<span class="go">       [  1.000e+00 -5.609e-15j,  -5.081e-04 +1.000e+00j, ...,</span>
<span class="go">         -9.549e-01 -2.970e-01j,   2.938e-01 -9.559e-01j],</span>
<span class="go">       [ -1.000e+00 +8.742e-08j,  -1.000e+00 +8.742e-08j, ...,</span>
<span class="go">         -1.000e+00 +8.742e-08j,  -1.000e+00 +8.742e-08j]], dtype=complex64)</span>
</pre></div>
</div>
<p>Or get the phase angle (in radians)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span>
<span class="go">array([[  0.000e+00,   0.000e+00, ...,   3.142e+00,   3.142e+00],</span>
<span class="go">       [  1.615e-16,  -1.003e-01, ...,   2.031e-01,  -1.556e+00],</span>
<span class="go">       ...,</span>
<span class="go">       [ -5.609e-15,   1.571e+00, ...,  -2.840e+00,  -1.273e+00],</span>
<span class="go">       [  3.142e+00,   3.142e+00, ...,   3.142e+00,   3.142e+00]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.mel_frequencies">
<code class="descclassname">librosa.core.</code><code class="descname">mel_frequencies</code><span class="sig-paren">(</span><em>n_mels=128</em>, <em>fmin=0.0</em>, <em>fmax=11025.0</em>, <em>htk=False</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.mel_frequencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an array of acoustic frequencies tuned to the mel scale.</p>
<p>The mel scale is a quasi-logarithmic function of acoustic frequency
designed such that perceptually similar pitch intervals (e.g. octaves)
appear equal in width over the full hearing range.</p>
<p>Because the definition of the mel scale is conditioned by a finite number
of subjective psychoaoustical experiments, several implementations coexist
in the audio signal processing literature <a href="#id90"><span class="problematic" id="id26">[1]_</span></a>. By default, librosa replicates
the behavior of the well-established MATLAB Auditory Toolbox of Slaney <a href="#id91"><span class="problematic" id="id27">[2]_</span></a>.
According to this default implementation,  the conversion from Hertz to mel is
linear below 1 kHz and logarithmic above 1 kHz. Another available implementation
replicates the Hidden Markov Toolkit <a href="#id92"><span class="problematic" id="id28">[3]_</span></a> (HTK) according to the following formula:</p>
<p><cite>mel = 2595.0 * np.log10(1.0 + f / 700.0).</cite></p>
<p>The choice of implementation is determined by the <cite>htk</cite> keyword argument: setting
<cite>htk=False</cite> leads to the Auditory toolbox implementation, whereas setting it <cite>htk=True</cite>
leads to the HTK implementation.</p>
<table class="docutils footnote" frame="void" id="id29" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Umesh, S., Cohen, L., &amp; Nelson, D. Fitting the mel scale.
In Proc. International Conference on Acoustics, Speech, and Signal Processing
(ICASSP), vol. 1, pp. 217-220, 1998.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id30" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>Slaney, M. Auditory Toolbox: A MATLAB Toolbox for Auditory
Modeling Work. Technical Report, version 2, Interval Research Corporation, 1998.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id31" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>Young, S., Evermann, G., Gales, M., Hain, T., Kershaw, D., Liu, X.,
Moore, G., Odell, J., Ollason, D., Povey, D., Valtchev, V., &amp; Woodland, P.
The HTK book, version 3.4. Cambridge University, March 2009.</td></tr>
</tbody>
</table>
<p>hz_to_mel
mel_to_hz
librosa.feature.melspectrogram
librosa.feature.mfcc</p>
<dl class="docutils">
<dt>n_mels <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>Number of mel bins.</dd>
<dt>fmin <span class="classifier-delimiter">:</span> <span class="classifier">float &gt;= 0 [scalar]</span></dt>
<dd>Minimum frequency (Hz).</dd>
<dt>fmax <span class="classifier-delimiter">:</span> <span class="classifier">float &gt;= 0 [scalar]</span></dt>
<dd>Maximum frequency (Hz).</dd>
<dt>htk <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, use HTK formula to convert Hz to mel.
Otherwise (False), use Slaney’s Auditory Toolbox.</dd>
</dl>
<dl class="docutils">
<dt>bin_frequencies <span class="classifier-delimiter">:</span> <span class="classifier">ndarray [shape=(n_mels,)]</span></dt>
<dd>Vector of n_mels frequencies in Hz which are uniformly spaced on the Mel
axis.</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">mel_frequencies</span><span class="p">(</span><span class="n">n_mels</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
<span class="go">array([     0.   ,     85.317,    170.635,    255.952,</span>
<span class="go">          341.269,    426.586,    511.904,    597.221,</span>
<span class="go">          682.538,    767.855,    853.173,    938.49 ,</span>
<span class="go">         1024.856,   1119.114,   1222.042,   1334.436,</span>
<span class="go">         1457.167,   1591.187,   1737.532,   1897.337,</span>
<span class="go">         2071.84 ,   2262.393,   2470.47 ,   2697.686,</span>
<span class="go">         2945.799,   3216.731,   3512.582,   3835.643,</span>
<span class="go">         4188.417,   4573.636,   4994.285,   5453.621,</span>
<span class="go">         5955.205,   6502.92 ,   7101.009,   7754.107,</span>
<span class="go">         8467.272,   9246.028,  10096.408,  11025.   ])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.mel_to_hz">
<code class="descclassname">librosa.core.</code><code class="descname">mel_to_hz</code><span class="sig-paren">(</span><em>mels</em>, <em>htk=False</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.mel_to_hz" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert mel bin numbers to frequencies</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">mel_to_hz</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">200.</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">mel_to_hz</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="go">array([  66.667,  133.333,  200.   ,  266.667,  333.333])</span>
</pre></div>
</div>
<dl class="docutils">
<dt>mels <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)], float</span></dt>
<dd>mel bins to convert</dd>
<dt>htk <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>use HTK formula instead of Slaney</dd>
</dl>
<dl class="docutils">
<dt>frequencies <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd>input mels in Hz</dd>
</dl>
<p>hz_to_mel</p>
</dd></dl>

<dl class="function">
<dt id="librosa.core.midi_to_hz">
<code class="descclassname">librosa.core.</code><code class="descname">midi_to_hz</code><span class="sig-paren">(</span><em>notes</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.midi_to_hz" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the frequency (Hz) of MIDI note(s)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">midi_to_hz</span><span class="p">(</span><span class="mi">36</span><span class="p">)</span>
<span class="go">65.406</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">midi_to_hz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">36</span><span class="p">,</span> <span class="mi">48</span><span class="p">))</span>
<span class="go">array([  65.406,   69.296,   73.416,   77.782,   82.407,</span>
<span class="go">         87.307,   92.499,   97.999,  103.826,  110.   ,</span>
<span class="go">        116.541,  123.471])</span>
</pre></div>
</div>
<dl class="docutils">
<dt>notes <span class="classifier-delimiter">:</span> <span class="classifier">int or np.ndarray [shape=(n,), dtype=int]</span></dt>
<dd>midi number(s) of the note(s)</dd>
</dl>
<dl class="docutils">
<dt>frequency <span class="classifier-delimiter">:</span> <span class="classifier">number or np.ndarray [shape=(n,), dtype=float]</span></dt>
<dd>frequency (frequencies) of <cite>notes</cite> in Hz</dd>
</dl>
<p>hz_to_midi
note_to_hz</p>
</dd></dl>

<dl class="function">
<dt id="librosa.core.midi_to_note">
<code class="descclassname">librosa.core.</code><code class="descname">midi_to_note</code><span class="sig-paren">(</span><em>midi</em>, <em>octave=True</em>, <em>cents=False</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.midi_to_note" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert one or more MIDI numbers to note strings.</p>
<p>MIDI numbers will be rounded to the nearest integer.</p>
<p>Notes will be of the format ‘C0’, ‘C#0’, ‘D0’, …</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">midi_to_note</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;C-1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">midi_to_note</span><span class="p">(</span><span class="mi">37</span><span class="p">)</span>
<span class="go">&#39;C#2&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">midi_to_note</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;A#-2&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">midi_to_note</span><span class="p">(</span><span class="mf">104.7</span><span class="p">)</span>
<span class="go">&#39;A7&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">midi_to_note</span><span class="p">(</span><span class="mf">104.7</span><span class="p">,</span> <span class="n">cents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;A7-30&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">midi_to_note</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">24</span><span class="p">)))</span>
<span class="go">[&#39;C0&#39;, &#39;C#0&#39;, &#39;D0&#39;, &#39;D#0&#39;, &#39;E0&#39;, &#39;F0&#39;, &#39;F#0&#39;, &#39;G0&#39;, &#39;G#0&#39;, &#39;A0&#39;, &#39;A#0&#39;, &#39;B0&#39;]</span>
</pre></div>
</div>
<dl class="docutils">
<dt>midi <span class="classifier-delimiter">:</span> <span class="classifier">int or iterable of int</span></dt>
<dd>Midi numbers to convert.</dd>
<dt>octave: bool</dt>
<dd>If True, include the octave number</dd>
<dt>cents: bool</dt>
<dd>If true, cent markers will be appended for fractional notes.
Eg, <cite>midi_to_note(69.3, cents=True)</cite> == <cite>A4+03</cite></dd>
</dl>
<dl class="docutils">
<dt>notes <span class="classifier-delimiter">:</span> <span class="classifier">str or iterable of str</span></dt>
<dd>Strings describing each midi note.</dd>
</dl>
<dl class="docutils">
<dt>ParameterError</dt>
<dd>if <cite>cents</cite> is True and <cite>octave</cite> is False</dd>
</dl>
<p>midi_to_hz
note_to_midi
hz_to_note</p>
</dd></dl>

<dl class="function">
<dt id="librosa.core.note_to_hz">
<code class="descclassname">librosa.core.</code><code class="descname">note_to_hz</code><span class="sig-paren">(</span><em>note</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.note_to_hz" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert one or more note names to frequency (Hz)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Get the frequency of a note</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">note_to_hz</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="go">array([ 16.352])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Or multiple notes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">note_to_hz</span><span class="p">([</span><span class="s1">&#39;A3&#39;</span><span class="p">,</span> <span class="s1">&#39;A4&#39;</span><span class="p">,</span> <span class="s1">&#39;A5&#39;</span><span class="p">])</span>
<span class="go">array([ 220.,  440.,  880.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Or notes with tuning deviations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">note_to_hz</span><span class="p">(</span><span class="s1">&#39;C2-32&#39;</span><span class="p">,</span> <span class="n">round_midi</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([ 64.209])</span>
</pre></div>
</div>
<dl class="docutils">
<dt>note <span class="classifier-delimiter">:</span> <span class="classifier">str or iterable of str</span></dt>
<dd>One or more note names to convert</dd>
<dt>kwargs <span class="classifier-delimiter">:</span> <span class="classifier">additional keyword arguments</span></dt>
<dd>Additional parameters to <cite>note_to_midi</cite></dd>
</dl>
<dl class="docutils">
<dt>frequencies <span class="classifier-delimiter">:</span> <span class="classifier">number or np.ndarray [shape=(len(note),)]</span></dt>
<dd>Array of frequencies (in Hz) corresponding to <cite>note</cite></dd>
</dl>
<p>midi_to_hz
note_to_midi
hz_to_note</p>
</dd></dl>

<dl class="function">
<dt id="librosa.core.note_to_midi">
<code class="descclassname">librosa.core.</code><code class="descname">note_to_midi</code><span class="sig-paren">(</span><em>note</em>, <em>round_midi=True</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.note_to_midi" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert one or more spelled notes to MIDI number(s).</p>
<p>Notes may be spelled out with optional accidentals or octave numbers.</p>
<p>The leading note name is case-insensitive.</p>
<p>Sharps are indicated with <code class="docutils literal notranslate"><span class="pre">#</span></code>, flats may be indicated with <code class="docutils literal notranslate"><span class="pre">!</span></code> or <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
<dl class="docutils">
<dt>note <span class="classifier-delimiter">:</span> <span class="classifier">str or iterable of str</span></dt>
<dd>One or more note names.</dd>
<dt>round_midi <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><ul class="first last simple">
<li>If <cite>True</cite>, allow for fractional midi notes</li>
<li>Otherwise, round cent deviations to the nearest note</li>
</ul>
</dd>
</dl>
<dl class="docutils">
<dt>midi <span class="classifier-delimiter">:</span> <span class="classifier">float or np.array</span></dt>
<dd>Midi note numbers corresponding to inputs.</dd>
</dl>
<dl class="docutils">
<dt>ParameterError</dt>
<dd>If the input is not in valid note format</dd>
</dl>
<p>midi_to_note
note_to_hz</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">note_to_midi</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="go">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">note_to_midi</span><span class="p">(</span><span class="s1">&#39;C#3&#39;</span><span class="p">)</span>
<span class="go">49</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">note_to_midi</span><span class="p">(</span><span class="s1">&#39;f4&#39;</span><span class="p">)</span>
<span class="go">65</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">note_to_midi</span><span class="p">(</span><span class="s1">&#39;Bb-1&#39;</span><span class="p">)</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">note_to_midi</span><span class="p">(</span><span class="s1">&#39;A!8&#39;</span><span class="p">)</span>
<span class="go">116</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Lists of notes also work</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">note_to_midi</span><span class="p">([</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">])</span>
<span class="go">array([12, 16, 19])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.octs_to_hz">
<code class="descclassname">librosa.core.</code><code class="descname">octs_to_hz</code><span class="sig-paren">(</span><em>octs</em>, <em>tuning=0.0</em>, <em>bins_per_octave=12</em>, <em>A440=&lt;DEPRECATED parameter&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.octs_to_hz" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert octaves numbers to frequencies.</p>
<p>Octaves are counted relative to A.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">octs_to_hz</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">55.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">octs_to_hz</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">array([   6.875,   13.75 ,   27.5  ,   55.   ,  110.   ])</span>
</pre></div>
</div>
<dl class="docutils">
<dt>octaves <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or float</span></dt>
<dd>octave number for each frequency</dd>
<dt>tuning <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Tuning deviation from A440 in (fractional) bins per octave.</dd>
<dt>bins_per_octave <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>Number of bins per octave.</dd>
<dt>A440 <span class="classifier-delimiter">:</span> <span class="classifier">float &lt;DEPRECATED&gt;</span></dt>
<dd>frequency of A440</dd>
</dl>
<dl class="docutils">
<dt>frequencies <span class="classifier-delimiter">:</span> <span class="classifier">number or np.ndarray [shape=(n,)]</span></dt>
<dd>scalar or vector of frequencies</dd>
</dl>
<p>hz_to_octs</p>
</dd></dl>

<dl class="function">
<dt id="librosa.core.pcen">
<code class="descclassname">librosa.core.</code><code class="descname">pcen</code><span class="sig-paren">(</span><em>S</em>, <em>sr=22050</em>, <em>hop_length=512</em>, <em>gain=0.98</em>, <em>bias=2</em>, <em>power=0.5</em>, <em>time_constant=0.4</em>, <em>eps=1e-06</em>, <em>b=None</em>, <em>max_size=1</em>, <em>ref=None</em>, <em>axis=-1</em>, <em>max_axis=None</em>, <em>zi=None</em>, <em>return_zf=False</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.pcen" title="Permalink to this definition">¶</a></dt>
<dd><p>Per-channel energy normalization (PCEN) <a href="#id93"><span class="problematic" id="id32">[1]_</span></a></p>
<p>This function normalizes a time-frequency representation <cite>S</cite> by
performing automatic gain control, followed by nonlinear compression:</p>
<blockquote>
<div>P[f, t] = (S / (eps + M[f, t])**gain + bias)**power - bias**power</div></blockquote>
<p>IMPORTANT: the default values of eps, gain, bias, and power match the
original publication <a href="#id94"><span class="problematic" id="id33">[1]_</span></a>, in which M is a 40-band mel-frequency
spectrogram with 25 ms windowing, 10 ms frame shift, and raw audio values
in the interval [-2**31; 2**31-1[. If you use these default values, we
recommend to make sure that the raw audio is properly scaled to this
interval, and not to [-1, 1[ as is most often the case.</p>
<p>The matrix <cite>M</cite> is the result of applying a low-pass, temporal IIR filter
to <cite>S</cite>:</p>
<blockquote>
<div>M[f, t] = (1 - b) * M[f, t - 1] + b * S[f, t]</div></blockquote>
<p>If <cite>b</cite> is not provided, it is calculated as:</p>
<blockquote>
<div>b = (sqrt(1 + 4* T**2) - 1) / (2 * T**2)</div></blockquote>
<p>where <cite>T = time_constant * sr / hop_length</cite>, as in <a href="#id95"><span class="problematic" id="id34">[2]_</span></a>.</p>
<p>This normalization is designed to suppress background noise and
emphasize foreground signals, and can be used as an alternative to
decibel scaling (<cite>amplitude_to_db</cite>).</p>
<p>This implementation also supports smoothing across frequency bins
by specifying <cite>max_size &gt; 1</cite>.  If this option is used, the filtered
spectrogram <cite>M</cite> is computed as</p>
<blockquote>
<div>M[f, t] = (1 - b) * M[f, t - 1] + b * R[f, t]</div></blockquote>
<p>where <cite>R</cite> has been max-filtered along the frequency axis, similar to
the SuperFlux algorithm implemented in <cite>onset.onset_strength</cite>:</p>
<blockquote>
<div>R[f, t] = max(S[f - max_size//2: f + max_size//2, t])</div></blockquote>
<p>This can be used to perform automatic gain control on signals that cross
or span multiple frequency bans, which may be desirable for spectrograms
with high frequency resolution.</p>
<table class="docutils footnote" frame="void" id="id35" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Wang, Y., Getreuer, P., Hughes, T., Lyon, R. F., &amp; Saurous, R. A.
(2017, March). Trainable frontend for robust and far-field keyword spotting.
In Acoustics, Speech and Signal Processing (ICASSP), 2017
IEEE International Conference on (pp. 5670-5674). IEEE.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id36" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>Lostanlen, V., Salamon, J., McFee, B., Cartwright, M., Farnsworth, A.,
Kelling, S., and Bello, J. P. Per-Channel Energy Normalization: Why and How.
IEEE Signal Processing Letters, 26(1), 39-43.</td></tr>
</tbody>
</table>
<dl class="docutils">
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray (non-negative)</span></dt>
<dd>The input (magnitude) spectrogram</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>The audio sampling rate</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>The hop length of <cite>S</cite>, expressed in samples</dd>
<dt>gain <span class="classifier-delimiter">:</span> <span class="classifier">number &gt;= 0 [scalar]</span></dt>
<dd>The gain factor.  Typical values should be slightly less than 1.</dd>
<dt>bias <span class="classifier-delimiter">:</span> <span class="classifier">number &gt;= 0 [scalar]</span></dt>
<dd>The bias point of the nonlinear compression (default: 2)</dd>
<dt>power <span class="classifier-delimiter">:</span> <span class="classifier">number &gt;= 0 [scalar]</span></dt>
<dd>The compression exponent.  Typical values should be between 0 and 0.5.
Smaller values of <cite>power</cite> result in stronger compression.
At the limit <cite>power=0</cite>, polynomial compression becomes logarithmic.</dd>
<dt>time_constant <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>The time constant for IIR filtering, measured in seconds.</dd>
<dt>eps <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>A small constant used to ensure numerical stability of the filter.</dd>
<dt>b <span class="classifier-delimiter">:</span> <span class="classifier">number in [0, 1]  [scalar]</span></dt>
<dd>The filter coefficient for the low-pass filter.
If not provided, it will be inferred from <cite>time_constant</cite>.</dd>
<dt>max_size <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>The width of the max filter applied to the frequency axis.
If left as <cite>1</cite>, no filtering is performed.</dd>
<dt>ref <span class="classifier-delimiter">:</span> <span class="classifier">None or np.ndarray (shape=S.shape)</span></dt>
<dd>An optional pre-computed reference spectrum (<cite>R</cite> in the above).
If not provided it will be computed from <cite>S</cite>.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int [scalar]</span></dt>
<dd>The (time) axis of the input spectrogram.</dd>
<dt>max_axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int [scalar]</span></dt>
<dd>The frequency axis of the input spectrogram.
If <cite>None</cite>, and <cite>S</cite> is two-dimensional, it will be inferred
as the opposite from <cite>axis</cite>.
If <cite>S</cite> is not two-dimensional, and <cite>max_size &gt; 1</cite>, an error
will be raised.</dd>
<dt>zi <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first">The initial filter delay values.</p>
<p class="last">This may be the <cite>zf</cite> (final delay values) of a previous call to <cite>pcen</cite>, or
computed by <cite>scipy.signal.lfilter_zi</cite>.</p>
</dd>
<dt>return_zf <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first">If <cite>True</cite>, return the final filter delay values along with the PCEN output <cite>P</cite>.
This is primarily useful in streaming contexts, where the final state of one
block of processing should be used to initialize the next block.</p>
<p class="last">If <cite>False</cite> (default) only the PCEN values <cite>P</cite> are returned.</p>
</dd>
</dl>
<dl class="docutils">
<dt>P <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, non-negative [shape=(n, m)]</span></dt>
<dd>The per-channel energy normalized version of <cite>S</cite>.</dd>
<dt>zf <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray (optional)</span></dt>
<dd>The final filter delay values.  Only returned if <cite>return_zf=True</cite>.</dd>
</dl>
<p>amplitude_to_db
librosa.onset.onset_strength</p>
<p>Compare PCEN to log amplitude (dB) scaling on Mel spectra</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">(),</span>
<span class="gp">... </span>                     <span class="n">offset</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># We recommend scaling y to the range [-2**31, 2**31[ before applying</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># PCEN&#39;s default parameters. Furthermore, we use power=1 to get a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># magnitude spectrum instead of a power spectrum.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">melspectrogram</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log_S</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">amplitude_to_db</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pcen_S</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">pcen</span><span class="p">(</span><span class="n">S</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">log_S</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;mel&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;log amplitude (dB)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">pcen_S</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;mel&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Per-channel energy normalization&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Compare PCEN with and without max-filtering</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pcen_max</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">pcen</span><span class="p">(</span><span class="n">S</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="p">),</span> <span class="n">max_size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">pcen_S</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;mel&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Per-channel energy normalization (no max-filter)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">pcen_max</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;mel&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Per-channel energy normalization (max_size=3)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.perceptual_weighting">
<code class="descclassname">librosa.core.</code><code class="descname">perceptual_weighting</code><span class="sig-paren">(</span><em>S</em>, <em>frequencies</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.perceptual_weighting" title="Permalink to this definition">¶</a></dt>
<dd><p>Perceptual weighting of a power spectrogram:</p>
<p><cite>S_p[f] = A_weighting(f) + 10*log(S[f] / ref)</cite></p>
<dl class="docutils">
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)]</span></dt>
<dd>Power spectrogram</dd>
<dt>frequencies <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d,)]</span></dt>
<dd>Center frequency for each row of <cite>S</cite></dd>
<dt>kwargs <span class="classifier-delimiter">:</span> <span class="classifier">additional keyword arguments</span></dt>
<dd>Additional keyword arguments to <cite>power_to_db</cite>.</dd>
</dl>
<dl class="docutils">
<dt>S_p <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)]</span></dt>
<dd>perceptually weighted version of <cite>S</cite></dd>
</dl>
<p>power_to_db</p>
<p>This function caches at level 30.</p>
<p>Re-weight a CQT power spectrum, using peak power as reference</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">cqt</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="n">librosa</span><span class="o">.</span><span class="n">note_to_hz</span><span class="p">(</span><span class="s1">&#39;A1&#39;</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">cqt_frequencies</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                                <span class="n">fmin</span><span class="o">=</span><span class="n">librosa</span><span class="o">.</span><span class="n">note_to_hz</span><span class="p">(</span><span class="s1">&#39;A1&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perceptual_CQT</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">perceptual_weighting</span><span class="p">(</span><span class="n">C</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">freqs</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perceptual_CQT</span>
<span class="go">array([[ -80.076,  -80.049, ..., -104.735, -104.735],</span>
<span class="go">       [ -78.344,  -78.555, ..., -103.725, -103.725],</span>
<span class="go">       ...,</span>
<span class="go">       [ -76.272,  -76.272, ...,  -76.272,  -76.272],</span>
<span class="go">       [ -76.485,  -76.485, ...,  -76.485,  -76.485]])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">amplitude_to_db</span><span class="p">(</span><span class="n">C</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">),</span>
<span class="gp">... </span>                         <span class="n">fmin</span><span class="o">=</span><span class="n">librosa</span><span class="o">.</span><span class="n">note_to_hz</span><span class="p">(</span><span class="s1">&#39;A1&#39;</span><span class="p">),</span>
<span class="gp">... </span>                         <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;cqt_hz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Log CQT power&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%+2.0f</span><span class="s1"> dB&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">perceptual_CQT</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;cqt_hz&#39;</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">fmin</span><span class="o">=</span><span class="n">librosa</span><span class="o">.</span><span class="n">note_to_hz</span><span class="p">(</span><span class="s1">&#39;A1&#39;</span><span class="p">),</span>
<span class="gp">... </span>                         <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Perceptually weighted log CQT&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%+2.0f</span><span class="s1"> dB&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.phase_vocoder">
<code class="descclassname">librosa.core.</code><code class="descname">phase_vocoder</code><span class="sig-paren">(</span><em>D</em>, <em>rate</em>, <em>hop_length=None</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.phase_vocoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Phase vocoder.  Given an STFT matrix D, speed up by a factor of <cite>rate</cite></p>
<p>Based on the implementation provided by <a href="#id96"><span class="problematic" id="id37">[1]_</span></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is a simplified implementation, intended primarily for
reference and pedagogical purposes.  It makes no attempt to
handle transients, and is likely to produce many audible
artifacts.  For a higher quality implementation, we recommend
the RubberBand library <a href="#id97"><span class="problematic" id="id38">[2]_</span></a> and its Python wrapper <cite>pyrubberband</cite>.</p>
</div>
<table class="docutils footnote" frame="void" id="id39" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Ellis, D. P. W. “A phase vocoder in Matlab.”
Columbia University, 2002.
<a class="reference external" href="http://www.ee.columbia.edu/~dpwe/resources/matlab/pvoc/">http://www.ee.columbia.edu/~dpwe/resources/matlab/pvoc/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id40" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><a class="reference external" href="https://breakfastquay.com/rubberband/">https://breakfastquay.com/rubberband/</a></td></tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Play at double speed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span>   <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span>       <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D_fast</span>  <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">phase_vocoder</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_fast</span>  <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">istft</span><span class="p">(</span><span class="n">D_fast</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Or play at 1/3 speed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span>   <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span>       <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D_slow</span>  <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">phase_vocoder</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_slow</span>  <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">istft</span><span class="p">(</span><span class="n">D_slow</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
</pre></div>
</div>
<dl class="docutils">
<dt>D <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t), dtype=complex]</span></dt>
<dd>STFT matrix</dd>
<dt>rate <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd>Speed-up factor: <cite>rate &gt; 1</cite> is faster, <cite>rate &lt; 1</cite> is slower.</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar] or None</span></dt>
<dd><p class="first">The number of samples between successive columns of <cite>D</cite>.</p>
<p class="last">If None, defaults to <cite>n_fft/4 = (D.shape[0]-1)/2</cite></p>
</dd>
</dl>
<dl class="docutils">
<dt>D_stretched <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t / rate), dtype=complex]</span></dt>
<dd>time-stretched STFT</dd>
</dl>
<p>pyrubberband</p>
</dd></dl>

<dl class="function">
<dt id="librosa.core.piptrack">
<code class="descclassname">librosa.core.</code><code class="descname">piptrack</code><span class="sig-paren">(</span><em>y=None</em>, <em>sr=22050</em>, <em>S=None</em>, <em>n_fft=2048</em>, <em>hop_length=None</em>, <em>fmin=150.0</em>, <em>fmax=4000.0</em>, <em>threshold=0.1</em>, <em>win_length=None</em>, <em>window='hann'</em>, <em>center=True</em>, <em>pad_mode='reflect'</em>, <em>ref=None</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.piptrack" title="Permalink to this definition">¶</a></dt>
<dd><p>Pitch tracking on thresholded parabolically-interpolated STFT.</p>
<p>This implementation uses the parabolic interpolation method described by <a href="#id98"><span class="problematic" id="id41">[1]_</span></a>.</p>
<table class="docutils footnote" frame="void" id="id42" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><a class="reference external" href="https://ccrma.stanford.edu/~jos/sasp/Sinusoidal_Peak_Interpolation.html">https://ccrma.stanford.edu/~jos/sasp/Sinusoidal_Peak_Interpolation.html</a></td></tr>
</tbody>
</table>
<dl class="docutils">
<dt>y: np.ndarray [shape=(n,)] or None</dt>
<dd>audio signal</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>audio sampling rate of <cite>y</cite></dd>
<dt>S: np.ndarray [shape=(d, t)] or None</dt>
<dd>magnitude or power spectrogram</dd>
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar] or None</span></dt>
<dd>number of FFT bins to use, if <cite>y</cite> is provided.</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar] or None</span></dt>
<dd>number of samples to hop</dd>
<dt>threshold <span class="classifier-delimiter">:</span> <span class="classifier">float in <cite>(0, 1)</cite></span></dt>
<dd><p class="first">A bin in spectrum <cite>S</cite> is considered a pitch when it is greater than
<cite>threshold*ref(S)</cite>.</p>
<p class="last">By default, <cite>ref(S)</cite> is taken to be <cite>max(S, axis=0)</cite> (the maximum value in
each column).</p>
</dd>
<dt>fmin <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd>lower frequency cutoff.</dd>
<dt>fmax <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd>upper frequency cutoff.</dd>
<dt>win_length <span class="classifier-delimiter">:</span> <span class="classifier">int &lt;= n_fft [scalar]</span></dt>
<dd><p class="first">Each frame of audio is windowed by <cite>window()</cite>.
The window will be of length <cite>win_length</cite> and then padded
with zeros to match <cite>n_fft</cite>.</p>
<p class="last">If unspecified, defaults to <code class="docutils literal notranslate"><span class="pre">win_length</span> <span class="pre">=</span> <span class="pre">n_fft</span></code>.</p>
</dd>
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span></dt>
<dd><ul class="first last simple">
<li>a window specification (string, tuple, or number);
see <cite>scipy.signal.get_window</cite></li>
<li>a window function, such as <cite>scipy.signal.hanning</cite></li>
<li>a vector or array of length <cite>n_fft</cite></li>
</ul>
</dd>
<dt>center <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><ul class="first last simple">
<li>If <cite>True</cite>, the signal <cite>y</cite> is padded so that frame
<cite>t</cite> is centered at <cite>y[t * hop_length]</cite>.</li>
<li>If <cite>False</cite>, then frame <cite>t</cite> begins at <cite>y[t * hop_length]</cite></li>
</ul>
</dd>
<dt>pad_mode <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>If <cite>center=True</cite>, the padding mode to use at the edges of the signal.
By default, STFT uses reflection padding.</dd>
<dt>ref <span class="classifier-delimiter">:</span> <span class="classifier">scalar or callable [default=np.max]</span></dt>
<dd><p class="first">If scalar, the reference value against which <cite>S</cite> is compared for determining
pitches.</p>
<p class="last">If callable, the reference value is computed as <cite>ref(S, axis=0)</cite>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>One of <cite>S</cite> or <cite>y</cite> must be provided.</p>
<p class="last">If <cite>S</cite> is not given, it is computed from <cite>y</cite> using
the default parameters of <cite>librosa.core.stft</cite>.</p>
</div>
<p>pitches : np.ndarray [shape=(d, t)]
magnitudes : np.ndarray [shape=(d,t)]</p>
<blockquote>
<div><p>Where <cite>d</cite> is the subset of FFT bins within <cite>fmin</cite> and <cite>fmax</cite>.</p>
<p><cite>pitches[f, t]</cite> contains instantaneous frequency at bin
<cite>f</cite>, time <cite>t</cite></p>
<p><cite>magnitudes[f, t]</cite> contains the corresponding magnitudes.</p>
<p>Both <cite>pitches</cite> and <cite>magnitudes</cite> take value 0 at bins
of non-maximal magnitude.</p>
</div></blockquote>
<p>This function caches at level 30.</p>
<p>Computing pitches from a waveform input</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pitches</span><span class="p">,</span> <span class="n">magnitudes</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">piptrack</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
<p>Or from a spectrogram input</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pitches</span><span class="p">,</span> <span class="n">magnitudes</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">piptrack</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
<p>Or with an alternate reference value for pitch detection, where
values above the mean spectral energy in each frame are counted as pitches</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pitches</span><span class="p">,</span> <span class="n">magnitudes</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">piptrack</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>                                       <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.pitch_tuning">
<code class="descclassname">librosa.core.</code><code class="descname">pitch_tuning</code><span class="sig-paren">(</span><em>frequencies</em>, <em>resolution=0.01</em>, <em>bins_per_octave=12</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.pitch_tuning" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a collection of pitches, estimate its tuning offset
(in fractions of a bin) relative to A440=440.0Hz.</p>
<dl class="docutils">
<dt>frequencies <span class="classifier-delimiter">:</span> <span class="classifier">array-like, float</span></dt>
<dd>A collection of frequencies detected in the signal.
See <cite>piptrack</cite></dd>
<dt>resolution <span class="classifier-delimiter">:</span> <span class="classifier">float in <cite>(0, 1)</cite></span></dt>
<dd>Resolution of the tuning as a fraction of a bin.
0.01 corresponds to cents.</dd>
<dt>bins_per_octave <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>How many frequency bins per octave</dd>
</dl>
<dl class="docutils">
<dt>tuning: float in <cite>[-0.5, 0.5)</cite></dt>
<dd>estimated tuning deviation (fractions of a bin)</dd>
</dl>
<dl class="docutils">
<dt>estimate_tuning</dt>
<dd>Estimating tuning from time-series or spectrogram input</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate notes at +25 cents</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">cqt_frequencies</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="n">tuning</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">pitch_tuning</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span>
<span class="go">0.25</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Track frequencies from a real spectrogram</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pitches</span><span class="p">,</span> <span class="n">magnitudes</span><span class="p">,</span> <span class="n">stft</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">ifptrack</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Select out pitches with high energy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pitches</span> <span class="o">=</span> <span class="n">pitches</span><span class="p">[</span><span class="n">magnitudes</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">magnitudes</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">pitch_tuning</span><span class="p">(</span><span class="n">pitches</span><span class="p">)</span>
<span class="go">0.089999999999999969</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.power_to_db">
<code class="descclassname">librosa.core.</code><code class="descname">power_to_db</code><span class="sig-paren">(</span><em>S</em>, <em>ref=1.0</em>, <em>amin=1e-10</em>, <em>top_db=80.0</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.power_to_db" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a power spectrogram (amplitude squared) to decibel (dB) units</p>
<p>This computes the scaling <code class="docutils literal notranslate"><span class="pre">10</span> <span class="pre">*</span> <span class="pre">log10(S</span> <span class="pre">/</span> <span class="pre">ref)</span></code> in a numerically
stable way.</p>
<dl class="docutils">
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>input power</dd>
<dt>ref <span class="classifier-delimiter">:</span> <span class="classifier">scalar or callable</span></dt>
<dd><p class="first">If scalar, the amplitude <cite>abs(S)</cite> is scaled relative to <cite>ref</cite>:
<cite>10 * log10(S / ref)</cite>.
Zeros in the output correspond to positions where <cite>S == ref</cite>.</p>
<p class="last">If callable, the reference value is computed as <cite>ref(S)</cite>.</p>
</dd>
<dt>amin <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd>minimum threshold for <cite>abs(S)</cite> and <cite>ref</cite></dd>
<dt>top_db <span class="classifier-delimiter">:</span> <span class="classifier">float &gt;= 0 [scalar]</span></dt>
<dd>threshold the output at <cite>top_db</cite> below the peak:
<code class="docutils literal notranslate"><span class="pre">max(10</span> <span class="pre">*</span> <span class="pre">log10(S))</span> <span class="pre">-</span> <span class="pre">top_db</span></code></dd>
</dl>
<dl class="docutils">
<dt>S_db <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><code class="docutils literal notranslate"><span class="pre">S_db</span> <span class="pre">~=</span> <span class="pre">10</span> <span class="pre">*</span> <span class="pre">log10(S)</span> <span class="pre">-</span> <span class="pre">10</span> <span class="pre">*</span> <span class="pre">log10(ref)</span></code></dd>
</dl>
<p>perceptual_weighting
db_to_power
amplitude_to_db
db_to_amplitude</p>
<p>This function caches at level 30.</p>
<p>Get a power spectrogram from a waveform <code class="docutils literal notranslate"><span class="pre">y</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">power_to_db</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([[-33.293, -27.32 , ..., -33.293, -33.293],</span>
<span class="go">       [-33.293, -25.723, ..., -33.293, -33.293],</span>
<span class="go">       ...,</span>
<span class="go">       [-33.293, -33.293, ..., -33.293, -33.293],</span>
<span class="go">       [-33.293, -33.293, ..., -33.293, -33.293]], dtype=float32)</span>
</pre></div>
</div>
<p>Compute dB relative to peak power</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">power_to_db</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
<span class="go">array([[-80.   , -74.027, ..., -80.   , -80.   ],</span>
<span class="go">       [-80.   , -72.431, ..., -80.   , -80.   ],</span>
<span class="go">       ...,</span>
<span class="go">       [-80.   , -80.   , ..., -80.   , -80.   ],</span>
<span class="go">       [-80.   , -80.   , ..., -80.   , -80.   ]], dtype=float32)</span>
</pre></div>
</div>
<p>Or compare to median power</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">power_to_db</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">)</span>
<span class="go">array([[-0.189,  5.784, ..., -0.189, -0.189],</span>
<span class="go">       [-0.189,  7.381, ..., -0.189, -0.189],</span>
<span class="go">       ...,</span>
<span class="go">       [-0.189, -0.189, ..., -0.189, -0.189],</span>
<span class="go">       [-0.189, -0.189, ..., -0.189, -0.189]], dtype=float32)</span>
</pre></div>
</div>
<p>And plot the results</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Power spectrogram&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">power_to_db</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">),</span>
<span class="gp">... </span>                         <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%+2.0f</span><span class="s1"> dB&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Log-Power spectrogram&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.pseudo_cqt">
<code class="descclassname">librosa.core.</code><code class="descname">pseudo_cqt</code><span class="sig-paren">(</span><em>y</em>, <em>sr=22050</em>, <em>hop_length=512</em>, <em>fmin=None</em>, <em>n_bins=84</em>, <em>bins_per_octave=12</em>, <em>tuning=0.0</em>, <em>filter_scale=1</em>, <em>norm=1</em>, <em>sparsity=0.01</em>, <em>window='hann'</em>, <em>scale=True</em>, <em>pad_mode='reflect'</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.pseudo_cqt" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the pseudo constant-Q transform of an audio signal.</p>
<p>This uses a single fft size that is the smallest power of 2 that is greater
than or equal to the max of:</p>
<blockquote>
<div><ol class="arabic simple">
<li>The longest CQT filter</li>
<li>2x the hop_length</li>
</ol>
</div></blockquote>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd>audio time series</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>sampling rate of <cite>y</cite></dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>number of samples between successive CQT columns.</dd>
<dt>fmin <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd>Minimum frequency. Defaults to C1 ~= 32.70 Hz</dd>
<dt>n_bins <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>Number of frequency bins, starting at <cite>fmin</cite></dd>
<dt>bins_per_octave <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>Number of bins per octave</dd>
<dt>tuning <span class="classifier-delimiter">:</span> <span class="classifier">None or float</span></dt>
<dd><p class="first">Tuning offset in fractions of a bin.</p>
<p>If <cite>None</cite>, tuning will be automatically estimated from the signal.</p>
<p class="last">The minimum frequency of the resulting CQT will be modified to
<cite>fmin * 2**(tuning / bins_per_octave)</cite>.</p>
</dd>
<dt>filter_scale <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd>Filter filter_scale factor. Larger values use longer windows.</dd>
<dt>sparsity <span class="classifier-delimiter">:</span> <span class="classifier">float in [0, 1)</span></dt>
<dd><p class="first">Sparsify the CQT basis by discarding up to <cite>sparsity</cite>
fraction of the energy in each basis.</p>
<p class="last">Set <cite>sparsity=0</cite> to disable sparsification.</p>
</dd>
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">str, tuple, number, or function</span></dt>
<dd>Window specification for the basis filters.
See <cite>filters.get_window</cite> for details.</dd>
<dt>pad_mode <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first">Padding mode for centered frame analysis.</p>
<p class="last">See also: <cite>librosa.core.stft</cite> and <cite>np.pad</cite>.</p>
</dd>
</dl>
<dl class="docutils">
<dt>CQT <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n_bins, t), dtype=np.float]</span></dt>
<dd>Pseudo Constant-Q energy for each frequency at each time.</dd>
</dl>
<dl class="docutils">
<dt>ParameterError</dt>
<dd><p class="first">If <cite>hop_length</cite> is not an integer multiple of
<cite>2**(n_bins / bins_per_octave)</cite></p>
<p class="last">Or if <cite>y</cite> is too short to support the frequency range of the CQT.</p>
</dd>
</dl>
<p>This function caches at level 20.</p>
</dd></dl>

<dl class="function">
<dt id="librosa.core.reassigned_spectrogram">
<code class="descclassname">librosa.core.</code><code class="descname">reassigned_spectrogram</code><span class="sig-paren">(</span><em>y</em>, <em>sr=22050</em>, <em>S=None</em>, <em>n_fft=2048</em>, <em>hop_length=None</em>, <em>win_length=None</em>, <em>window='hann'</em>, <em>center=True</em>, <em>reassign_frequencies=True</em>, <em>reassign_times=True</em>, <em>ref_power=1e-06</em>, <em>fill_nan=False</em>, <em>clip=True</em>, <em>dtype=&lt;class 'numpy.complex64'&gt;</em>, <em>pad_mode='reflect'</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.reassigned_spectrogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Time-frequency reassigned spectrogram.</p>
<p>The reassignment vectors are calculated using equations 5.20 and 5.23 in
<a href="#id99"><span class="problematic" id="id43">[1]_</span></a>:</p>
<p>where <cite>S_h</cite> is the complex STFT calculated using the original window,
<cite>S_dh</cite> is the complex STFT calculated using the derivative of the original
window, and <cite>S_th</cite> is the complex STFT calculated using the original window
multiplied by the time offset from the window center. See <a href="#id100"><span class="problematic" id="id44">[2]_</span></a> for
additional algorithms, and <a href="#id101"><span class="problematic" id="id45">[3]_</span></a> and <a class="footnote-reference" href="#id50" id="id46">[4]</a> for history and discussion of the
method.</p>
<p>It is recommended to use <cite>center=False</cite> with this function rather than the
librosa default <cite>True</cite>. Unlike <cite>stft</cite>, reassigned times are not aligned to
the left or center of each frame, so padding the signal does not affect the
meaning of the reassigned times. However, reassignment assumes that the
energy in each FFT bin is associated with exactly one signal component and
impulse event. The default <cite>center=True</cite> with reflection padding can thus
invalidate the reassigned estimates in the half-reflected frames at the
beginning and end of the signal.</p>
<p>If <cite>reassign_times</cite> is <cite>False</cite>, the frame times that are returned will be
aligned to the left or center of the frame, depending on the value of
<cite>center</cite>. In this case, if <cite>center</cite> is <cite>True</cite>, then <cite>pad_mode=”wrap”</cite> is
recommended for valid estimation of the instantaneous frequencies in the
boundary frames.</p>
<table class="docutils footnote" frame="void" id="id47" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Flandrin, P., Auger, F., &amp; Chassande-Mottin, E. (2002).
Time-Frequency reassignment: From principles to algorithms. In Applications
in Time-Frequency Signal Processing (Vol. 10, pp. 179-204). CRC Press.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id48" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>Fulop, S. A., &amp; Fitz, K. (2006). Algorithms for computing the
time-corrected instantaneous frequency (reassigned) spectrogram, with
applications. The Journal of the Acoustical Society of America, 119(1),
360. doi:10.1121/1.2133000</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id49" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>Auger, F., Flandrin, P., Lin, Y.-T., McLaughlin, S., Meignen, S.,
Oberlin, T., &amp; Wu, H.-T. (2013). Time-Frequency Reassignment and
Synchrosqueezing: An Overview. IEEE Signal Processing Magazine, 30(6),
32-41. doi:10.1109/MSP.2013.2265316</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id50" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id46">[4]</a></td><td>Hainsworth, S., Macleod, M. (2003). Time-frequency reassignment: a
review and analysis. Tech. Rep. CUED/FINFENG/TR.459, Cambridge University
Engineering Department</td></tr>
</tbody>
</table>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)], real-valued</span></dt>
<dd>audio time series</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>sampling rate of <cite>y</cite></dd>
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)] or None</span></dt>
<dd>(optional) complex STFT calculated using the other arguments provided
to <cite>reassigned_spectrogram</cite></dd>
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>FFT window size. Defaults to 2048.</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>hop length, number samples between subsequent frames.
If not supplied, defaults to <cite>win_length / 4</cite>.</dd>
<dt>win_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0, &lt;= n_fft</span></dt>
<dd>Window length. Defaults to <cite>n_fft</cite>.
See <cite>stft</cite> for details.</dd>
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span></dt>
<dd><ul class="first simple">
<li>a window specification (string, tuple, number);
see <cite>scipy.signal.get_window</cite></li>
<li>a window function, such as <cite>scipy.signal.hanning</cite></li>
<li>a user-specified window vector of length <cite>n_fft</cite></li>
</ul>
<p class="last">See <cite>stft</cite> for details.</p>
</dd>
<dt>center <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><ul class="first last simple">
<li>If <cite>True</cite> (default), the signal <cite>y</cite> is padded so that frame
<cite>D[:, t]</cite> is centered at <cite>y[t * hop_length]</cite>.</li>
<li>If <cite>False</cite>, then <cite>D[:, t]</cite> begins at <cite>y[t * hop_length]</cite></li>
</ul>
</dd>
<dt>reassign_frequencies <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><ul class="first last simple">
<li>If <cite>True</cite> (default), the returned frequencies will be instantaneous
frequency estimates.</li>
<li>If <cite>False</cite>, the returned frequencies will be a read-only view of the
STFT bin frequencies for all frames.</li>
</ul>
</dd>
<dt>reassign_times <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><ul class="first last simple">
<li>If <cite>True</cite> (default), the returned times will be corrected
(reassigned) time estimates for each bin.</li>
<li>If <cite>False</cite>, the returned times will be a read-only view of the STFT
frame times for all bins.</li>
</ul>
</dd>
<dt>ref_power <span class="classifier-delimiter">:</span> <span class="classifier">float &gt;= 0 or callable</span></dt>
<dd>Minimum power threshold for estimating time-frequency reassignments.
Any bin with <cite>np.abs(S[f, t])**2 &lt; ref_power</cite> will be returned as
<cite>np.nan</cite> in both frequency and time, unless <cite>fill_nan</cite> is <cite>True</cite>. If 0
is provided, then only bins with zero power will be returned as
<cite>np.nan</cite> (unless <cite>fill_nan=True</cite>).</dd>
<dt>fill_nan <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><ul class="first last simple">
<li>If <cite>False</cite> (default), the frequency and time reassignments for bins
below the power threshold provided in <cite>ref_power</cite> will be returned as
<cite>np.nan</cite>.</li>
<li>If <cite>True</cite>, the frequency and time reassignments for these bins will
be returned as the bin center frequencies and frame times.</li>
</ul>
</dd>
<dt>clip <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><ul class="first last simple">
<li>If <cite>True</cite> (default), estimated frequencies outside the range
<cite>[0, 0.5 * sr]</cite> or times outside the range <cite>[0, len(y) / sr]</cite> will be
clipped to those ranges.</li>
<li>If <cite>False</cite>, estimated frequencies and times beyond the bounds of the
spectrogram may be returned.</li>
</ul>
</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">numeric type</span></dt>
<dd>Complex numeric type for STFT calculation. Default is 64-bit complex.</dd>
<dt>pad_mode <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>If <cite>center=True</cite>, the padding mode to use at the edges of the signal.
By default, STFT uses reflection padding.</dd>
</dl>
<dl class="docutils">
<dt>freqs <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(1 + n_fft/2, t), dtype=real]</span></dt>
<dd>Instantaneous frequencies:
<cite>freqs[f, t]</cite> is the frequency for bin <cite>f</cite>, frame <cite>t</cite>
If <cite>reassign_frequencies=False</cite>, this will instead be a read-only array
of the same shape containing the bin center frequencies for all frames.</dd>
<dt>times <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(1 + n_fft/2, t), dtype=real]</span></dt>
<dd>Reassigned times:
<cite>times[f, t]</cite> is the time for bin <cite>f</cite>, frame <cite>t</cite>
If <cite>reassign_times=False</cite>, this will instead be a read-only array of
the same shape containing the frame times for all bins.</dd>
<dt>mags <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(1 + n_fft/2, t), dtype=real]</span></dt>
<dd>Magnitudes from short-time Fourier transform:
<cite>mags[f, t]</cite> is the magnitude for bin <cite>f</cite>, frame <cite>t</cite></dd>
</dl>
<dl class="docutils">
<dt>RuntimeWarning</dt>
<dd>Frequency or time estimates with zero support will produce a
divide-by-zero warning, and will be returned as <cite>np.nan</cite> unless
<cite>fill_nan=True</cite>.</dd>
</dl>
<p>stft : Short-time Fourier Transform</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">amin</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n_fft</span> <span class="o">=</span> <span class="mi">64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span> <span class="o">=</span> <span class="mi">4000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="mf">1e-3</span> <span class="o">*</span> <span class="n">librosa</span><span class="o">.</span><span class="n">clicks</span><span class="p">(</span><span class="n">times</span><span class="o">=</span><span class="p">[</span><span class="mf">0.3</span><span class="p">],</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">click_duration</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
<span class="gp">... </span>                          <span class="n">click_freq</span><span class="o">=</span><span class="mf">1200.0</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">8000</span><span class="p">)</span> <span class="o">+</span>\
<span class="gp">... </span>    <span class="mf">1e-3</span> <span class="o">*</span> <span class="n">librosa</span><span class="o">.</span><span class="n">clicks</span><span class="p">(</span><span class="n">times</span><span class="o">=</span><span class="p">[</span><span class="mf">1.5</span><span class="p">],</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">click_duration</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
<span class="gp">... </span>                          <span class="n">click_freq</span><span class="o">=</span><span class="mf">400.0</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">8000</span><span class="p">)</span> <span class="o">+</span>\
<span class="gp">... </span>    <span class="mf">1e-3</span> <span class="o">*</span> <span class="n">librosa</span><span class="o">.</span><span class="n">chirp</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">1600</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span>\
<span class="gp">... </span>    <span class="mf">1e-6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">mags</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">reassigned_spectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mags_db</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">power_to_db</span><span class="p">(</span><span class="n">mags</span><span class="p">,</span> <span class="n">amin</span><span class="o">=</span><span class="n">amin</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">mags_db</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">hop_length</span><span class="o">=</span><span class="n">n_fft</span><span class="o">//</span><span class="mi">4</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;gray_r&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Spectrogram&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">labelbottom</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">mags_db</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;gray_r&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">clim</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">amin</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">mags_db</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Reassigned spectrogram&quot;</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.resample">
<code class="descclassname">librosa.core.</code><code class="descname">resample</code><span class="sig-paren">(</span><em>y</em>, <em>orig_sr</em>, <em>target_sr</em>, <em>res_type='kaiser_best'</em>, <em>fix=True</em>, <em>scale=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample a time series from orig_sr to target_sr</p>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,) or shape=(2, n)]</span></dt>
<dd>audio time series.  Can be mono or stereo.</dd>
<dt>orig_sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>original sampling rate of <cite>y</cite></dd>
<dt>target_sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>target sampling rate</dd>
<dt>res_type <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first">resample type (see note)</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>By default, this uses <cite>resampy</cite>’s high-quality mode (‘kaiser_best’).</p>
<p>To use a faster method, set <cite>res_type=’kaiser_fast’</cite>.</p>
<p>To use <cite>scipy.signal.resample</cite>, set <cite>res_type=’fft’</cite> or <cite>res_type=’scipy’</cite>.</p>
<p class="last">To use <cite>scipy.signal.resample_poly</cite>, set <cite>res_type=’polyphase’</cite>.</p>
</div>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When using <cite>res_type=’polyphase’</cite>, only integer sampling rates are
supported.</p>
</div>
</dd>
<dt>fix <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>adjust the length of the resampled signal to be of size exactly
<cite>ceil(target_sr * len(y) / orig_sr)</cite></dd>
<dt>scale <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Scale the resampled signal so that <cite>y</cite> and <cite>y_hat</cite> have approximately
equal total energy.</dd>
<dt>kwargs <span class="classifier-delimiter">:</span> <span class="classifier">additional keyword arguments</span></dt>
<dd>If <cite>fix==True</cite>, additional keyword arguments to pass to
<cite>librosa.util.fix_length</cite>.</dd>
</dl>
<dl class="docutils">
<dt>y_hat <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n * target_sr / orig_sr,)]</span></dt>
<dd><cite>y</cite> resampled from <cite>orig_sr</cite> to <cite>target_sr</cite></dd>
</dl>
<dl class="docutils">
<dt>ParameterError</dt>
<dd>If <cite>res_type=’polyphase’</cite> and <cite>orig_sr</cite> or <cite>target_sr</cite> are not both
integer-valued.</dd>
</dl>
<p>librosa.util.fix_length
scipy.signal.resample
resampy.resample</p>
<p>This function caches at level 20.</p>
<p>Downsample from 22 KHz to 8 KHz</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">(),</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_8k</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="mi">8000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">y_8k</span><span class="o">.</span><span class="n">shape</span>
<span class="go">((1355168,), (491671,))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.salience">
<code class="descclassname">librosa.core.</code><code class="descname">salience</code><span class="sig-paren">(</span><em>S</em>, <em>freqs</em>, <em>h_range</em>, <em>weights=None</em>, <em>aggregate=None</em>, <em>filter_peaks=True</em>, <em>fill_value=nan</em>, <em>kind='linear'</em>, <em>axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.salience" title="Permalink to this definition">¶</a></dt>
<dd><p>Harmonic salience function.</p>
<dl class="docutils">
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, n)]</span></dt>
<dd>input time frequency magnitude representation (e.g. STFT or CQT magnitudes).
Must be real-valued and non-negative.</dd>
<dt>freqs <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(S.shape[axis])</span></dt>
<dd>The frequency values corresponding to S’s elements along the
chosen axis.</dd>
<dt>h_range <span class="classifier-delimiter">:</span> <span class="classifier">list-like, non-negative</span></dt>
<dd>Harmonics to include in salience computation.  The first harmonic (1)
corresponds to <cite>S</cite> itself. Values less than one (e.g., 1/2) correspond
to sub-harmonics.</dd>
<dt>weights <span class="classifier-delimiter">:</span> <span class="classifier">list-like</span></dt>
<dd>The weight to apply to each harmonic in the summation. (default:
uniform weights). Must be the same length as <cite>harmonics</cite>.</dd>
<dt>aggregate <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd>aggregation function (default: <cite>np.average</cite>)
If <cite>aggregate=np.average</cite>, then a weighted average is
computed per-harmonic according to the specified weights.
For all other aggregation functions, all harmonics
are treated equally.</dd>
<dt>filter_peaks <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If true, returns harmonic summation only on frequencies of peak
magnitude. Otherwise returns harmonic summation over the full spectrum.
Defaults to True.</dd>
<dt>fill_value <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>The value to fill non-peaks in the output representation. (default:
np.nan) Only used if <cite>filter_peaks == True</cite>.</dd>
<dt>kind <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Interpolation type for harmonic estimation.
See <cite>scipy.interpolate.interp1d</cite>.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The axis along which to compute harmonics</dd>
</dl>
<dl class="docutils">
<dt>S_sal <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(len(h_range), [x.shape])</span></dt>
<dd><cite>S_sal</cite> will have the same shape as <cite>S</cite>, and measure
the overal harmonic energy at each frequency.</dd>
</dl>
<p>interp_harmonics</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">(),</span>
<span class="gp">... </span>                     <span class="n">duration</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">harms</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S_sal</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">salience</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">harms</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">S_sal</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(1025, 646)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">amplitude_to_db</span><span class="p">(</span><span class="n">S_sal</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">),</span>
<span class="gp">... </span>                         <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Salience spectrogram&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.samples_like">
<code class="descclassname">librosa.core.</code><code class="descname">samples_like</code><span class="sig-paren">(</span><em>X</em>, <em>hop_length=512</em>, <em>n_fft=None</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.samples_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of sample indices to match the time axis from a feature matrix.</p>
<dl class="docutils">
<dt>X <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray or scalar</span></dt>
<dd><ul class="first last simple">
<li>If ndarray, X is a feature matrix, e.g. STFT, chromagram, or mel spectrogram.</li>
<li>If scalar, X represents the number of frames.</li>
</ul>
</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>number of samples between successive frames</dd>
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">None or int &gt; 0 [scalar]</span></dt>
<dd>Optional: length of the FFT window.
If given, time conversion will include an offset of <cite>n_fft / 2</cite>
to counteract windowing effects when using a non-centered STFT.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int [scalar]</span></dt>
<dd>The axis representing the time axis of X.
By default, the last axis (-1) is taken.</dd>
</dl>
<dl class="docutils">
<dt>samples <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd>ndarray of sample indices corresponding to each frame of X.</dd>
</dl>
<p>times_like : Return an array of time values to match the time axis from a feature matrix.</p>
<p>Provide a feature matrix input:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">samples_like</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span>
<span class="go">array([      0,     512,    1024, ..., 1353728, 1354240, 1354752])</span>
</pre></div>
</div>
<p>Provide a scalar input:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n_frames</span> <span class="o">=</span> <span class="mi">2647</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">samples_like</span><span class="p">(</span><span class="n">n_frames</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span>
<span class="go">array([      0,     512,    1024, ..., 1353728, 1354240, 1354752])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.samples_to_frames">
<code class="descclassname">librosa.core.</code><code class="descname">samples_to_frames</code><span class="sig-paren">(</span><em>samples</em>, <em>hop_length=512</em>, <em>n_fft=None</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.samples_to_frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts sample indices into STFT frames.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Get the frame numbers for every 256 samples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">samples_to_frames</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">22050</span><span class="p">,</span> <span class="mi">256</span><span class="p">))</span>
<span class="go">array([ 0,  0,  1,  1,  2,  2,  3,  3,  4,  4,  5,  5,  6,  6,</span>
<span class="go">        7,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 13, 13,</span>
<span class="go">       14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20,</span>
<span class="go">       21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27,</span>
<span class="go">       28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34,</span>
<span class="go">       35, 35, 36, 36, 37, 37, 38, 38, 39, 39, 40, 40, 41, 41,</span>
<span class="go">       42, 42, 43])</span>
</pre></div>
</div>
<dl class="docutils">
<dt>samples <span class="classifier-delimiter">:</span> <span class="classifier">int or np.ndarray [shape=(n,)]</span></dt>
<dd>sample index or vector of sample indices</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>number of samples between successive frames</dd>
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">None or int &gt; 0 [scalar]</span></dt>
<dd><p class="first">Optional: length of the FFT window.
If given, time conversion will include an offset of <cite>- n_fft / 2</cite>
to counteract windowing effects in STFT.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This may result in negative frame indices.</p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>frames <span class="classifier-delimiter">:</span> <span class="classifier">int or np.ndarray [shape=(n,), dtype=int]</span></dt>
<dd>Frame numbers corresponding to the given times:
<cite>frames[i] = floor( samples[i] / hop_length )</cite></dd>
</dl>
<p>samples_to_time : convert sample indices to time values
frames_to_samples : convert frame indices to sample indices</p>
</dd></dl>

<dl class="function">
<dt id="librosa.core.samples_to_time">
<code class="descclassname">librosa.core.</code><code class="descname">samples_to_time</code><span class="sig-paren">(</span><em>samples</em>, <em>sr=22050</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.samples_to_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert sample indices to time (in seconds).</p>
<dl class="docutils">
<dt>samples <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>Sample index or array of sample indices</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0</span></dt>
<dd>Sampling rate</dd>
</dl>
<dl class="docutils">
<dt>times <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=samples.shape]</span></dt>
<dd>Time values corresponding to <cite>samples</cite> (in seconds)</dd>
</dl>
<p>samples_to_frames : convert sample indices to frame indices
time_to_samples : convert time values to sample indices</p>
<p>Get timestamps corresponding to every 512 samples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">samples_to_time</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">22050</span><span class="p">,</span> <span class="mi">512</span><span class="p">))</span>
<span class="go">array([ 0.   ,  0.023,  0.046,  0.07 ,  0.093,  0.116,  0.139,</span>
<span class="go">        0.163,  0.186,  0.209,  0.232,  0.255,  0.279,  0.302,</span>
<span class="go">        0.325,  0.348,  0.372,  0.395,  0.418,  0.441,  0.464,</span>
<span class="go">        0.488,  0.511,  0.534,  0.557,  0.58 ,  0.604,  0.627,</span>
<span class="go">        0.65 ,  0.673,  0.697,  0.72 ,  0.743,  0.766,  0.789,</span>
<span class="go">        0.813,  0.836,  0.859,  0.882,  0.906,  0.929,  0.952,</span>
<span class="go">        0.975,  0.998])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.set_fftlib">
<code class="descclassname">librosa.core.</code><code class="descname">set_fftlib</code><span class="sig-paren">(</span><em>lib=None</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.set_fftlib" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the FFT library used by librosa.</p>
<dl class="docutils">
<dt>lib <span class="classifier-delimiter">:</span> <span class="classifier">None or module</span></dt>
<dd>Must implement an interface compatible with <cite>numpy.fft</cite>.
If <cite>None</cite>, reverts to <cite>numpy.fft</cite>.</dd>
</dl>
<p>Use <cite>pyfftw</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyfftw</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">set_fftlib</span><span class="p">(</span><span class="n">pyfftw</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">numpy_fft</span><span class="p">)</span>
</pre></div>
</div>
<p>Reset to default <cite>numpy</cite> implementation</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">set_fftlib</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.stft">
<code class="descclassname">librosa.core.</code><code class="descname">stft</code><span class="sig-paren">(</span><em>y</em>, <em>n_fft=2048</em>, <em>hop_length=None</em>, <em>win_length=None</em>, <em>window='hann'</em>, <em>center=True</em>, <em>dtype=&lt;class 'numpy.complex64'&gt;</em>, <em>pad_mode='reflect'</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.stft" title="Permalink to this definition">¶</a></dt>
<dd><p>Short-time Fourier transform (STFT). <a href="#id102"><span class="problematic" id="id51">[1]_</span></a> (chapter 2)</p>
<p>The STFT represents a signal in the time-frequency domain by
computing discrete Fourier transforms (DFT) over short overlapping
windows.</p>
<p>This function returns a complex-valued matrix D such that</p>
<ul class="simple">
<li><cite>np.abs(D[f, t])</cite> is the magnitude of frequency bin <cite>f</cite>
at frame <cite>t</cite>, and</li>
<li><cite>np.angle(D[f, t])</cite> is the phase of frequency bin <cite>f</cite>
at frame <cite>t</cite>.</li>
</ul>
<p>The integers <cite>t</cite> and <cite>f</cite> can be converted to physical units by means
of the utility functions <cite>frames_to_sample</cite> and <cite>fft_frequencies</cite>.</p>
<table class="docutils footnote" frame="void" id="id52" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><ol class="first last upperalpha simple" start="13">
<li>Müller. “Fundamentals of Music Processing.” Springer, 2015</li>
</ol>
</td></tr>
</tbody>
</table>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)], real-valued</span></dt>
<dd>input signal</dd>
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>length of the windowed signal after padding with zeros.
The number of rows in the STFT matrix <cite>D</cite> is (1 + n_fft/2).
The default value, n_fft=2048 samples, corresponds to a physical
duration of 93 milliseconds at a sample rate of 22050 Hz, i.e. the
default sample rate in librosa. This value is well adapted for music
signals. However, in speech processing, the recommended value is 512,
corresponding to 23 milliseconds at a sample rate of 22050 Hz.
In any case, we recommend setting <cite>n_fft</cite> to a power of two for
optimizing the speed of the fast Fourier transform (FFT) algorithm.</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first">number of audio samples between adjacent STFT columns.</p>
<p>Smaller values increase the number of columns in <cite>D</cite> without
affecting the frequency resolution of the STFT.</p>
<p class="last">If unspecified, defaults to <cite>win_length / 4</cite> (see below).</p>
</dd>
<dt>win_length <span class="classifier-delimiter">:</span> <span class="classifier">int &lt;= n_fft [scalar]</span></dt>
<dd><p class="first">Each frame of audio is windowed by <cite>window()</cite> of length <cite>win_length</cite>
and then padded with zeros to match <cite>n_fft</cite>.</p>
<p>Smaller values improve the temporal resolution of the STFT (i.e. the
ability to discriminate impulses that are closely spaced in time)
at the expense of frequency resolution (i.e. the ability to discriminate
pure tones that are closely spaced in frequency). This effect is known
as the time-frequency localization tradeoff and needs to be adjusted
according to the properties of the input signal <cite>y</cite>.</p>
<p class="last">If unspecified, defaults to <code class="docutils literal notranslate"><span class="pre">win_length</span> <span class="pre">=</span> <span class="pre">n_fft</span></code>.</p>
</dd>
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span></dt>
<dd><p class="first">Either:</p>
<ul class="simple">
<li>a window specification (string, tuple, or number);
see <cite>scipy.signal.get_window</cite></li>
<li>a window function, such as <cite>scipy.signal.hanning</cite></li>
<li>a vector or array of length <cite>n_fft</cite></li>
</ul>
<p class="last">Defaults to a raised cosine window (“hann”), which is adequate for
most applications in audio signal processing.</p>
</dd>
<dt>center <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first">If <cite>True</cite>, the signal <cite>y</cite> is padded so that frame
<cite>D[:, t]</cite> is centered at <cite>y[t * hop_length]</cite>.</p>
<p>If <cite>False</cite>, then <cite>D[:, t]</cite> begins at <cite>y[t * hop_length]</cite>.</p>
<p class="last">Defaults to <cite>True</cite>,  which simplifies the alignment of <cite>D</cite> onto a
time grid by means of <cite>librosa.core.frames_to_samples</cite>.
Note, however, that <cite>center</cite> must be set to <cite>False</cite> when analyzing
signals with <cite>librosa.stream</cite>.</p>
</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">numeric type</span></dt>
<dd>Complex numeric type for <cite>D</cite>.  Default is single-precision
floating-point complex (<cite>np.complex64</cite>).</dd>
<dt>pad_mode <span class="classifier-delimiter">:</span> <span class="classifier">string or function</span></dt>
<dd>If <cite>center=True</cite>, this argument is passed to <cite>np.pad</cite> for padding
the edges of the signal <cite>y</cite>. By default (<cite>pad_mode=”reflect”</cite>),
<cite>y</cite> is padded on both sides with its own reflection, mirrored around
its first and last sample respectively.
If <cite>center=False</cite>,  this argument is ignored.</dd>
</dl>
<dl class="docutils">
<dt>D <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(1 + n_fft/2, n_frames), dtype=dtype]</span></dt>
<dd>Complex-valued matrix of short-term Fourier transform
coefficients.</dd>
</dl>
<p>istft : Inverse STFT</p>
<p>reassigned_spectrogram : Time-frequency reassigned spectrogram</p>
<p>This function caches at level 20.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span>
<span class="go">array([[2.58028018e-03, 4.32422794e-02, 6.61255598e-01, ...,</span>
<span class="go">        6.82710262e-04, 2.51654536e-04, 7.23036574e-05],</span>
<span class="go">       [2.49403086e-03, 5.15930466e-02, 6.00107312e-01, ...,</span>
<span class="go">        3.48026224e-04, 2.35853557e-04, 7.54836728e-05],</span>
<span class="go">       [7.82410789e-04, 1.05394892e-01, 4.37517226e-01, ...,</span>
<span class="go">        6.29352580e-04, 3.38571583e-04, 8.38094638e-05],</span>
<span class="go">       ...,</span>
<span class="go">       [9.48568513e-08, 4.74725084e-07, 1.50052492e-05, ...,</span>
<span class="go">        1.85637656e-08, 2.89708542e-08, 5.74304337e-09],</span>
<span class="go">       [1.25165826e-07, 8.58259284e-07, 1.11157215e-05, ...,</span>
<span class="go">        3.49099771e-08, 3.11740926e-08, 5.29926236e-09],</span>
<span class="go">       [1.70630571e-07, 8.92518756e-07, 1.23656537e-05, ...,</span>
<span class="go">        5.33256745e-08, 3.33264900e-08, 5.13272980e-09]], dtype=float32)</span>
</pre></div>
</div>
<p>Use left-aligned frames, instead of centered frames</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
</pre></div>
</div>
<p>Use a shorter hop length</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D_short</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">64</span><span class="p">))</span>
</pre></div>
</div>
<p>Display a spectrogram</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">amplitude_to_db</span><span class="p">(</span><span class="n">D</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">),</span>
<span class="gp">... </span>                         <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Power spectrogram&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%+2.0f</span><span class="s1"> dB&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.stream">
<code class="descclassname">librosa.core.</code><code class="descname">stream</code><span class="sig-paren">(</span><em>path</em>, <em>block_length</em>, <em>frame_length</em>, <em>hop_length</em>, <em>mono=True</em>, <em>offset=0.0</em>, <em>duration=None</em>, <em>fill_value=None</em>, <em>dtype=&lt;class 'numpy.float32'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Stream audio in fixed-length buffers.</p>
<p>This is primarily useful for processing large files that won’t
fit entirely in memory at once.</p>
<p>Instead of loading the entire audio signal into memory (as
in <cite>load()</cite>, this function produces <em>blocks</em> of audio spanning
a fixed number of frames at a specified frame length and hop
length.</p>
<p>While this function strives for similar behavior to <cite>load</cite>,
there are a few caveats that users should be aware of:</p>
<blockquote>
<div><ol class="arabic simple">
<li>This function does not return audio buffers directly.
It returns a generator, which you can iterate over
to produce blocks of audio.  A <em>block</em>, in this context,
refers to a buffer of audio which spans a given number of
(potentially overlapping) frames.</li>
<li>Automatic sample-rate conversion is not supported.
Audio will be streamed in its native sample rate,
so no default values are provided for <cite>frame_length</cite>
and <cite>hop_length</cite>.  It is recommended that you first
get the sampling rate for the file in question, using
<cite>get_samplerate()</cite>, and set these parameters accordingly.</li>
<li>Many analyses require access to the entire signal
to behave correctly, such as <cite>resample</cite>, <cite>cqt</cite>, or
<cite>beat_track</cite>, so these methods will not be appropriate
for streamed data.</li>
<li>The <cite>block_length</cite> parameter specifies how many frames
of audio will be produced per block.  Larger values will
consume more memory, but will be more efficient to process
down-stream.  The best value will ultimately depend on your
application and other system constraints.</li>
<li>By default, most librosa analyses (e.g., short-time Fourier
transform) assume centered frames, which requires padding the
signal at the beginning and end.  This will not work correctly
when the signal is carved into blocks, because it would introduce
padding in the middle of the signal.  To disable this feature,
use <cite>center=False</cite> in all frame-based analyses.</li>
</ol>
</div></blockquote>
<p>See the examples below for proper usage of this function.</p>
<dl class="docutils">
<dt>path <span class="classifier-delimiter">:</span> <span class="classifier">string, int, or file-like object</span></dt>
<dd><p class="first">path to the input file to stream.</p>
<p class="last">Any codec supported by <cite>soundfile</cite> is permitted here.</p>
</dd>
<dt>block_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd><p class="first">The number of frames to include in each block.</p>
<p class="last">Note that at the end of the file, there may not be enough
data to fill an entire block, resulting in a shorter block
by default.  To pad the signal out so that blocks are always
full length, set <cite>fill_value</cite> (see below).</p>
</dd>
<dt>frame_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>The number of samples per frame.</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd><p class="first">The number of samples to advance between frames.</p>
<p class="last">Note that by when <cite>hop_length &lt; frame_length</cite>, neighboring frames
will overlap.  Similarly, the last frame of one <em>block</em> will overlap
with the first frame of the next <em>block</em>.</p>
</dd>
<dt>mono <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Convert the signal to mono during streaming</dd>
<dt>offset <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Start reading after this time (in seconds)</dd>
<dt>duration <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Only load up to this much audio (in seconds)</dd>
<dt>fill_value <span class="classifier-delimiter">:</span> <span class="classifier">float [optional]</span></dt>
<dd><p class="first">If padding the signal to produce constant-length blocks,
this value will be used at the end of the signal.</p>
<p class="last">In most cases, <cite>fill_value=0</cite> (silence) is expected, but
you may specify any value here.</p>
</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">numeric type</span></dt>
<dd>data type of audio buffers to be produced</dd>
</dl>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>An audio buffer of (at most)
<cite>block_length * (hop_length-1) + frame_length</cite> samples.</dd>
</dl>
<p>load
get_samplerate
soundfile.blocks</p>
<p>Apply a short-term Fourier transform to blocks of 256 frames
at a time.  Note that streaming operation requires left-aligned
frames, so we must set <cite>center=False</cite> to avoid padding artifacts.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">get_samplerate</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stream</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">block_length</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">frame_length</span><span class="o">=</span><span class="mi">4096</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">hop_length</span><span class="o">=</span><span class="mi">1024</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">y_block</span> <span class="ow">in</span> <span class="n">stream</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">D_block</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y_block</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Or compute a mel spectrogram over a stream, using a shorter frame
and non-overlapping windows</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">get_samplerate</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stream</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span>
<span class="gp">... </span>                        <span class="n">block_length</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span>
<span class="gp">... </span>                        <span class="n">frame_length</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
<span class="gp">... </span>                        <span class="n">hop_length</span><span class="o">=</span><span class="mi">2048</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">y_block</span> <span class="ow">in</span> <span class="n">stream</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">m_block</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">melspectrogram</span><span class="p">(</span><span class="n">y_block</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
<span class="gp">... </span>                                             <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
<span class="gp">... </span>                                             <span class="n">hop_length</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
<span class="gp">... </span>                                             <span class="n">center</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.tempo_frequencies">
<code class="descclassname">librosa.core.</code><code class="descname">tempo_frequencies</code><span class="sig-paren">(</span><em>n_bins</em>, <em>hop_length=512</em>, <em>sr=22050</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.tempo_frequencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the frequencies (in beats per minute) corresponding
to an onset auto-correlation or tempogram matrix.</p>
<dl class="docutils">
<dt>n_bins <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>The number of lag bins</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>The number of samples between each bin</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0</span></dt>
<dd>The audio sampling rate</dd>
</dl>
<dl class="docutils">
<dt>bin_frequencies <span class="classifier-delimiter">:</span> <span class="classifier">ndarray [shape=(n_bins,)]</span></dt>
<dd><p class="first">vector of bin frequencies measured in BPM.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>bin_frequencies[0] = +np.inf</cite> corresponds to 0-lag</p>
</div>
</dd>
</dl>
<p>Get the tempo frequencies corresponding to a 384-bin (8-second) tempogram</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">tempo_frequencies</span><span class="p">(</span><span class="mi">384</span><span class="p">)</span>
<span class="go">array([      inf,  2583.984,  1291.992, ...,     6.782,</span>
<span class="go">           6.764,     6.747])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.time_to_frames">
<code class="descclassname">librosa.core.</code><code class="descname">time_to_frames</code><span class="sig-paren">(</span><em>times</em>, <em>sr=22050</em>, <em>hop_length=512</em>, <em>n_fft=None</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.time_to_frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts time stamps into STFT frames.</p>
<dl class="docutils">
<dt>times <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd>time (in seconds) or vector of time values</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>audio sampling rate</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>number of samples between successive frames</dd>
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">None or int &gt; 0 [scalar]</span></dt>
<dd><p class="first">Optional: length of the FFT window.
If given, time conversion will include an offset of <cite>- n_fft / 2</cite>
to counteract windowing effects in STFT.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This may result in negative frame indices.</p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>frames <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,), dtype=int]</span></dt>
<dd>Frame numbers corresponding to the given times:
<cite>frames[i] = floor( times[i] * sr / hop_length )</cite></dd>
</dl>
<p>frames_to_time : convert frame indices to time values
time_to_samples : convert time values to sample indices</p>
<p>Get the frame numbers for every 100ms</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">time_to_frames</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span>
<span class="gp">... </span>                        <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
<span class="go">array([ 0,  4,  8, 12, 17, 21, 25, 30, 34, 38])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.time_to_samples">
<code class="descclassname">librosa.core.</code><code class="descname">time_to_samples</code><span class="sig-paren">(</span><em>times</em>, <em>sr=22050</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.time_to_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert timestamps (in seconds) to sample indices.</p>
<dl class="docutils">
<dt>times <span class="classifier-delimiter">:</span> <span class="classifier">number or np.ndarray</span></dt>
<dd>Time value or array of time values (in seconds)</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0</span></dt>
<dd>Sampling rate</dd>
</dl>
<dl class="docutils">
<dt>samples <span class="classifier-delimiter">:</span> <span class="classifier">int or np.ndarray [shape=times.shape, dtype=int]</span></dt>
<dd>Sample indices corresponding to values in <cite>times</cite></dd>
</dl>
<p>time_to_frames : convert time values to frame indices
samples_to_time : convert sample indices to time values</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">time_to_samples</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">)</span>
<span class="go">array([    0,  2205,  4410,  6615,  8820, 11025, 13230, 15435,</span>
<span class="go">       17640, 19845])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.times_like">
<code class="descclassname">librosa.core.</code><code class="descname">times_like</code><span class="sig-paren">(</span><em>X</em>, <em>sr=22050</em>, <em>hop_length=512</em>, <em>n_fft=None</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.times_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of time values to match the time axis from a feature matrix.</p>
<dl class="docutils">
<dt>X <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray or scalar</span></dt>
<dd><ul class="first last simple">
<li>If ndarray, X is a feature matrix, e.g. STFT, chromagram, or mel spectrogram.</li>
<li>If scalar, X represents the number of frames.</li>
</ul>
</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>audio sampling rate</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>number of samples between successive frames</dd>
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">None or int &gt; 0 [scalar]</span></dt>
<dd>Optional: length of the FFT window.
If given, time conversion will include an offset of <cite>n_fft / 2</cite>
to counteract windowing effects when using a non-centered STFT.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int [scalar]</span></dt>
<dd>The axis representing the time axis of X.
By default, the last axis (-1) is taken.</dd>
</dl>
<dl class="docutils">
<dt>times <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd>ndarray of times (in seconds) corresponding to each frame of X.</dd>
</dl>
<p>samples_like : Return an array of sample indices to match the time axis from a feature matrix.</p>
<p>Provide a feature matrix input:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">times</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">times_like</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">times</span>
<span class="go">array([  0.00000000e+00,   2.32199546e-02,   4.64399093e-02, ...,</span>
<span class="go">         6.13935601e+01,   6.14167800e+01,   6.14400000e+01])</span>
</pre></div>
</div>
<p>Provide a scalar input:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n_frames</span> <span class="o">=</span> <span class="mi">2647</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">times</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">times_like</span><span class="p">(</span><span class="n">n_frames</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">times</span>
<span class="go">array([  0.00000000e+00,   2.32199546e-02,   4.64399093e-02, ...,</span>
<span class="go">         6.13935601e+01,   6.14167800e+01,   6.14400000e+01])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.to_mono">
<code class="descclassname">librosa.core.</code><code class="descname">to_mono</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.to_mono" title="Permalink to this definition">¶</a></dt>
<dd><p>Force an audio signal down to mono by averaging samples across channels.</p>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(2,n) or shape=(n,)]</span></dt>
<dd>audio time series, either stereo or mono</dd>
</dl>
<dl class="docutils">
<dt>y_mono <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><cite>y</cite> as a monophonic time-series</dd>
</dl>
<p>This function caches at level 20.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">(),</span> <span class="n">mono</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 1355168)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_mono</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">to_mono</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_mono</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1355168,)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.tone">
<code class="descclassname">librosa.core.</code><code class="descname">tone</code><span class="sig-paren">(</span><em>frequency</em>, <em>sr=22050</em>, <em>length=None</em>, <em>duration=None</em>, <em>phi=None</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.tone" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a pure tone signal. The signal generated is a cosine wave.</p>
<dl class="docutils">
<dt>frequency <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd>frequency</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0</span></dt>
<dd>desired sampling rate of the output signal</dd>
<dt>length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>desired number of samples in the output signal. When both <cite>duration</cite> and <cite>length</cite> are defined,
<cite>length</cite> would take priority.</dd>
<dt>duration <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd>desired duration in seconds. When both <cite>duration</cite> and <cite>length</cite> are defined, <cite>length</cite> would take priority.</dd>
<dt>phi <span class="classifier-delimiter">:</span> <span class="classifier">float or None</span></dt>
<dd>phase offset, in radians. If unspecified, defaults to <cite>-np.pi * 0.5</cite>.</dd>
</dl>
<dl class="docutils">
<dt>tone_signal <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(length,), dtype=float64]</span></dt>
<dd>Synthesized pure sine tone signal</dd>
</dl>
<dl class="docutils">
<dt>ParameterError</dt>
<dd><ul class="first last simple">
<li>If <cite>frequency</cite> is not provided.</li>
<li>If neither <cite>length</cite> nor <cite>duration</cite> are provided.</li>
</ul>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate a pure sine tone A4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tone</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">tone</span><span class="p">(</span><span class="mi">440</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Or generate the same signal using `length`</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tone</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">tone</span><span class="p">(</span><span class="mi">440</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">22050</span><span class="p">)</span>
</pre></div>
</div>
<p>Display spectrogram</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">melspectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">tone</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">power_to_db</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">),</span>
<span class="gp">... </span>                         <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;mel&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.zero_crossings">
<code class="descclassname">librosa.core.</code><code class="descname">zero_crossings</code><span class="sig-paren">(</span><em>y</em>, <em>threshold=1e-10</em>, <em>ref_magnitude=None</em>, <em>pad=True</em>, <em>zero_pos=True</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.core.zero_crossings" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the zero-crossings of a signal <cite>y</cite>: indices <cite>i</cite> such that
<cite>sign(y[i]) != sign(y[j])</cite>.</p>
<p>If <cite>y</cite> is multi-dimensional, then zero-crossings are computed along
the specified <cite>axis</cite>.</p>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>The input array</dd>
<dt>threshold <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 or None</span></dt>
<dd>If specified, values where <cite>-threshold &lt;= y &lt;= threshold</cite> are
clipped to 0.</dd>
<dt>ref_magnitude <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 or callable</span></dt>
<dd><p class="first">If numeric, the threshold is scaled relative to <cite>ref_magnitude</cite>.</p>
<p class="last">If callable, the threshold is scaled relative to
<cite>ref_magnitude(np.abs(y))</cite>.</p>
</dd>
<dt>pad <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>If <cite>True</cite>, then <cite>y[0]</cite> is considered a valid zero-crossing.</dd>
<dt>zero_pos <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first">If <cite>True</cite> then the value 0 is interpreted as having positive sign.</p>
<p class="last">If <cite>False</cite>, then 0, -1, and +1 all have distinct signs.</p>
</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Axis along which to compute zero-crossings.</dd>
</dl>
<dl class="docutils">
<dt>zero_crossings <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=y.shape, dtype=boolean]</span></dt>
<dd>Indicator array of zero-crossings in <cite>y</cite> along the selected axis.</dd>
</dl>
<p>This function caches at level 20.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate a time-series</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([  0.000e+00,   9.694e-01,   4.759e-01,  -7.357e-01,</span>
<span class="go">        -8.372e-01,   3.247e-01,   9.966e-01,   1.646e-01,</span>
<span class="go">        -9.158e-01,  -6.142e-01,   6.142e-01,   9.158e-01,</span>
<span class="go">        -1.646e-01,  -9.966e-01,  -3.247e-01,   8.372e-01,</span>
<span class="go">         7.357e-01,  -4.759e-01,  -9.694e-01,  -9.797e-16])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute zero-crossings</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">zero_crossings</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span>
<span class="go">array([ True, False, False,  True, False,  True, False, False,</span>
<span class="go">        True, False,  True, False,  True, False, False,  True,</span>
<span class="go">       False,  True, False,  True], dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Stack y against the zero-crossing indicator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[  0.000e+00,   1.000e+00],</span>
<span class="go">       [  9.694e-01,   0.000e+00],</span>
<span class="go">       [  4.759e-01,   0.000e+00],</span>
<span class="go">       [ -7.357e-01,   1.000e+00],</span>
<span class="go">       [ -8.372e-01,   0.000e+00],</span>
<span class="go">       [  3.247e-01,   1.000e+00],</span>
<span class="go">       [  9.966e-01,   0.000e+00],</span>
<span class="go">       [  1.646e-01,   0.000e+00],</span>
<span class="go">       [ -9.158e-01,   1.000e+00],</span>
<span class="go">       [ -6.142e-01,   0.000e+00],</span>
<span class="go">       [  6.142e-01,   1.000e+00],</span>
<span class="go">       [  9.158e-01,   0.000e+00],</span>
<span class="go">       [ -1.646e-01,   1.000e+00],</span>
<span class="go">       [ -9.966e-01,   0.000e+00],</span>
<span class="go">       [ -3.247e-01,   0.000e+00],</span>
<span class="go">       [  8.372e-01,   1.000e+00],</span>
<span class="go">       [  7.357e-01,   0.000e+00],</span>
<span class="go">       [ -4.759e-01,   1.000e+00],</span>
<span class="go">       [ -9.694e-01,   0.000e+00],</span>
<span class="go">       [ -9.797e-16,   1.000e+00]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Find the indices of zero-crossings</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">(array([ 0,  3,  5,  8, 10, 12, 15, 17, 19]),)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
</div>
<div class="section" id="module-librosa.beat">
<span id="beat-tracking"></span><h1>Beat tracking<a class="headerlink" href="#module-librosa.beat" title="Permalink to this headline">¶</a></h1>
<div class="section" id="beat-and-tempo">
<h2>Beat and tempo<a class="headerlink" href="#beat-and-tempo" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="librosa.beat.beat_track">
<code class="descclassname">librosa.beat.</code><code class="descname">beat_track</code><span class="sig-paren">(</span><em>y=None</em>, <em>sr=22050</em>, <em>onset_envelope=None</em>, <em>hop_length=512</em>, <em>start_bpm=120.0</em>, <em>tightness=100</em>, <em>trim=True</em>, <em>bpm=None</em>, <em>prior=None</em>, <em>units='frames'</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.beat.beat_track" title="Permalink to this definition">¶</a></dt>
<dd><p>Dynamic programming beat tracker.</p>
<dl class="docutils">
<dt>Beats are detected in three stages, following the method of <a href="#id103"><span class="problematic" id="id53">[1]_</span></a>:</dt>
<dd><ol class="first last arabic simple">
<li>Measure onset strength</li>
<li>Estimate tempo from onset correlation</li>
<li>Pick peaks in onset strength approximately consistent with estimated
tempo</li>
</ol>
</dd>
</dl>
<table class="docutils footnote" frame="void" id="id54" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Ellis, Daniel PW. “Beat tracking by dynamic programming.”
Journal of New Music Research 36.1 (2007): 51-60.
<a class="reference external" href="http://labrosa.ee.columbia.edu/projects/beattrack/">http://labrosa.ee.columbia.edu/projects/beattrack/</a></td></tr>
</tbody>
</table>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or None</span></dt>
<dd>audio time series</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>sampling rate of <cite>y</cite></dd>
<dt>onset_envelope <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or None</span></dt>
<dd>(optional) pre-computed onset strength envelope.</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>number of audio samples between successive <cite>onset_envelope</cite> values</dd>
<dt>start_bpm <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd>initial guess for the tempo estimator (in beats per minute)</dd>
<dt>tightness <span class="classifier-delimiter">:</span> <span class="classifier">float [scalar]</span></dt>
<dd>tightness of beat distribution around tempo</dd>
<dt>trim <span class="classifier-delimiter">:</span> <span class="classifier">bool [scalar]</span></dt>
<dd>trim leading/trailing beats with weak onsets</dd>
<dt>bpm <span class="classifier-delimiter">:</span> <span class="classifier">float [scalar]</span></dt>
<dd>(optional) If provided, use <cite>bpm</cite> as the tempo instead of
estimating it from <cite>onsets</cite>.</dd>
<dt>prior <span class="classifier-delimiter">:</span> <span class="classifier">scipy.stats.rv_continuous [optional]</span></dt>
<dd>An optional prior distribution over tempo.
If provided, <cite>start_bpm</cite> will be ignored.</dd>
<dt>units <span class="classifier-delimiter">:</span> <span class="classifier">{‘frames’, ‘samples’, ‘time’}</span></dt>
<dd>The units to encode detected beat events in.
By default, ‘frames’ are used.</dd>
</dl>
<dl class="docutils">
<dt>tempo <span class="classifier-delimiter">:</span> <span class="classifier">float [scalar, non-negative]</span></dt>
<dd>estimated global tempo (in beats per minute)</dd>
<dt>beats <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(m,)]</span></dt>
<dd>estimated beat event locations in the specified units
(default is frame indices)</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If no onset strength could be detected, beat_tracker estimates 0 BPM
and returns an empty list.</p>
</div>
<dl class="docutils">
<dt>ParameterError</dt>
<dd>if neither <cite>y</cite> nor <cite>onset_envelope</cite> are provided,
or if <cite>units</cite> is not one of ‘frames’, ‘samples’, or ‘time’</dd>
</dl>
<p>librosa.onset.onset_strength</p>
<p>Track beats using time series input</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tempo</span><span class="p">,</span> <span class="n">beats</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">beat_track</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tempo</span>
<span class="go">64.599609375</span>
</pre></div>
</div>
<p>Print the first 20 beat frames</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">beats</span><span class="p">[:</span><span class="mi">20</span><span class="p">]</span>
<span class="go">array([ 320,  357,  397,  436,  480,  525,  569,  609,  658,</span>
<span class="go">        698,  737,  777,  817,  857,  896,  936,  976, 1016,</span>
<span class="go">       1055, 1095])</span>
</pre></div>
</div>
<p>Or print them as timestamps</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">frames_to_time</span><span class="p">(</span><span class="n">beats</span><span class="p">[:</span><span class="mi">20</span><span class="p">],</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="go">array([  7.43 ,   8.29 ,   9.218,  10.124,  11.146,  12.19 ,</span>
<span class="go">        13.212,  14.141,  15.279,  16.208,  17.113,  18.042,</span>
<span class="go">        18.971,  19.9  ,  20.805,  21.734,  22.663,  23.591,</span>
<span class="go">        24.497,  25.426])</span>
</pre></div>
</div>
<p>Track beats using a pre-computed onset envelope</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">onset_env</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">onset</span><span class="o">.</span><span class="n">onset_strength</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
<span class="gp">... </span>                                         <span class="n">aggregate</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tempo</span><span class="p">,</span> <span class="n">beats</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">beat_track</span><span class="p">(</span><span class="n">onset_envelope</span><span class="o">=</span><span class="n">onset_env</span><span class="p">,</span>
<span class="gp">... </span>                                       <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tempo</span>
<span class="go">64.599609375</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">beats</span><span class="p">[:</span><span class="mi">20</span><span class="p">]</span>
<span class="go">array([ 320,  357,  397,  436,  480,  525,  569,  609,  658,</span>
<span class="go">        698,  737,  777,  817,  857,  896,  936,  976, 1016,</span>
<span class="go">       1055, 1095])</span>
</pre></div>
</div>
<p>Plot the beat events against the onset strength envelope</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hop_length</span> <span class="o">=</span> <span class="mi">512</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">times</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">times_like</span><span class="p">(</span><span class="n">onset_env</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">onset_env</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Onset strength&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">beats</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span>
<span class="gp">... </span>           <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Beats&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">framealpha</span><span class="o">=</span><span class="mf">0.75</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Limit the plot to a 15-second window</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">TimeFormatter</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.beat.tempo">
<code class="descclassname">librosa.beat.</code><code class="descname">tempo</code><span class="sig-paren">(</span><em>y=None</em>, <em>sr=22050</em>, <em>onset_envelope=None</em>, <em>hop_length=512</em>, <em>start_bpm=120</em>, <em>std_bpm=1.0</em>, <em>ac_size=8.0</em>, <em>max_tempo=320.0</em>, <em>aggregate=&lt;function mean&gt;</em>, <em>prior=None</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.beat.tempo" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the tempo (beats per minute)</p>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or None</span></dt>
<dd>audio time series</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>sampling rate of the time series</dd>
<dt>onset_envelope <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd>pre-computed onset strength envelope</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>hop length of the time series</dd>
<dt>start_bpm <span class="classifier-delimiter">:</span> <span class="classifier">float [scalar]</span></dt>
<dd>initial guess of the BPM</dd>
<dt>std_bpm <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd>standard deviation of tempo distribution</dd>
<dt>ac_size <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd>length (in seconds) of the auto-correlation window</dd>
<dt>max_tempo <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar, optional]</span></dt>
<dd>If provided, only estimate tempo below this threshold</dd>
<dt>aggregate <span class="classifier-delimiter">:</span> <span class="classifier">callable [optional]</span></dt>
<dd>Aggregation function for estimating global tempo.
If <cite>None</cite>, then tempo is estimated independently for each frame.</dd>
<dt>prior <span class="classifier-delimiter">:</span> <span class="classifier">scipy.stats.rv_continuous [optional]</span></dt>
<dd>A prior distribution over tempo (in beats per minute).
By default, a pseudo-log-normal prior is used.
If given, <cite>start_bpm</cite> and <cite>std_bpm</cite> will be ignored.</dd>
</dl>
<dl class="docutils">
<dt>tempo <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [scalar]</span></dt>
<dd>estimated tempo (beats per minute)</dd>
</dl>
<p>librosa.onset.onset_strength
librosa.feature.tempogram</p>
<p>This function caches at level 30.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Estimate a static tempo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">onset_env</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">onset</span><span class="o">.</span><span class="n">onset_strength</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tempo</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">tempo</span><span class="p">(</span><span class="n">onset_envelope</span><span class="o">=</span><span class="n">onset_env</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tempo</span>
<span class="go">array([129.199])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Or a static tempo with a uniform prior instead</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">scipy.stats</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prior</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">300</span><span class="p">)</span>  <span class="c1"># uniform over 30-300 BPM</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">utempo</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">tempo</span><span class="p">(</span><span class="n">onset_envelope</span><span class="o">=</span><span class="n">onset_env</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">utempo</span>
<span class="go">array([64.6])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Or a dynamic tempo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dtempo</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">tempo</span><span class="p">(</span><span class="n">onset_envelope</span><span class="o">=</span><span class="n">onset_env</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="n">aggregate</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dtempo</span>
<span class="go">array([ 143.555,  143.555,  143.555, ...,  161.499,  161.499,</span>
<span class="go">        172.266])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Dynamic tempo with a proper log-normal prior</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prior_lognorm</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">lognorm</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">120</span><span class="p">),</span> <span class="n">scale</span><span class="o">=</span><span class="mi">120</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dtempo_lognorm</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">tempo</span><span class="p">(</span><span class="n">onset_envelope</span><span class="o">=</span><span class="n">onset_env</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="n">aggregate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="n">prior</span><span class="o">=</span><span class="n">prior_lognorm</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dtempo_lognorm</span>
<span class="go">array([ 86.133,  86.133, ..., 129.199, 129.199])</span>
</pre></div>
</div>
<p>Plot the estimated tempo against the onset autocorrelation</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Convert to scalar</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tempo</span> <span class="o">=</span> <span class="n">tempo</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">utempo</span> <span class="o">=</span> <span class="n">utempo</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute 2-second windowed autocorrelation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hop_length</span> <span class="o">=</span> <span class="mi">512</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ac</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">autocorrelate</span><span class="p">(</span><span class="n">onset_env</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sr</span> <span class="o">//</span> <span class="n">hop_length</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">tempo_frequencies</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ac</span><span class="p">),</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
<span class="gp">... </span>                                  <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Plot on a BPM axis.  We skip the first (0-lag) bin.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">semilogx</span><span class="p">(</span><span class="n">freqs</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">ac</span><span class="p">)[</span><span class="mi">1</span><span class="p">:],</span>
<span class="gp">... </span>             <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Onset autocorrelation&#39;</span><span class="p">,</span> <span class="n">basex</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">tempo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Tempo (default prior): </span><span class="si">{:.2f}</span><span class="s1"> BPM&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tempo</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">utempo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Tempo (uniform prior): </span><span class="si">{:.2f}</span><span class="s1"> BPM&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">utempo</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Tempo (BPM)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Static tempo estimation&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Plot dynamic tempo estimates over a tempogram</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tg</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">tempogram</span><span class="p">(</span><span class="n">onset_envelope</span><span class="o">=</span><span class="n">onset_env</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
<span class="gp">... </span>                               <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;tempo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">times_like</span><span class="p">(</span><span class="n">dtempo</span><span class="p">),</span> <span class="n">dtempo</span><span class="p">,</span>
<span class="gp">... </span>         <span class="n">color</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Tempo estimate (default prior)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">times_like</span><span class="p">(</span><span class="n">dtempo_lognorm</span><span class="p">),</span> <span class="n">dtempo_lognorm</span><span class="p">,</span>
<span class="gp">... </span>         <span class="n">color</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span>
<span class="gp">... </span>         <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Tempo estimate (lognorm prior)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Dynamic tempo estimation&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">framealpha</span><span class="o">=</span><span class="mf">0.75</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.beat.plp">
<code class="descclassname">librosa.beat.</code><code class="descname">plp</code><span class="sig-paren">(</span><em>y=None</em>, <em>sr=22050</em>, <em>onset_envelope=None</em>, <em>hop_length=512</em>, <em>win_length=384</em>, <em>tempo_min=30</em>, <em>tempo_max=300</em>, <em>prior=None</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.beat.plp" title="Permalink to this definition">¶</a></dt>
<dd><p>Predominant local pulse (PLP) estimation. <a href="#id104"><span class="problematic" id="id55">[1]_</span></a></p>
<p>The PLP method analyzes the onset strength envelope in the frequency domain
to find a locally stable tempo for each frame.  These local periodicities
are used to synthesize local half-waves, which are combined such that peaks
coincide with rhythmically salient frames (e.g. onset events on a musical time grid).
The local maxima of the pulse curve can be taken as estimated beat positions.</p>
<p>This method may be preferred over the dynamic programming method of <cite>beat_track</cite>
when either the tempo is expected to vary significantly over time.  Additionally,
since <cite>plp</cite> does not require the entire signal to make predictions, it may be
preferable when beat-tracking long recordings in a streaming setting.</p>
<table class="docutils footnote" frame="void" id="id56" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Grosche, P., &amp; Muller, M. (2011).
“Extracting predominant local pulse information from music recordings.”
IEEE Transactions on Audio, Speech, and Language Processing, 19(6), 1688-1701.</td></tr>
</tbody>
</table>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or None</span></dt>
<dd>audio time series</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>sampling rate of <cite>y</cite></dd>
<dt>onset_envelope <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or None</span></dt>
<dd>(optional) pre-computed onset strength envelope</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>number of audio samples between successive <cite>onset_envelope</cite> values</dd>
<dt>win_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>number of frames to use for tempogram analysis.
By default, 384 frames (at <cite>sr=22050</cite> and <cite>hop_length=512</cite>) corresponds
to about 8.9 seconds.</dd>
<dt>tempo_min, tempo_max <span class="classifier-delimiter">:</span> <span class="classifier">numbers &gt; 0 [scalar], optional</span></dt>
<dd><p class="first">Minimum and maximum permissible tempo values.  <cite>tempo_max</cite> must be at least
<cite>tempo_min</cite>.</p>
<p class="last">Set either (or both) to <cite>None</cite> to disable this constraint.</p>
</dd>
<dt>prior <span class="classifier-delimiter">:</span> <span class="classifier">scipy.stats.rv_continuous [optional]</span></dt>
<dd>A prior distribution over tempo (in beats per minute).
By default, a uniform prior over <cite>[tempo_min, tempo_max]</cite> is used.</dd>
</dl>
<dl class="docutils">
<dt>pulse <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=[(n,)]</span></dt>
<dd>The estimated pulse curve.  Maxima correspond to rhythmically salient
points of time.</dd>
</dl>
<p>beat_track
librosa.onset.onset_strength
librosa.feature.fourier_tempogram</p>
<p>Visualize the PLP compared to an onset strength envelope.
Both are normalized here to make comparison easier.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">onset_env</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">onset</span><span class="o">.</span><span class="n">onset_strength</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pulse</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">plp</span><span class="p">(</span><span class="n">onset_envelope</span><span class="o">=</span><span class="n">onset_env</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Or compute pulse with an alternate prior, like log-normal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">scipy.stats</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prior</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">lognorm</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">120</span><span class="p">),</span> <span class="n">scale</span><span class="o">=</span><span class="mi">120</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pulse_lognorm</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">plp</span><span class="p">(</span><span class="n">onset_envelope</span><span class="o">=</span><span class="n">onset_env</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
<span class="gp">... </span>                                 <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">melspec</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">melspectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">power_to_db</span><span class="p">(</span><span class="n">melspec</span><span class="p">,</span>
<span class="gp">... </span>                                             <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">),</span>
<span class="gp">... </span>                         <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;mel&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Mel spectrogram&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">times_like</span><span class="p">(</span><span class="n">onset_env</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">onset_env</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Onset strength&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">times_like</span><span class="p">(</span><span class="n">pulse</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">pulse</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Predominant local pulse (PLP)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Uniform tempo prior [30, 300]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">times_like</span><span class="p">(</span><span class="n">onset_env</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">onset_env</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Onset strength&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">times_like</span><span class="p">(</span><span class="n">pulse_lognorm</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">pulse_lognorm</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Predominant local pulse (PLP)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Log-normal tempo prior, mean=120&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">30</span><span class="p">,</span> <span class="mi">35</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>PLP local maxima can be used as estimates of beat positions.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tempo</span><span class="p">,</span> <span class="n">beats</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">beat_track</span><span class="p">(</span><span class="n">onset_envelope</span><span class="o">=</span><span class="n">onset_env</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">beats_plp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">localmax</span><span class="p">(</span><span class="n">pulse</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">times</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">times_like</span><span class="p">(</span><span class="n">onset_env</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">onset_env</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Onset strength&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">beats</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span>
<span class="gp">... </span>           <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Beats&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">framealpha</span><span class="o">=</span><span class="mf">0.75</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;librosa.beat.beat_track&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Limit the plot to a 15-second window</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">times</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">times_like</span><span class="p">(</span><span class="n">pulse</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">pulse</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">label</span><span class="o">=</span><span class="s1">&#39;PLP&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">beats_plp</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span>
<span class="gp">... </span>           <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;PLP Beats&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">framealpha</span><span class="o">=</span><span class="mf">0.75</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;librosa.beat.plp&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">35</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">TimeFormatter</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-librosa.feature">
<span id="feature-extraction"></span><h1>Feature extraction<a class="headerlink" href="#module-librosa.feature" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id57">
<h2>Feature extraction<a class="headerlink" href="#id57" title="Permalink to this headline">¶</a></h2>
<div class="section" id="spectral-features">
<h3>Spectral features<a class="headerlink" href="#spectral-features" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="rhythm-features">
<h3>Rhythm features<a class="headerlink" href="#rhythm-features" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="feature-manipulation">
<h3>Feature manipulation<a class="headerlink" href="#feature-manipulation" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="feature-inversion">
<h3>Feature inversion<a class="headerlink" href="#feature-inversion" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="librosa.feature.chroma_cens">
<code class="descclassname">librosa.feature.</code><code class="descname">chroma_cens</code><span class="sig-paren">(</span><em>y=None</em>, <em>sr=22050</em>, <em>C=None</em>, <em>hop_length=512</em>, <em>fmin=None</em>, <em>tuning=None</em>, <em>n_chroma=12</em>, <em>n_octaves=7</em>, <em>bins_per_octave=None</em>, <em>cqt_mode='full'</em>, <em>window=None</em>, <em>norm=2</em>, <em>win_len_smooth=41</em>, <em>smoothing_window='hann'</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.feature.chroma_cens" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the chroma variant “Chroma Energy Normalized” (CENS), following <a href="#id105"><span class="problematic" id="id58">[1]_</span></a>.</p>
<p>To compute CENS features, following steps are taken after obtaining chroma vectors using <cite>chroma_cqt</cite>:
1. L-1 normalization of each chroma vector
2. Quantization of amplitude based on “log-like” amplitude thresholds
3. (optional) Smoothing with sliding window. Default window length = 41 frames
4. (not implemented) Downsampling</p>
<p>CENS features are robust to dynamics, timbre and articulation, thus these are commonly used in audio
matching and retrieval applications.</p>
<table class="docutils footnote" frame="void" id="id59" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Meinard Müller and Sebastian Ewert
“Chroma Toolbox: MATLAB implementations for extracting variants of chroma-based audio features”
In Proceedings of the International Conference on Music Information Retrieval (ISMIR), 2011.</td></tr>
</tbody>
</table>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd>audio time series</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0</span></dt>
<dd>sampling rate of <cite>y</cite></dd>
<dt>C <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)] [Optional]</span></dt>
<dd>a pre-computed constant-Q spectrogram</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>number of samples between successive chroma frames</dd>
<dt>fmin <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd>minimum frequency to analyze in the CQT.
Default: ‘C1’ ~= 32.7 Hz</dd>
<dt>norm <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0, +-np.inf, or None</span></dt>
<dd>Column-wise normalization of the chromagram.</dd>
<dt>tuning <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Deviation (in fractions of a CQT bin) from A440 tuning</dd>
<dt>n_chroma <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>Number of chroma bins to produce</dd>
<dt>n_octaves <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>Number of octaves to analyze above <cite>fmin</cite></dd>
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">None or np.ndarray</span></dt>
<dd>Optional window parameter to <cite>filters.cq_to_chroma</cite></dd>
<dt>bins_per_octave <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>Number of bins per octave in the CQT.
Default: matches <cite>n_chroma</cite></dd>
<dt>cqt_mode <span class="classifier-delimiter">:</span> <span class="classifier">[‘full’, ‘hybrid’]</span></dt>
<dd>Constant-Q transform mode</dd>
<dt>win_len_smooth <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 or None</span></dt>
<dd>Length of temporal smoothing window. <cite>None</cite> disables temporal smoothing.
Default: 41</dd>
<dt>smoothing_window <span class="classifier-delimiter">:</span> <span class="classifier">str, float or tuple</span></dt>
<dd>Type of window function for temporal smoothing. See <cite>filters.get_window</cite> for possible inputs.
Default: ‘hann’</dd>
</dl>
<dl class="docutils">
<dt>chroma_cens <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n_chroma, t)]</span></dt>
<dd>The output cens-chromagram</dd>
</dl>
<dl class="docutils">
<dt>chroma_cqt</dt>
<dd>Compute a chromagram from a constant-Q transform.</dd>
<dt>chroma_stft</dt>
<dd>Compute a chromagram from an STFT spectrogram or waveform.</dd>
<dt>filters.get_window</dt>
<dd>Compute a window function.</dd>
</dl>
<p>Compare standard cqt chroma to CENS.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">(),</span>
<span class="gp">... </span>                     <span class="n">offset</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chroma_cens</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">chroma_cens</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chroma_cq</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">chroma_cqt</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">chroma_cq</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;chroma&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;chroma_cq&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">chroma_cens</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;chroma&#39;</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;chroma_cens&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.chroma_cqt">
<code class="descclassname">librosa.feature.</code><code class="descname">chroma_cqt</code><span class="sig-paren">(</span><em>y=None</em>, <em>sr=22050</em>, <em>C=None</em>, <em>hop_length=512</em>, <em>fmin=None</em>, <em>norm=inf</em>, <em>threshold=0.0</em>, <em>tuning=None</em>, <em>n_chroma=12</em>, <em>n_octaves=7</em>, <em>window=None</em>, <em>bins_per_octave=None</em>, <em>cqt_mode='full'</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.feature.chroma_cqt" title="Permalink to this definition">¶</a></dt>
<dd><p>Constant-Q chromagram</p>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd>audio time series</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0</span></dt>
<dd>sampling rate of <cite>y</cite></dd>
<dt>C <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)] [Optional]</span></dt>
<dd>a pre-computed constant-Q spectrogram</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>number of samples between successive chroma frames</dd>
<dt>fmin <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd>minimum frequency to analyze in the CQT.
Default: ‘C1’ ~= 32.7 Hz</dd>
<dt>norm <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0, +-np.inf, or None</span></dt>
<dd>Column-wise normalization of the chromagram.</dd>
<dt>threshold <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Pre-normalization energy threshold.  Values below the
threshold are discarded, resulting in a sparse chromagram.</dd>
<dt>tuning <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Deviation (in fractions of a CQT bin) from A440 tuning</dd>
<dt>n_chroma <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>Number of chroma bins to produce</dd>
<dt>n_octaves <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>Number of octaves to analyze above <cite>fmin</cite></dd>
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">None or np.ndarray</span></dt>
<dd>Optional window parameter to <cite>filters.cq_to_chroma</cite></dd>
<dt>bins_per_octave <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>Number of bins per octave in the CQT.
Default: matches <cite>n_chroma</cite></dd>
<dt>cqt_mode <span class="classifier-delimiter">:</span> <span class="classifier">[‘full’, ‘hybrid’]</span></dt>
<dd>Constant-Q transform mode</dd>
</dl>
<dl class="docutils">
<dt>chromagram <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n_chroma, t)]</span></dt>
<dd>The output chromagram</dd>
</dl>
<p>librosa.util.normalize
librosa.core.cqt
librosa.core.hybrid_cqt
chroma_stft</p>
<p>Compare a long-window STFT chromagram to the CQT chromagram</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">(),</span>
<span class="gp">... </span>                     <span class="n">offset</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chroma_stft</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">chroma_stft</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
<span class="gp">... </span>                                          <span class="n">n_chroma</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">4096</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chroma_cq</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">chroma_cqt</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">chroma_stft</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;chroma&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;chroma_stft&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">chroma_cq</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;chroma&#39;</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;chroma_cqt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.chroma_stft">
<code class="descclassname">librosa.feature.</code><code class="descname">chroma_stft</code><span class="sig-paren">(</span><em>y=None</em>, <em>sr=22050</em>, <em>S=None</em>, <em>norm=inf</em>, <em>n_fft=2048</em>, <em>hop_length=512</em>, <em>win_length=None</em>, <em>window='hann'</em>, <em>center=True</em>, <em>pad_mode='reflect'</em>, <em>tuning=None</em>, <em>n_chroma=12</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.feature.chroma_stft" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a chromagram from a waveform or power spectrogram.</p>
<p>This implementation is derived from <cite>chromagram_E</cite> <a href="#id106"><span class="problematic" id="id60">[1]_</span></a></p>
<table class="docutils footnote" frame="void" id="id61" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Ellis, Daniel P.W.  “Chroma feature analysis and synthesis”
2007/04/21
<a class="reference external" href="http://labrosa.ee.columbia.edu/matlab/chroma-ansyn/">http://labrosa.ee.columbia.edu/matlab/chroma-ansyn/</a></td></tr>
</tbody>
</table>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or None</span></dt>
<dd>audio time series</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>sampling rate of <cite>y</cite></dd>
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)] or None</span></dt>
<dd>power spectrogram</dd>
<dt>norm <span class="classifier-delimiter">:</span> <span class="classifier">float or None</span></dt>
<dd><p class="first">Column-wise normalization.
See <cite>librosa.util.normalize</cite> for details.</p>
<p class="last">If <cite>None</cite>, no normalization is performed.</p>
</dd>
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">int  &gt; 0 [scalar]</span></dt>
<dd>FFT window size if provided <cite>y, sr</cite> instead of <cite>S</cite></dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>hop length if provided <cite>y, sr</cite> instead of <cite>S</cite></dd>
<dt>win_length <span class="classifier-delimiter">:</span> <span class="classifier">int &lt;= n_fft [scalar]</span></dt>
<dd><p class="first">Each frame of audio is windowed by <cite>window()</cite>.
The window will be of length <cite>win_length</cite> and then padded
with zeros to match <cite>n_fft</cite>.</p>
<p class="last">If unspecified, defaults to <code class="docutils literal notranslate"><span class="pre">win_length</span> <span class="pre">=</span> <span class="pre">n_fft</span></code>.</p>
</dd>
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span></dt>
<dd><ul class="first last simple">
<li>a window specification (string, tuple, or number);
see <cite>scipy.signal.get_window</cite></li>
<li>a window function, such as <cite>scipy.signal.hanning</cite></li>
<li>a vector or array of length <cite>n_fft</cite></li>
</ul>
</dd>
<dt>center <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><ul class="first last simple">
<li>If <cite>True</cite>, the signal <cite>y</cite> is padded so that frame
<cite>t</cite> is centered at <cite>y[t * hop_length]</cite>.</li>
<li>If <cite>False</cite>, then frame <cite>t</cite> begins at <cite>y[t * hop_length]</cite></li>
</ul>
</dd>
<dt>pad_mode <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>If <cite>center=True</cite>, the padding mode to use at the edges of the signal.
By default, STFT uses reflection padding.</dd>
<dt>tuning <span class="classifier-delimiter">:</span> <span class="classifier">float [scalar] or None.</span></dt>
<dd>Deviation from A440 tuning in fractional chroma bins.
If <cite>None</cite>, it is automatically estimated.</dd>
<dt>n_chroma <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>Number of chroma bins to produce (12 by default).</dd>
<dt>kwargs <span class="classifier-delimiter">:</span> <span class="classifier">additional keyword arguments</span></dt>
<dd>Arguments to parameterize chroma filters.
See <cite>librosa.filters.chroma</cite> for details.</dd>
</dl>
<dl class="docutils">
<dt>chromagram <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n_chroma, t)]</span></dt>
<dd>Normalized energy for each chroma bin at each frame.</dd>
</dl>
<dl class="docutils">
<dt>librosa.filters.chroma</dt>
<dd>Chroma filter bank construction</dd>
<dt>librosa.util.normalize</dt>
<dd>Vector normalization</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">chroma_stft</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="go">array([[ 0.974,  0.881, ...,  0.925,  1.   ],</span>
<span class="go">       [ 1.   ,  0.841, ...,  0.882,  0.878],</span>
<span class="go">       ...,</span>
<span class="go">       [ 0.658,  0.985, ...,  0.878,  0.764],</span>
<span class="go">       [ 0.969,  0.92 , ...,  0.974,  0.915]])</span>
</pre></div>
</div>
<p>Use an energy (magnitude) spectrum instead of power spectrogram</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chroma</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">chroma_stft</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chroma</span>
<span class="go">array([[ 0.884,  0.91 , ...,  0.861,  0.858],</span>
<span class="go">       [ 0.963,  0.785, ...,  0.968,  0.896],</span>
<span class="go">       ...,</span>
<span class="go">       [ 0.871,  1.   , ...,  0.928,  0.829],</span>
<span class="go">       [ 1.   ,  0.982, ...,  0.93 ,  0.878]])</span>
</pre></div>
</div>
<p>Use a pre-computed power spectrogram with a larger frame</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">4096</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chroma</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">chroma_stft</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chroma</span>
<span class="go">array([[ 0.685,  0.477, ...,  0.961,  0.986],</span>
<span class="go">       [ 0.674,  0.452, ...,  0.952,  0.926],</span>
<span class="go">       ...,</span>
<span class="go">       [ 0.844,  0.575, ...,  0.934,  0.869],</span>
<span class="go">       [ 0.793,  0.663, ...,  0.964,  0.972]])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">chroma</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;chroma&#39;</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Chromagram&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.delta">
<code class="descclassname">librosa.feature.</code><code class="descname">delta</code><span class="sig-paren">(</span><em>data</em>, <em>width=9</em>, <em>order=1</em>, <em>axis=-1</em>, <em>mode='interp'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.feature.delta" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute delta features: local estimate of the derivative
of the input data along the selected axis.</p>
<p>Delta features are computed Savitsky-Golay filtering.</p>
<dl class="docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>the input data matrix (eg, spectrogram)</dd>
<dt>width <span class="classifier-delimiter">:</span> <span class="classifier">int, positive, odd [scalar]</span></dt>
<dd>Number of frames over which to compute the delta features.
Cannot exceed the length of <cite>data</cite> along the specified axis.
If <cite>mode=’interp’</cite>, then <cite>width</cite> must be at least <cite>data.shape[axis]</cite>.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>the order of the difference operator.
1 for first derivative, 2 for second, etc.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int [scalar]</span></dt>
<dd>the axis along which to compute deltas.
Default is -1 (columns).</dd>
<dt>mode <span class="classifier-delimiter">:</span> <span class="classifier">str, {‘interp’, ‘nearest’, ‘mirror’, ‘constant’, ‘wrap’}</span></dt>
<dd>Padding mode for estimating differences at the boundaries.</dd>
<dt>kwargs <span class="classifier-delimiter">:</span> <span class="classifier">additional keyword arguments</span></dt>
<dd>See <cite>scipy.signal.savgol_filter</cite></dd>
</dl>
<dl class="docutils">
<dt>delta_data <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)]</span></dt>
<dd>delta matrix of <cite>data</cite> at specified order</dd>
</dl>
<p>This function caches at level 40.</p>
<p>scipy.signal.savgol_filter</p>
<p>Compute MFCC deltas, delta-deltas</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mfcc</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">mfcc</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mfcc_delta</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">delta</span><span class="p">(</span><span class="n">mfcc</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mfcc_delta</span>
<span class="go">array([[  1.666e+01,   1.666e+01, ...,   1.869e-15,   1.869e-15],</span>
<span class="go">       [  1.784e+01,   1.784e+01, ...,   6.085e-31,   6.085e-31],</span>
<span class="go">       ...,</span>
<span class="go">       [  7.262e-01,   7.262e-01, ...,   9.259e-31,   9.259e-31],</span>
<span class="go">       [  6.578e-01,   6.578e-01, ...,   7.597e-31,   7.597e-31]])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mfcc_delta2</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">delta</span><span class="p">(</span><span class="n">mfcc</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mfcc_delta2</span>
<span class="go">array([[ -1.703e+01,  -1.703e+01, ...,   3.834e-14,   3.834e-14],</span>
<span class="go">       [ -1.108e+01,  -1.108e+01, ...,  -1.068e-30,  -1.068e-30],</span>
<span class="go">       ...,</span>
<span class="go">       [  4.075e-01,   4.075e-01, ...,  -1.565e-30,  -1.565e-30],</span>
<span class="go">       [  1.676e-01,   1.676e-01, ...,  -2.104e-30,  -2.104e-30]])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">mfcc</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;MFCC&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">mfcc_delta</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;MFCC-$\Delta$&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">mfcc_delta2</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;MFCC-$\Delta^2$&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.fourier_tempogram">
<code class="descclassname">librosa.feature.</code><code class="descname">fourier_tempogram</code><span class="sig-paren">(</span><em>y=None</em>, <em>sr=22050</em>, <em>onset_envelope=None</em>, <em>hop_length=512</em>, <em>win_length=384</em>, <em>center=True</em>, <em>window='hann'</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.feature.fourier_tempogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Fourier tempogram: the short-time Fourier transform of the
onset strength envelope. <a href="#id107"><span class="problematic" id="id62">[1]_</span></a></p>
<table class="docutils footnote" frame="void" id="id63" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Grosche, Peter, Meinard Müller, and Frank Kurth.
“Cyclic tempogram - A mid-level tempo representation for music signals.”
ICASSP, 2010.</td></tr>
</tbody>
</table>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or None</span></dt>
<dd>Audio time series.</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>sampling rate of <cite>y</cite></dd>
<dt>onset_envelope <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or None</span></dt>
<dd>Optional pre-computed onset strength envelope as provided by
<cite>onset.onset_strength</cite>.</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>number of audio samples between successive onset measurements</dd>
<dt>win_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>length of the onset window (in frames/onset measurements)
The default settings (384) corresponds to <cite>384 * hop_length / sr ~= 8.9s</cite>.</dd>
<dt>center <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If <cite>True</cite>, onset windows are centered.
If <cite>False</cite>, windows are left-aligned.</dd>
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">string, function, number, tuple, or np.ndarray [shape=(win_length,)]</span></dt>
<dd>A window specification as in <cite>core.stft</cite>.</dd>
</dl>
<dl class="docutils">
<dt>tempogram <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(win_length // 2 + 1, n)]</span></dt>
<dd>Complex short-time Fourier transform of the onset envelope.</dd>
</dl>
<dl class="docutils">
<dt>ParameterError</dt>
<dd><p class="first">if neither <cite>y</cite> nor <cite>onset_envelope</cite> are provided</p>
<p class="last">if <cite>win_length &lt; 1</cite></p>
</dd>
</dl>
<p>tempogram
librosa.onset.onset_strength
librosa.util.normalize
librosa.core.stft</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute local onset autocorrelation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hop_length</span> <span class="o">=</span> <span class="mi">512</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">oenv</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">onset</span><span class="o">.</span><span class="n">onset_strength</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tempogram</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">fourier_tempogram</span><span class="p">(</span><span class="n">onset_envelope</span><span class="o">=</span><span class="n">oenv</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute the auto-correlation tempogram, unnormalized to make comparison easier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ac_tempogram</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">tempogram</span><span class="p">(</span><span class="n">onset_envelope</span><span class="o">=</span><span class="n">oenv</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
<span class="gp">... </span>                                         <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">oenv</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Onset strength&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tempogram</span><span class="p">),</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                         <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;fourier_tempo&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;magma&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Fourier tempogram&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">ac_tempogram</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                         <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;tempo&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;magma&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Autocorrelation tempogram&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.melspectrogram">
<code class="descclassname">librosa.feature.</code><code class="descname">melspectrogram</code><span class="sig-paren">(</span><em>y=None</em>, <em>sr=22050</em>, <em>S=None</em>, <em>n_fft=2048</em>, <em>hop_length=512</em>, <em>win_length=None</em>, <em>window='hann'</em>, <em>center=True</em>, <em>pad_mode='reflect'</em>, <em>power=2.0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.feature.melspectrogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a mel-scaled spectrogram.</p>
<p>If a spectrogram input <cite>S</cite> is provided, then it is mapped directly onto
the mel basis <cite>mel_f</cite> by <cite>mel_f.dot(S)</cite>.</p>
<p>If a time-series input <cite>y, sr</cite> is provided, then its magnitude spectrogram
<cite>S</cite> is first computed, and then mapped onto the mel scale by
<cite>mel_f.dot(S**power)</cite>.  By default, <cite>power=2</cite> operates on a power spectrum.</p>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or None</span></dt>
<dd>audio time-series</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>sampling rate of <cite>y</cite></dd>
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)]</span></dt>
<dd>spectrogram</dd>
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>length of the FFT window</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>number of samples between successive frames.
See <cite>librosa.core.stft</cite></dd>
<dt>win_length <span class="classifier-delimiter">:</span> <span class="classifier">int &lt;= n_fft [scalar]</span></dt>
<dd><p class="first">Each frame of audio is windowed by <cite>window()</cite>.
The window will be of length <cite>win_length</cite> and then padded
with zeros to match <cite>n_fft</cite>.</p>
<p class="last">If unspecified, defaults to <code class="docutils literal notranslate"><span class="pre">win_length</span> <span class="pre">=</span> <span class="pre">n_fft</span></code>.</p>
</dd>
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span></dt>
<dd><ul class="first last simple">
<li>a window specification (string, tuple, or number);
see <cite>scipy.signal.get_window</cite></li>
<li>a window function, such as <cite>scipy.signal.hanning</cite></li>
<li>a vector or array of length <cite>n_fft</cite></li>
</ul>
</dd>
<dt>center <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><ul class="first last simple">
<li>If <cite>True</cite>, the signal <cite>y</cite> is padded so that frame
<cite>t</cite> is centered at <cite>y[t * hop_length]</cite>.</li>
<li>If <cite>False</cite>, then frame <cite>t</cite> begins at <cite>y[t * hop_length]</cite></li>
</ul>
</dd>
<dt>pad_mode <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>If <cite>center=True</cite>, the padding mode to use at the edges of the signal.
By default, STFT uses reflection padding.</dd>
<dt>power <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd>Exponent for the magnitude melspectrogram.
e.g., 1 for energy, 2 for power, etc.</dd>
<dt>kwargs <span class="classifier-delimiter">:</span> <span class="classifier">additional keyword arguments</span></dt>
<dd>Mel filter bank parameters.
See <cite>librosa.filters.mel</cite> for details.</dd>
</dl>
<dl class="docutils">
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n_mels, t)]</span></dt>
<dd>Mel spectrogram</dd>
</dl>
<dl class="docutils">
<dt>librosa.filters.mel</dt>
<dd>Mel filter bank construction</dd>
<dt>librosa.core.stft</dt>
<dd>Short-time Fourier Transform</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">melspectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="go">array([[  2.891e-07,   2.548e-03, ...,   8.116e-09,   5.633e-09],</span>
<span class="go">       [  1.986e-07,   1.162e-02, ...,   9.332e-08,   6.716e-09],</span>
<span class="go">       ...,</span>
<span class="go">       [  3.668e-09,   2.029e-08, ...,   3.208e-09,   2.864e-09],</span>
<span class="go">       [  2.561e-10,   2.096e-09, ...,   7.543e-10,   6.101e-10]])</span>
</pre></div>
</div>
<p>Using a pre-computed power spectrogram would give the same result:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">melspectrogram</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">D</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
<p>Display of mel-frequency spectrogram coefficients, with custom
arguments for mel filterbank construction (default is fmax=sr/2):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Passing through arguments to the Mel filters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">melspectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_mels</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="n">fmax</span><span class="o">=</span><span class="mi">8000</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S_dB</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">power_to_db</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">S_dB</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;mel&#39;</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">fmax</span><span class="o">=</span><span class="mi">8000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%+2.0f</span><span class="s1"> dB&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Mel-frequency spectrogram&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.mfcc">
<code class="descclassname">librosa.feature.</code><code class="descname">mfcc</code><span class="sig-paren">(</span><em>y=None</em>, <em>sr=22050</em>, <em>S=None</em>, <em>n_mfcc=20</em>, <em>dct_type=2</em>, <em>norm='ortho'</em>, <em>lifter=0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.feature.mfcc" title="Permalink to this definition">¶</a></dt>
<dd><p>Mel-frequency cepstral coefficients (MFCCs)</p>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or None</span></dt>
<dd>audio time series</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>sampling rate of <cite>y</cite></dd>
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)] or None</span></dt>
<dd>log-power Mel spectrogram</dd>
<dt>n_mfcc: int &gt; 0 [scalar]</dt>
<dd>number of MFCCs to return</dd>
<dt>dct_type <span class="classifier-delimiter">:</span> <span class="classifier">None, or {1, 2, 3}</span></dt>
<dd>Discrete cosine transform (DCT) type.
By default, DCT type-2 is used.</dd>
<dt>norm <span class="classifier-delimiter">:</span> <span class="classifier">None or ‘ortho’</span></dt>
<dd><p class="first">If <cite>dct_type</cite> is <cite>2 or 3</cite>, setting <cite>norm=’ortho’</cite> uses an ortho-normal
DCT basis.</p>
<p class="last">Normalization is not supported for <cite>dct_type=1</cite>.</p>
</dd>
<dt>lifter <span class="classifier-delimiter">:</span> <span class="classifier">number &gt;= 0</span></dt>
<dd><p class="first">If <cite>lifter&gt;0</cite>, apply <em>liftering</em> (cepstral filtering) to the MFCCs:</p>
<p><cite>M[n, :] &lt;- M[n, :] * (1 + sin(pi * (n + 1) / lifter)) * lifter / 2</cite></p>
<p class="last">Setting <cite>lifter &gt;= 2 * n_mfcc</cite> emphasizes the higher-order coefficients.
As <cite>lifter</cite> increases, the coefficient weighting becomes approximately linear.</p>
</dd>
<dt>kwargs <span class="classifier-delimiter">:</span> <span class="classifier">additional keyword arguments</span></dt>
<dd>Arguments to <cite>melspectrogram</cite>, if operating
on time series input</dd>
</dl>
<dl class="docutils">
<dt>M <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n_mfcc, t)]</span></dt>
<dd>MFCC sequence</dd>
</dl>
<p>melspectrogram
scipy.fftpack.dct</p>
<p>Generate mfccs from a time series</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">(),</span> <span class="n">offset</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">mfcc</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="go">array([[ -5.229e+02,  -4.944e+02, ...,  -5.229e+02,  -5.229e+02],</span>
<span class="go">       [  7.105e-15,   3.787e+01, ...,  -7.105e-15,  -7.105e-15],</span>
<span class="go">       ...,</span>
<span class="go">       [  1.066e-14,  -7.500e+00, ...,   1.421e-14,   1.421e-14],</span>
<span class="go">       [  3.109e-14,  -5.058e+00, ...,   2.931e-14,   2.931e-14]])</span>
</pre></div>
</div>
<p>Using a different hop length and HTK-style Mel frequencies</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">mfcc</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="n">htk</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[-1.628e+02, -8.903e+01, -1.409e+02, ..., -1.078e+02,</span>
<span class="go">    -2.504e+02, -2.393e+02],</span>
<span class="go">   [ 1.275e+02,  9.532e+01,  1.019e+02, ...,  1.152e+02,</span>
<span class="go">     2.224e+02,  1.750e+02],</span>
<span class="go">   [ 1.139e+01,  6.155e+00,  1.266e+01, ...,  4.557e+01,</span>
<span class="go">     4.585e+01,  3.985e+01],</span>
<span class="go">   ...,</span>
<span class="go">   [ 3.462e+00,  4.032e+00, -5.694e-01, ..., -6.677e+00,</span>
<span class="go">    -1.183e-01,  1.485e+00],</span>
<span class="go">   [ 9.569e-01,  1.069e+00, -6.865e+00, ..., -9.598e+00,</span>
<span class="go">    -1.611e+00, -6.716e+00],</span>
<span class="go">   [ 8.457e+00,  3.582e+00, -1.156e-01, ..., -3.018e+00,</span>
<span class="go">    -1.456e+01, -6.991e+00]], dtype=float32)</span>
</pre></div>
</div>
<p>Use a pre-computed log-power Mel spectrogram</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">melspectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_mels</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span>
<span class="gp">... </span>                                   <span class="n">fmax</span><span class="o">=</span><span class="mi">8000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">mfcc</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">librosa</span><span class="o">.</span><span class="n">power_to_db</span><span class="p">(</span><span class="n">S</span><span class="p">))</span>
<span class="go">array([[ -5.207e+02,  -4.898e+02, ...,  -5.207e+02,  -5.207e+02],</span>
<span class="go">       [ -2.576e-14,   4.054e+01, ...,  -3.997e-14,  -3.997e-14],</span>
<span class="go">       ...,</span>
<span class="go">       [  7.105e-15,  -3.534e+00, ...,   0.000e+00,   0.000e+00],</span>
<span class="go">       [  3.020e-14,  -2.613e+00, ...,   3.553e-14,   3.553e-14]])</span>
</pre></div>
</div>
<p>Get more components</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mfccs</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">mfcc</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_mfcc</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
</pre></div>
</div>
<p>Visualize the MFCC series</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">mfccs</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;MFCC&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Compare different DCT bases</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m_slaney</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">mfcc</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">dct_type</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m_htk</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">mfcc</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">dct_type</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">m_slaney</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;RASTAMAT / Auditory toolbox (dct_type=2)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">m_htk</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;HTK-style (dct_type=3)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.poly_features">
<code class="descclassname">librosa.feature.</code><code class="descname">poly_features</code><span class="sig-paren">(</span><em>y=None</em>, <em>sr=22050</em>, <em>S=None</em>, <em>n_fft=2048</em>, <em>hop_length=512</em>, <em>win_length=None</em>, <em>window='hann'</em>, <em>center=True</em>, <em>pad_mode='reflect'</em>, <em>order=1</em>, <em>freq=None</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.feature.poly_features" title="Permalink to this definition">¶</a></dt>
<dd><p>Get coefficients of fitting an nth-order polynomial to the columns
of a spectrogram.</p>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or None</span></dt>
<dd>audio time series</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>audio sampling rate of <cite>y</cite></dd>
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)] or None</span></dt>
<dd>(optional) spectrogram magnitude</dd>
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>FFT window size</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>hop length for STFT. See <cite>librosa.core.stft</cite> for details.</dd>
<dt>win_length <span class="classifier-delimiter">:</span> <span class="classifier">int &lt;= n_fft [scalar]</span></dt>
<dd><p class="first">Each frame of audio is windowed by <cite>window()</cite>.
The window will be of length <cite>win_length</cite> and then padded
with zeros to match <cite>n_fft</cite>.</p>
<p class="last">If unspecified, defaults to <code class="docutils literal notranslate"><span class="pre">win_length</span> <span class="pre">=</span> <span class="pre">n_fft</span></code>.</p>
</dd>
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span></dt>
<dd><ul class="first last simple">
<li>a window specification (string, tuple, or number);
see <cite>scipy.signal.get_window</cite></li>
<li>a window function, such as <cite>scipy.signal.hanning</cite></li>
<li>a vector or array of length <cite>n_fft</cite></li>
</ul>
</dd>
<dt>center <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><ul class="first last simple">
<li>If <cite>True</cite>, the signal <cite>y</cite> is padded so that frame
<cite>t</cite> is centered at <cite>y[t * hop_length]</cite>.</li>
<li>If <cite>False</cite>, then frame <cite>t</cite> begins at <cite>y[t * hop_length]</cite></li>
</ul>
</dd>
<dt>pad_mode <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>If <cite>center=True</cite>, the padding mode to use at the edges of the signal.
By default, STFT uses reflection padding.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>order of the polynomial to fit</dd>
<dt>freq <span class="classifier-delimiter">:</span> <span class="classifier">None or np.ndarray [shape=(d,) or shape=(d, t)]</span></dt>
<dd>Center frequencies for spectrogram bins.
If <cite>None</cite>, then FFT bin center frequencies are used.
Otherwise, it can be a single array of <cite>d</cite> center frequencies,
or a matrix of center frequencies as constructed by
<cite>librosa.core.ifgram</cite></dd>
</dl>
<dl class="docutils">
<dt>coefficients <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(order+1, t)]</span></dt>
<dd><p class="first">polynomial coefficients for each frame.</p>
<p><cite>coeffecients[0]</cite> corresponds to the highest degree (<cite>order</cite>),</p>
<p><cite>coefficients[1]</cite> corresponds to the next highest degree (<cite>order-1</cite>),</p>
<p class="last">down to the constant term <cite>coefficients[order]</cite>.</p>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
</pre></div>
</div>
<p>Fit a degree-0 polynomial (constant) to each frame</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p0</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">poly_features</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Fit a linear polynomial to each frame</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">poly_features</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Fit a quadratic to each frame</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">poly_features</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Plot the results for comparison</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;order=2&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;order=1&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">p0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;order=0&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Constant&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;order=2&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;order=1&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Linear&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;order=2&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Quadratic&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">amplitude_to_db</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">),</span>
<span class="gp">... </span>                         <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.rms">
<code class="descclassname">librosa.feature.</code><code class="descname">rms</code><span class="sig-paren">(</span><em>y=None</em>, <em>S=None</em>, <em>frame_length=2048</em>, <em>hop_length=512</em>, <em>center=True</em>, <em>pad_mode='reflect'</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.feature.rms" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute root-mean-square (RMS) value for each frame, either from the
audio samples <cite>y</cite> or from a spectrogram <cite>S</cite>.</p>
<p>Computing the RMS value from audio samples is faster as it doesn’t require
a STFT calculation. However, using a spectrogram will give a more accurate
representation of energy over time because its frames can be windowed,
thus prefer using <cite>S</cite> if it’s already available.</p>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or None</span></dt>
<dd>(optional) audio time series. Required if <cite>S</cite> is not input.</dd>
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)] or None</span></dt>
<dd>(optional) spectrogram magnitude. Required if <cite>y</cite> is not input.</dd>
<dt>frame_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>length of analysis frame (in samples) for energy calculation</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>hop length for STFT. See <cite>librosa.core.stft</cite> for details.</dd>
<dt>center <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first">If <cite>True</cite> and operating on time-domain input (<cite>y</cite>), pad the signal
by <cite>frame_length//2</cite> on either side.</p>
<p class="last">If operating on spectrogram input, this has no effect.</p>
</dd>
<dt>pad_mode <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Padding mode for centered analysis.  See <cite>np.pad</cite> for valid
values.</dd>
</dl>
<dl class="docutils">
<dt>rms <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(1, t)]</span></dt>
<dd>RMS value for each frame</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">rms</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
<span class="go">array([[ 0.   ,  0.056, ...,  0.   ,  0.   ]], dtype=float32)</span>
</pre></div>
</div>
<p>Or from spectrogram input</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">magphase</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rms</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">rms</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">rms</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;RMS Energy&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">rms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">amplitude_to_db</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">),</span>
<span class="gp">... </span>                         <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;log Power spectrogram&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
<p>Use a STFT window of constant ones and no frame centering to get consistent
results with the RMS computed from the audio samples <cite>y</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">magphase</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">False</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">rms</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.spectral_bandwidth">
<code class="descclassname">librosa.feature.</code><code class="descname">spectral_bandwidth</code><span class="sig-paren">(</span><em>y=None</em>, <em>sr=22050</em>, <em>S=None</em>, <em>n_fft=2048</em>, <em>hop_length=512</em>, <em>win_length=None</em>, <em>window='hann'</em>, <em>center=True</em>, <em>pad_mode='reflect'</em>, <em>freq=None</em>, <em>centroid=None</em>, <em>norm=True</em>, <em>p=2</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.feature.spectral_bandwidth" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute p’th-order spectral bandwidth.</p>
<blockquote>
<div><p>The spectral bandwidth <a href="#id108"><span class="problematic" id="id64">[1]_</span></a> at frame <cite>t</cite> is computed by</p>
<blockquote>
<div>(sum_k S[k, t] * (freq[k, t] - centroid[t])**p)**(1/p)</div></blockquote>
</div></blockquote>
<table class="docutils footnote" frame="void" id="id65" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Klapuri, A., &amp; Davy, M. (Eds.). (2007). Signal processing
methods for music transcription, chapter 5.
Springer Science &amp; Business Media.</td></tr>
</tbody>
</table>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or None</span></dt>
<dd>audio time series</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>audio sampling rate of <cite>y</cite></dd>
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)] or None</span></dt>
<dd>(optional) spectrogram magnitude</dd>
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>FFT window size</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>hop length for STFT. See <cite>librosa.core.stft</cite> for details.</dd>
<dt>win_length <span class="classifier-delimiter">:</span> <span class="classifier">int &lt;= n_fft [scalar]</span></dt>
<dd><p class="first">Each frame of audio is windowed by <cite>window()</cite>.
The window will be of length <cite>win_length</cite> and then padded
with zeros to match <cite>n_fft</cite>.</p>
<p class="last">If unspecified, defaults to <code class="docutils literal notranslate"><span class="pre">win_length</span> <span class="pre">=</span> <span class="pre">n_fft</span></code>.</p>
</dd>
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span></dt>
<dd><ul class="first last simple">
<li>a window specification (string, tuple, or number);
see <cite>scipy.signal.get_window</cite></li>
<li>a window function, such as <cite>scipy.signal.hanning</cite></li>
<li>a vector or array of length <cite>n_fft</cite></li>
</ul>
</dd>
<dt>center <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><ul class="first last simple">
<li>If <cite>True</cite>, the signal <cite>y</cite> is padded so that frame
<cite>t</cite> is centered at <cite>y[t * hop_length]</cite>.</li>
<li>If <cite>False</cite>, then frame <cite>t</cite> begins at <cite>y[t * hop_length]</cite></li>
</ul>
</dd>
<dt>pad_mode <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>If <cite>center=True</cite>, the padding mode to use at the edges of the signal.
By default, STFT uses reflection padding.</dd>
<dt>freq <span class="classifier-delimiter">:</span> <span class="classifier">None or np.ndarray [shape=(d,) or shape=(d, t)]</span></dt>
<dd>Center frequencies for spectrogram bins.
If <cite>None</cite>, then FFT bin center frequencies are used.
Otherwise, it can be a single array of <cite>d</cite> center frequencies,
or a matrix of center frequencies as constructed by
<cite>librosa.core.ifgram</cite></dd>
<dt>centroid <span class="classifier-delimiter">:</span> <span class="classifier">None or np.ndarray [shape=(1, t)]</span></dt>
<dd>pre-computed centroid frequencies</dd>
<dt>norm <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Normalize per-frame spectral energy (sum to one)</dd>
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd>Power to raise deviation from spectral centroid.</dd>
</dl>
<dl class="docutils">
<dt>bandwidth <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(1, t)]</span></dt>
<dd>frequency bandwidth for each frame</dd>
</dl>
<p>From time-series input</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spec_bw</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">spectral_bandwidth</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spec_bw</span>
<span class="go">array([[ 3379.878,  1429.486, ...,  3235.214,  3080.148]])</span>
</pre></div>
</div>
<p>From spectrogram input</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">magphase</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">spectral_bandwidth</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">)</span>
<span class="go">array([[ 3379.878,  1429.486, ...,  3235.214,  3080.148]])</span>
</pre></div>
</div>
<p>Using variable bin center frequencies</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">if_gram</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">ifgram</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">spectral_bandwidth</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">D</span><span class="p">),</span> <span class="n">freq</span><span class="o">=</span><span class="n">if_gram</span><span class="p">)</span>
<span class="go">array([[ 3380.011,  1429.11 , ...,  3235.22 ,  3080.148]])</span>
</pre></div>
</div>
<p>Plot the result</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">spec_bw</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Spectral bandwidth&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Hz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">spec_bw</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">amplitude_to_db</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">),</span>
<span class="gp">... </span>                         <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;log Power spectrogram&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.spectral_centroid">
<code class="descclassname">librosa.feature.</code><code class="descname">spectral_centroid</code><span class="sig-paren">(</span><em>y=None</em>, <em>sr=22050</em>, <em>S=None</em>, <em>n_fft=2048</em>, <em>hop_length=512</em>, <em>freq=None</em>, <em>win_length=None</em>, <em>window='hann'</em>, <em>center=True</em>, <em>pad_mode='reflect'</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.feature.spectral_centroid" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the spectral centroid.</p>
<p>Each frame of a magnitude spectrogram is normalized and treated as a
distribution over frequency bins, from which the mean (centroid) is
extracted per frame.</p>
<p>More precisely, the centroid at frame <cite>t</cite> is defined as <a href="#id109"><span class="problematic" id="id66">[1]_</span></a>:</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">centroid[t]</span> <span class="pre">=</span> <span class="pre">sum_k</span> <span class="pre">S[k,</span> <span class="pre">t]</span> <span class="pre">*</span> <span class="pre">freq[k]</span> <span class="pre">/</span> <span class="pre">(sum_j</span> <span class="pre">S[j,</span> <span class="pre">t])</span></code></div></blockquote>
<p>where <cite>S</cite> is a magnitude spectrogram, and <cite>freq</cite> is the array of
frequencies (e.g., FFT frequencies in Hz) of the rows of <cite>S</cite>.</p>
<table class="docutils footnote" frame="void" id="id67" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Klapuri, A., &amp; Davy, M. (Eds.). (2007). Signal processing
methods for music transcription, chapter 5. 
Springer Science &amp; Business Media.</td></tr>
</tbody>
</table>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or None</span></dt>
<dd>audio time series</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>audio sampling rate of <cite>y</cite></dd>
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)] or None</span></dt>
<dd>(optional) spectrogram magnitude</dd>
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>FFT window size</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>hop length for STFT. See <cite>librosa.core.stft</cite> for details.</dd>
<dt>freq <span class="classifier-delimiter">:</span> <span class="classifier">None or np.ndarray [shape=(d,) or shape=(d, t)]</span></dt>
<dd>Center frequencies for spectrogram bins.
If <cite>None</cite>, then FFT bin center frequencies are used.
Otherwise, it can be a single array of <cite>d</cite> center frequencies,
or a matrix of center frequencies as constructed by
<cite>librosa.core.ifgram</cite></dd>
<dt>win_length <span class="classifier-delimiter">:</span> <span class="classifier">int &lt;= n_fft [scalar]</span></dt>
<dd><p class="first">Each frame of audio is windowed by <cite>window()</cite>.
The window will be of length <cite>win_length</cite> and then padded
with zeros to match <cite>n_fft</cite>.</p>
<p class="last">If unspecified, defaults to <code class="docutils literal notranslate"><span class="pre">win_length</span> <span class="pre">=</span> <span class="pre">n_fft</span></code>.</p>
</dd>
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span></dt>
<dd><ul class="first last simple">
<li>a window specification (string, tuple, or number);
see <cite>scipy.signal.get_window</cite></li>
<li>a window function, such as <cite>scipy.signal.hanning</cite></li>
<li>a vector or array of length <cite>n_fft</cite></li>
</ul>
</dd>
<dt>center <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><ul class="first last simple">
<li>If <cite>True</cite>, the signal <cite>y</cite> is padded so that frame
<cite>t</cite> is centered at <cite>y[t * hop_length]</cite>.</li>
<li>If <cite>False</cite>, then frame <cite>t</cite> begins at <cite>y[t * hop_length]</cite></li>
</ul>
</dd>
<dt>pad_mode <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>If <cite>center=True</cite>, the padding mode to use at the edges of the signal.
By default, STFT uses reflection padding.</dd>
</dl>
<dl class="docutils">
<dt>centroid <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(1, t)]</span></dt>
<dd>centroid frequencies</dd>
</dl>
<dl class="docutils">
<dt>librosa.core.stft</dt>
<dd>Short-time Fourier Transform</dd>
<dt>librosa.core.ifgram</dt>
<dd>Instantaneous-frequency spectrogram</dd>
</dl>
<p>From time-series input:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cent</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">spectral_centroid</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cent</span>
<span class="go">array([[ 4382.894,   626.588, ...,  5037.07 ,  5413.398]])</span>
</pre></div>
</div>
<p>From spectrogram input:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">magphase</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">spectral_centroid</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">)</span>
<span class="go">array([[ 4382.894,   626.588, ...,  5037.07 ,  5413.398]])</span>
</pre></div>
</div>
<p>Using variable bin center frequencies:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">if_gram</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">ifgram</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">spectral_centroid</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">D</span><span class="p">),</span> <span class="n">freq</span><span class="o">=</span><span class="n">if_gram</span><span class="p">)</span>
<span class="go">array([[ 4420.719,   625.769, ...,  5011.86 ,  5221.492]])</span>
</pre></div>
</div>
<p>Plot the result</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">cent</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Spectral centroid&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Hz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">cent</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">amplitude_to_db</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">),</span>
<span class="gp">... </span>                         <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;log Power spectrogram&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.spectral_contrast">
<code class="descclassname">librosa.feature.</code><code class="descname">spectral_contrast</code><span class="sig-paren">(</span><em>y=None</em>, <em>sr=22050</em>, <em>S=None</em>, <em>n_fft=2048</em>, <em>hop_length=512</em>, <em>win_length=None</em>, <em>window='hann'</em>, <em>center=True</em>, <em>pad_mode='reflect'</em>, <em>freq=None</em>, <em>fmin=200.0</em>, <em>n_bands=6</em>, <em>quantile=0.02</em>, <em>linear=False</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.feature.spectral_contrast" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute spectral contrast <a href="#id110"><span class="problematic" id="id68">[1]_</span></a></p>
<p>Each frame of a spectrogram <cite>S</cite> is divided into sub-bands.
For each sub-band, the energy contrast is estimated by comparing
the mean energy in the top quantile (peak energy) to that of the 
bottom quantile (valley energy).  High contrast values generally
correspond to clear, narrow-band signals, while low contrast values
correspond to broad-band noise.</p>
<table class="docutils footnote" frame="void" id="id69" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Jiang, Dan-Ning, Lie Lu, Hong-Jiang Zhang, Jian-Hua Tao,
and Lian-Hong Cai.
“Music type classification by spectral contrast feature.”
In Multimedia and Expo, 2002. ICME‘02. Proceedings.
2002 IEEE International Conference on, vol. 1, pp. 113-116.
IEEE, 2002.</td></tr>
</tbody>
</table>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or None</span></dt>
<dd>audio time series</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number  &gt; 0 [scalar]</span></dt>
<dd>audio sampling rate of <cite>y</cite></dd>
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)] or None</span></dt>
<dd>(optional) spectrogram magnitude</dd>
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>FFT window size</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>hop length for STFT. See <cite>librosa.core.stft</cite> for details.</dd>
<dt>win_length <span class="classifier-delimiter">:</span> <span class="classifier">int &lt;= n_fft [scalar]</span></dt>
<dd><p class="first">Each frame of audio is windowed by <cite>window()</cite>.
The window will be of length <cite>win_length</cite> and then padded
with zeros to match <cite>n_fft</cite>.</p>
<p class="last">If unspecified, defaults to <code class="docutils literal notranslate"><span class="pre">win_length</span> <span class="pre">=</span> <span class="pre">n_fft</span></code>.</p>
</dd>
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span></dt>
<dd><ul class="first last simple">
<li>a window specification (string, tuple, or number);
see <cite>scipy.signal.get_window</cite></li>
<li>a window function, such as <cite>scipy.signal.hanning</cite></li>
<li>a vector or array of length <cite>n_fft</cite></li>
</ul>
</dd>
<dt>center <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><ul class="first last simple">
<li>If <cite>True</cite>, the signal <cite>y</cite> is padded so that frame
<cite>t</cite> is centered at <cite>y[t * hop_length]</cite>.</li>
<li>If <cite>False</cite>, then frame <cite>t</cite> begins at <cite>y[t * hop_length]</cite></li>
</ul>
</dd>
<dt>pad_mode <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>If <cite>center=True</cite>, the padding mode to use at the edges of the signal.
By default, STFT uses reflection padding.</dd>
<dt>freq <span class="classifier-delimiter">:</span> <span class="classifier">None or np.ndarray [shape=(d,)]</span></dt>
<dd>Center frequencies for spectrogram bins.
If <cite>None</cite>, then FFT bin center frequencies are used.
Otherwise, it can be a single array of <cite>d</cite> center frequencies.</dd>
<dt>fmin <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd>Frequency cutoff for the first bin <cite>[0, fmin]</cite>
Subsequent bins will cover <cite>[fmin, 2*fmin]</cite>, <cite>[2*fmin, 4*fmin]</cite>, etc.</dd>
<dt>n_bands <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 1</span></dt>
<dd>number of frequency bands</dd>
<dt>quantile <span class="classifier-delimiter">:</span> <span class="classifier">float in (0, 1)</span></dt>
<dd>quantile for determining peaks and valleys</dd>
<dt>linear <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first">If <cite>True</cite>, return the linear difference of magnitudes:
<cite>peaks - valleys</cite>.</p>
<p class="last">If <cite>False</cite>, return the logarithmic difference:
<cite>log(peaks) - log(valleys)</cite>.</p>
</dd>
</dl>
<dl class="docutils">
<dt>contrast <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n_bands + 1, t)]</span></dt>
<dd>each row of spectral contrast values corresponds to a given
octave-based frequency</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">contrast</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">spectral_contrast</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">amplitude_to_db</span><span class="p">(</span><span class="n">S</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">),</span>
<span class="gp">... </span>                         <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%+2.0f</span><span class="s1"> dB&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Power spectrogram&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">contrast</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency bands&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Spectral contrast&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.spectral_flatness">
<code class="descclassname">librosa.feature.</code><code class="descname">spectral_flatness</code><span class="sig-paren">(</span><em>y=None</em>, <em>S=None</em>, <em>n_fft=2048</em>, <em>hop_length=512</em>, <em>win_length=None</em>, <em>window='hann'</em>, <em>center=True</em>, <em>pad_mode='reflect'</em>, <em>amin=1e-10</em>, <em>power=2.0</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.feature.spectral_flatness" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute spectral flatness</p>
<p>Spectral flatness (or tonality coefficient) is a measure to
quantify how much noise-like a sound is, as opposed to being
tone-like <a href="#id111"><span class="problematic" id="id70">[1]_</span></a>. A high spectral flatness (closer to 1.0)
indicates the spectrum is similar to white noise.
It is often converted to decibel.</p>
<table class="docutils footnote" frame="void" id="id71" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Dubnov, Shlomo  “Generalization of spectral flatness
measure for non-gaussian linear processes”
IEEE Signal Processing Letters, 2004, Vol. 11.</td></tr>
</tbody>
</table>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or None</span></dt>
<dd>audio time series</dd>
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)] or None</span></dt>
<dd>(optional) pre-computed spectrogram magnitude</dd>
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>FFT window size</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>hop length for STFT. See <cite>librosa.core.stft</cite> for details.</dd>
<dt>win_length <span class="classifier-delimiter">:</span> <span class="classifier">int &lt;= n_fft [scalar]</span></dt>
<dd><p class="first">Each frame of audio is windowed by <cite>window()</cite>.
The window will be of length <cite>win_length</cite> and then padded
with zeros to match <cite>n_fft</cite>.</p>
<p class="last">If unspecified, defaults to <code class="docutils literal notranslate"><span class="pre">win_length</span> <span class="pre">=</span> <span class="pre">n_fft</span></code>.</p>
</dd>
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span></dt>
<dd><ul class="first last simple">
<li>a window specification (string, tuple, or number);
see <cite>scipy.signal.get_window</cite></li>
<li>a window function, such as <cite>scipy.signal.hanning</cite></li>
<li>a vector or array of length <cite>n_fft</cite></li>
</ul>
</dd>
<dt>center <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><ul class="first last simple">
<li>If <cite>True</cite>, the signal <cite>y</cite> is padded so that frame
<cite>t</cite> is centered at <cite>y[t * hop_length]</cite>.</li>
<li>If <cite>False</cite>, then frame <cite>t</cite> begins at <cite>y[t * hop_length]</cite></li>
</ul>
</dd>
<dt>pad_mode <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>If <cite>center=True</cite>, the padding mode to use at the edges of the signal.
By default, STFT uses reflection padding.</dd>
<dt>amin <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd>minimum threshold for <cite>S</cite> (=added noise floor for numerical stability)</dd>
<dt>power <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd>Exponent for the magnitude spectrogram.
e.g., 1 for energy, 2 for power, etc.
Power spectrogram is usually used for computing spectral flatness.</dd>
</dl>
<dl class="docutils">
<dt>flatness <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(1, t)]</span></dt>
<dd>spectral flatness for each frame.
The returned value is in [0, 1] and often converted to dB scale.</dd>
</dl>
<p>From time-series input</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flatness</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">spectral_flatness</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flatness</span>
<span class="go">array([[  1.00000e+00,   5.82299e-03,   5.64624e-04, ...,   9.99063e-01,</span>
<span class="go">      1.00000e+00,   1.00000e+00]], dtype=float32)</span>
</pre></div>
</div>
<p>From spectrogram input</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">magphase</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">spectral_flatness</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">)</span>
<span class="go">array([[  1.00000e+00,   5.82299e-03,   5.64624e-04, ...,   9.99063e-01,</span>
<span class="go">      1.00000e+00,   1.00000e+00]], dtype=float32)</span>
</pre></div>
</div>
<p>From power spectrogram input</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">magphase</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S_power</span> <span class="o">=</span> <span class="n">S</span> <span class="o">**</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">spectral_flatness</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S_power</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="go">array([[  1.00000e+00,   5.82299e-03,   5.64624e-04, ...,   9.99063e-01,</span>
<span class="go">      1.00000e+00,   1.00000e+00]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.spectral_rolloff">
<code class="descclassname">librosa.feature.</code><code class="descname">spectral_rolloff</code><span class="sig-paren">(</span><em>y=None</em>, <em>sr=22050</em>, <em>S=None</em>, <em>n_fft=2048</em>, <em>hop_length=512</em>, <em>win_length=None</em>, <em>window='hann'</em>, <em>center=True</em>, <em>pad_mode='reflect'</em>, <em>freq=None</em>, <em>roll_percent=0.85</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.feature.spectral_rolloff" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute roll-off frequency.</p>
<p>The roll-off frequency is defined for each frame as the center frequency
for a spectrogram bin such that at least roll_percent (0.85 by default)
of the energy of the spectrum in this frame is contained in this bin and
the bins below. This can be used to, e.g., approximate the maximum (or
minimum) frequency by setting roll_percent to a value close to 1 (or 0).</p>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or None</span></dt>
<dd>audio time series</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>audio sampling rate of <cite>y</cite></dd>
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)] or None</span></dt>
<dd>(optional) spectrogram magnitude</dd>
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>FFT window size</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>hop length for STFT. See <cite>librosa.core.stft</cite> for details.</dd>
<dt>win_length <span class="classifier-delimiter">:</span> <span class="classifier">int &lt;= n_fft [scalar]</span></dt>
<dd><p class="first">Each frame of audio is windowed by <cite>window()</cite>.
The window will be of length <cite>win_length</cite> and then padded
with zeros to match <cite>n_fft</cite>.</p>
<p class="last">If unspecified, defaults to <code class="docutils literal notranslate"><span class="pre">win_length</span> <span class="pre">=</span> <span class="pre">n_fft</span></code>.</p>
</dd>
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span></dt>
<dd><ul class="first last simple">
<li>a window specification (string, tuple, or number);
see <cite>scipy.signal.get_window</cite></li>
<li>a window function, such as <cite>scipy.signal.hanning</cite></li>
<li>a vector or array of length <cite>n_fft</cite></li>
</ul>
</dd>
<dt>center <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><ul class="first last simple">
<li>If <cite>True</cite>, the signal <cite>y</cite> is padded so that frame
<cite>t</cite> is centered at <cite>y[t * hop_length]</cite>.</li>
<li>If <cite>False</cite>, then frame <cite>t</cite> begins at <cite>y[t * hop_length]</cite></li>
</ul>
</dd>
<dt>pad_mode <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>If <cite>center=True</cite>, the padding mode to use at the edges of the signal.
By default, STFT uses reflection padding.</dd>
<dt>freq <span class="classifier-delimiter">:</span> <span class="classifier">None or np.ndarray [shape=(d,) or shape=(d, t)]</span></dt>
<dd><p class="first">Center frequencies for spectrogram bins.
If <cite>None</cite>, then FFT bin center frequencies are used.
Otherwise, it can be a single array of <cite>d</cite> center frequencies,</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>freq</cite> is assumed to be sorted in increasing order</p>
</div>
</dd>
<dt>roll_percent <span class="classifier-delimiter">:</span> <span class="classifier">float [0 &lt; roll_percent &lt; 1]</span></dt>
<dd>Roll-off percentage.</dd>
</dl>
<dl class="docutils">
<dt>rolloff <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(1, t)]</span></dt>
<dd>roll-off frequency for each frame</dd>
</dl>
<p>From time-series input</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Approximate maximum frequencies with roll_percent=0.85 (default)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rolloff</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">spectral_rolloff</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rolloff</span>
<span class="go">array([[ 8376.416,   968.994, ...,  8925.513,  9108.545]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Approximate minimum frequencies with roll_percent=0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rolloff</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">spectral_rolloff</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">roll_percent</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rolloff</span>
<span class="go">array([[ 75.36621094,  64.59960938,  64.59960938, ...,  75.36621094,</span>
<span class="go">     75.36621094,  64.59960938]])</span>
</pre></div>
</div>
<p>From spectrogram input</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">magphase</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">spectral_rolloff</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="go">array([[ 8376.416,   968.994, ...,  8925.513,  9108.545]])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># With a higher roll percentage:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">spectral_rolloff</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">roll_percent</span><span class="o">=</span><span class="mf">0.95</span><span class="p">)</span>
<span class="go">array([[ 10012.939,   3003.882, ...,  10034.473,  10077.539]])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">rolloff</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Roll-off frequency&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Hz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">rolloff</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">amplitude_to_db</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">),</span>
<span class="gp">... </span>                         <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;log Power spectrogram&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.stack_memory">
<code class="descclassname">librosa.feature.</code><code class="descname">stack_memory</code><span class="sig-paren">(</span><em>data</em>, <em>n_steps=2</em>, <em>delay=1</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.feature.stack_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>Short-term history embedding: vertically concatenate a data
vector or matrix with delayed copies of itself.</p>
<p>Each column <cite>data[:, i]</cite> is mapped to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-&gt;</span>  <span class="p">[</span><span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span>
                <span class="n">data</span><span class="p">[:,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">delay</span><span class="p">],</span>
                <span class="o">...</span>
                <span class="n">data</span><span class="p">[:,</span> <span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_steps</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">delay</span><span class="p">]]</span>
</pre></div>
</div>
<p>For columns <cite>i &lt; (n_steps - 1) * delay</cite> , the data will be padded.
By default, the data is padded with zeros, but this behavior can be
overridden by supplying additional keyword arguments which are passed
to <cite>np.pad()</cite>.</p>
<dl class="docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(t,) or (d, t)]</span></dt>
<dd>Input data matrix.  If <cite>data</cite> is a vector (<cite>data.ndim == 1</cite>),
it will be interpreted as a row matrix and reshaped to <cite>(1, t)</cite>.</dd>
<dt>n_steps <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>embedding dimension, the number of steps back in time to stack</dd>
<dt>delay <span class="classifier-delimiter">:</span> <span class="classifier">int != 0 [scalar]</span></dt>
<dd><p class="first">the number of columns to step.</p>
<p>Positive values embed from the past (previous columns).</p>
<p class="last">Negative values embed from the future (subsequent columns).</p>
</dd>
<dt>kwargs <span class="classifier-delimiter">:</span> <span class="classifier">additional keyword arguments</span></dt>
<dd>Additional arguments to pass to <cite>np.pad</cite>.</dd>
</dl>
<dl class="docutils">
<dt>data_history <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(m * d, t)]</span></dt>
<dd>data augmented with lagged copies of itself,
where <cite>m == n_steps - 1</cite>.</dd>
</dl>
<p>This function caches at level 40.</p>
<p>Keep two steps (current and previous)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">stack_memory</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">array([[-3, -2, -1,  0,  1,  2],</span>
<span class="go">       [ 0, -3, -2, -1,  0,  1]])</span>
</pre></div>
</div>
<p>Or three steps</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">stack_memory</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">array([[-3, -2, -1,  0,  1,  2],</span>
<span class="go">       [ 0, -3, -2, -1,  0,  1],</span>
<span class="go">       [ 0,  0, -3, -2, -1,  0]])</span>
</pre></div>
</div>
<p>Use reflection padding instead of zero-padding</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">stack_memory</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">)</span>
<span class="go">array([[-3, -2, -1,  0,  1,  2],</span>
<span class="go">       [-2, -3, -2, -1,  0,  1],</span>
<span class="go">       [-1, -2, -3, -2, -1,  0]])</span>
</pre></div>
</div>
<p>Or pad with edge-values, and delay by 2</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">stack_memory</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span>
<span class="go">array([[-3, -2, -1,  0,  1,  2],</span>
<span class="go">       [-3, -3, -3, -2, -1,  0],</span>
<span class="go">       [-3, -3, -3, -3, -3, -2]])</span>
</pre></div>
</div>
<p>Stack time-lagged beat-synchronous chroma edge padding</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chroma</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">chroma_stft</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tempo</span><span class="p">,</span> <span class="n">beats</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">beat_track</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">beats</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">fix_frames</span><span class="p">(</span><span class="n">beats</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="n">chroma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chroma_sync</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">sync</span><span class="p">(</span><span class="n">chroma</span><span class="p">,</span> <span class="n">beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chroma_lag</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">stack_memory</span><span class="p">(</span><span class="n">chroma_sync</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="gp">... </span>                                          <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Plot the result</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">beat_times</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">frames_to_time</span><span class="p">(</span><span class="n">beats</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">chroma_lag</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;chroma&#39;</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">x_coords</span><span class="o">=</span><span class="n">beat_times</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">24</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Lag=0&#39;</span><span class="p">,</span> <span class="s1">&#39;Lag=1&#39;</span><span class="p">,</span> <span class="s1">&#39;Lag=2&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Time-lagged chroma&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.tempogram">
<code class="descclassname">librosa.feature.</code><code class="descname">tempogram</code><span class="sig-paren">(</span><em>y=None</em>, <em>sr=22050</em>, <em>onset_envelope=None</em>, <em>hop_length=512</em>, <em>win_length=384</em>, <em>center=True</em>, <em>window='hann'</em>, <em>norm=inf</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.feature.tempogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the tempogram: local autocorrelation of the onset strength envelope. <a href="#id112"><span class="problematic" id="id72">[1]_</span></a></p>
<table class="docutils footnote" frame="void" id="id73" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Grosche, Peter, Meinard Müller, and Frank Kurth.
“Cyclic tempogram - A mid-level tempo representation for music signals.”
ICASSP, 2010.</td></tr>
</tbody>
</table>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or None</span></dt>
<dd>Audio time series.</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>sampling rate of <cite>y</cite></dd>
<dt>onset_envelope <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,) or (m, n)] or None</span></dt>
<dd><p class="first">Optional pre-computed onset strength envelope as provided by
<cite>onset.onset_strength</cite>.</p>
<p class="last">If multi-dimensional, tempograms are computed independently for each
band (first dimension).</p>
</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>number of audio samples between successive onset measurements</dd>
<dt>win_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>length of the onset autocorrelation window (in frames/onset measurements)
The default settings (384) corresponds to <cite>384 * hop_length / sr ~= 8.9s</cite>.</dd>
<dt>center <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If <cite>True</cite>, onset autocorrelation windows are centered.
If <cite>False</cite>, windows are left-aligned.</dd>
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">string, function, number, tuple, or np.ndarray [shape=(win_length,)]</span></dt>
<dd>A window specification as in <cite>core.stft</cite>.</dd>
<dt>norm <span class="classifier-delimiter">:</span> <span class="classifier">{np.inf, -np.inf, 0, float &gt; 0, None}</span></dt>
<dd>Normalization mode.  Set to <cite>None</cite> to disable normalization.</dd>
</dl>
<dl class="docutils">
<dt>tempogram <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(win_length, n) or (m, win_length, n)]</span></dt>
<dd><p class="first">Localized autocorrelation of the onset strength envelope.</p>
<p class="last">If given multi-band input (<cite>onset_envelope.shape==(m,n)</cite>) then
<cite>tempogram[i]</cite> is the tempogram of <cite>onset_envelope[i]</cite>.</p>
</dd>
</dl>
<dl class="docutils">
<dt>ParameterError</dt>
<dd><p class="first">if neither <cite>y</cite> nor <cite>onset_envelope</cite> are provided</p>
<p class="last">if <cite>win_length &lt; 1</cite></p>
</dd>
</dl>
<p>fourier_tempogram
librosa.onset.onset_strength
librosa.util.normalize
librosa.core.stft</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute local onset autocorrelation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hop_length</span> <span class="o">=</span> <span class="mi">512</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">oenv</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">onset</span><span class="o">.</span><span class="n">onset_strength</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tempogram</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">tempogram</span><span class="p">(</span><span class="n">onset_envelope</span><span class="o">=</span><span class="n">oenv</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
<span class="gp">... </span>                                      <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute global onset autocorrelation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ac_global</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">autocorrelate</span><span class="p">(</span><span class="n">oenv</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="n">tempogram</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ac_global</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">ac_global</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Estimate the global tempo for display purposes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tempo</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">tempo</span><span class="p">(</span><span class="n">onset_envelope</span><span class="o">=</span><span class="n">oenv</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
<span class="gp">... </span>                           <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">oenv</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Onset strength&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># We&#39;ll truncate the display to a narrower range of tempi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">tempogram</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                         <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;tempo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">tempo</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Estimated tempo=</span><span class="si">{:g}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tempo</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">framealpha</span><span class="o">=</span><span class="mf">0.75</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tempogram</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">hop_length</span><span class="p">)</span> <span class="o">/</span> <span class="n">sr</span><span class="p">,</span>
<span class="gp">... </span>                <span class="n">num</span><span class="o">=</span><span class="n">tempogram</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tempogram</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Mean local autocorrelation&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ac_global</span><span class="p">,</span> <span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Global autocorrelation&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Lag (seconds)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># We can also plot on a BPM axis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">tempo_frequencies</span><span class="p">(</span><span class="n">tempogram</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">semilogx</span><span class="p">(</span><span class="n">freqs</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tempogram</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span>             <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Mean local autocorrelation&#39;</span><span class="p">,</span> <span class="n">basex</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">semilogx</span><span class="p">(</span><span class="n">freqs</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">ac_global</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span>
<span class="gp">... </span>             <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Global autocorrelation&#39;</span><span class="p">,</span> <span class="n">basex</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">tempo</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=.</span><span class="mi">8</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Estimated tempo=</span><span class="si">{:g}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tempo</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;BPM&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.tonnetz">
<code class="descclassname">librosa.feature.</code><code class="descname">tonnetz</code><span class="sig-paren">(</span><em>y=None</em>, <em>sr=22050</em>, <em>chroma=None</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.feature.tonnetz" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the tonal centroid features (tonnetz), following the method of
<a href="#id113"><span class="problematic" id="id74">[1]_</span></a>.</p>
<table class="docutils footnote" frame="void" id="id75" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Harte, C., Sandler, M., &amp; Gasser, M. (2006). “Detecting Harmonic
Change in Musical Audio.” In Proceedings of the 1st ACM Workshop
on Audio and Music Computing Multimedia (pp. 21-26).
Santa Barbara, CA, USA: ACM Press. doi:10.1145/1178723.1178727.</td></tr>
</tbody>
</table>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or None</span></dt>
<dd>Audio time series.</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">number &gt; 0 [scalar]</span></dt>
<dd>sampling rate of <cite>y</cite></dd>
<dt>chroma <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n_chroma, t)] or None</span></dt>
<dd><p class="first">Normalized energy for each chroma bin at each frame.</p>
<p class="last">If <cite>None</cite>, a cqt chromagram is performed.</p>
</dd>
</dl>
<dl class="docutils">
<dt>tonnetz <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape(6, t)]</span></dt>
<dd><p class="first">Tonal centroid features for each frame.</p>
<dl class="last docutils">
<dt>Tonnetz dimensions:</dt>
<dd><ul class="first last simple">
<li>0: Fifth x-axis</li>
<li>1: Fifth y-axis</li>
<li>2: Minor x-axis</li>
<li>3: Minor y-axis</li>
<li>4: Major x-axis</li>
<li>5: Major y-axis</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="docutils">
<dt>chroma_cqt</dt>
<dd>Compute a chromagram from a constant-Q transform.</dd>
<dt>chroma_stft</dt>
<dd>Compute a chromagram from an STFT spectrogram or waveform.</dd>
</dl>
<p>Compute tonnetz features from the harmonic component of a song</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">effects</span><span class="o">.</span><span class="n">harmonic</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tonnetz</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">tonnetz</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tonnetz</span>
<span class="go">array([[-0.073, -0.053, ..., -0.054, -0.073],</span>
<span class="go">       [ 0.001,  0.001, ..., -0.054, -0.062],</span>
<span class="go">       ...,</span>
<span class="go">       [ 0.039,  0.034, ...,  0.044,  0.064],</span>
<span class="go">       [ 0.005,  0.002, ...,  0.011,  0.017]])</span>
</pre></div>
</div>
<p>Compare the tonnetz features to <cite>chroma_cqt</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">tonnetz</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;tonnetz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Tonal Centroids (Tonnetz)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">chroma_cqt</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">),</span>
<span class="gp">... </span>                         <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;chroma&#39;</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Chroma&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.zero_crossing_rate">
<code class="descclassname">librosa.feature.</code><code class="descname">zero_crossing_rate</code><span class="sig-paren">(</span><em>y</em>, <em>frame_length=2048</em>, <em>hop_length=512</em>, <em>center=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.feature.zero_crossing_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the zero-crossing rate of an audio time series.</p>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd>Audio time series</dd>
<dt>frame_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>Length of the frame over which to compute zero crossing rates</dd>
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd>Number of samples to advance for each frame</dd>
<dt>center <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If <cite>True</cite>, frames are centered by padding the edges of <cite>y</cite>.
This is similar to the padding in <cite>librosa.core.stft</cite>,
but uses edge-value copies instead of reflection.</dd>
<dt>kwargs <span class="classifier-delimiter">:</span> <span class="classifier">additional keyword arguments</span></dt>
<dd><p class="first">See <cite>librosa.core.zero_crossings</cite></p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">By default, the <cite>pad</cite> parameter is set to <cite>False</cite>, which
differs from the default specified by
<cite>librosa.core.zero_crossings</cite>.</p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>zcr <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(1, t)]</span></dt>
<dd><cite>zcr[0, i]</cite> is the fraction of zero crossings in the
<cite>i</cite> th frame</dd>
</dl>
<dl class="docutils">
<dt>librosa.core.zero_crossings</dt>
<dd>Compute zero-crossings in a time-series</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">zero_crossing_rate</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">array([[ 0.134,  0.139, ...,  0.387,  0.322]])</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
</div>
<div class="section" id="harmonic-percussive-source-separation">
<h1>Harmonic-percussive source separation<a class="headerlink" href="#harmonic-percussive-source-separation" title="Permalink to this headline">¶</a></h1>
</div>
<div class="section" id="module-librosa.output">
<span id="output-methods"></span><h1>Output methods<a class="headerlink" href="#module-librosa.output" title="Permalink to this headline">¶</a></h1>
<div class="section" id="output">
<h2>Output<a class="headerlink" href="#output" title="Permalink to this headline">¶</a></h2>
<p>Note: the <cite>librosa.output</cite> module is deprecated as of version 0.7.0, and
it will be removed entirely in version 0.8.</p>
<div class="section" id="text-output">
<h3>Text output<a class="headerlink" href="#text-output" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="audio-output">
<h3>Audio output<a class="headerlink" href="#audio-output" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="librosa.output.annotation">
<code class="descclassname">librosa.output.</code><code class="descname">annotation</code><span class="sig-paren">(</span><em>path</em>, <em>intervals</em>, <em>annotations=None</em>, <em>delimiter='</em>, <em>'</em>, <em>fmt='%0.3f'</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.output.annotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Save annotations in a 3-column format:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span><span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span><span class="n">annotations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>\<span class="n">n</span>
<span class="n">intervals</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span><span class="n">intervals</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span><span class="n">annotations</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>\<span class="n">n</span>
<span class="n">intervals</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span><span class="n">intervals</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span><span class="n">annotations</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>\<span class="n">n</span>
<span class="o">...</span>
</pre></div>
</div>
<p>This can be used for segment or chord annotations.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function is deprecated in librosa 0.7.0.
It will be removed in 0.8.</p>
</div>
<dl class="docutils">
<dt>path <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>path to save the output CSV file</dd>
<dt>intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n, 2)]</span></dt>
<dd><p class="first">array of interval start and end-times.</p>
<p><cite>intervals[i, 0]</cite> marks the start time of interval <cite>i</cite></p>
<p class="last"><cite>intervals[i, 1]</cite> marks the end time of interval <cite>i</cite></p>
</dd>
<dt>annotations <span class="classifier-delimiter">:</span> <span class="classifier">None or list-like [shape=(n,)]</span></dt>
<dd>optional list of annotation strings. <cite>annotations[i]</cite> applies
to the time range <cite>intervals[i, 0]</cite> to <cite>intervals[i, 1]</cite></dd>
<dt>delimiter <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>character to separate fields</dd>
<dt>fmt <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>format-string for rendering time data</dd>
</dl>
<dl class="docutils">
<dt>ParameterError</dt>
<dd>if <cite>annotations</cite> is not <cite>None</cite> and length does
not match <cite>intervals</cite></dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">mfcc</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
</pre></div>
</div>
<p>Detect segment boundaries</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">boundaries</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">agglomerative</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>Convert to time</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">boundary_times</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">frames_to_time</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
<span class="gp">... </span>                                        <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
</pre></div>
</div>
<p>Convert events boundaries to intervals</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">intervals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">boundary_times</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
<span class="gp">... </span>                       <span class="n">boundary_times</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]])</span>
</pre></div>
</div>
<p>Make some fake annotations</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Seg #</span><span class="si">{:03d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">intervals</span><span class="p">))]</span>
</pre></div>
</div>
<p>Save the output</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">annotation</span><span class="p">(</span><span class="s1">&#39;segments.csv&#39;</span><span class="p">,</span> <span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span>                          <span class="n">annotations</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.output.times_csv">
<code class="descclassname">librosa.output.</code><code class="descname">times_csv</code><span class="sig-paren">(</span><em>path</em>, <em>times</em>, <em>annotations=None</em>, <em>delimiter='</em>, <em>'</em>, <em>fmt='%0.3f'</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.output.times_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Save time steps as in CSV format.  This can be used to store the output
of a beat-tracker or segmentation algorithm.</p>
<p>If only <cite>times</cite> are provided, the file will contain each value
of <cite>times</cite> on a row:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>\<span class="n">n</span>
<span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>\<span class="n">n</span>
<span class="n">times</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>\<span class="n">n</span>
<span class="o">...</span>
</pre></div>
</div>
<p>If <cite>annotations</cite> are also provided, the file will contain
delimiter-separated values:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">annotations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>\<span class="n">n</span>
<span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">annotations</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>\<span class="n">n</span>
<span class="n">times</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">annotations</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>\<span class="n">n</span>
<span class="o">...</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function is deprecated in librosa 0.7.0.
It will be removed in 0.8.</p>
</div>
<dl class="docutils">
<dt>path <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>path to save the output CSV file</dd>
<dt>times <span class="classifier-delimiter">:</span> <span class="classifier">list-like of floats</span></dt>
<dd>list of frame numbers for beat events</dd>
<dt>annotations <span class="classifier-delimiter">:</span> <span class="classifier">None or list-like</span></dt>
<dd>optional annotations for each time step</dd>
<dt>delimiter <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>character to separate fields</dd>
<dt>fmt <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>format-string for rendering time</dd>
</dl>
<dl class="docutils">
<dt>ParameterError</dt>
<dd>if <cite>annotations</cite> is not <cite>None</cite> and length does not
match <cite>times</cite></dd>
</dl>
<p>Write beat-tracker time to CSV</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tempo</span><span class="p">,</span> <span class="n">beats</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">beat_track</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">times_csv</span><span class="p">(</span><span class="s1">&#39;beat_times.csv&#39;</span><span class="p">,</span> <span class="n">beats</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.output.write_wav">
<code class="descclassname">librosa.output.</code><code class="descname">write_wav</code><span class="sig-paren">(</span><em>path</em>, <em>y</em>, <em>sr</em>, <em>norm=False</em><span class="sig-paren">)</span><a class="headerlink" href="#librosa.output.write_wav" title="Permalink to this definition">¶</a></dt>
<dd><p>Output a time series as a .wav file</p>
<p>Note: only mono or stereo, floating-point data is supported.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function is deprecated in librosa 0.7.0.
It will be removed in 0.8.  Usage of <cite>write_wav</cite> should
be replaced by <cite>soundfile.write</cite>.</p>
</div>
<dl class="docutils">
<dt>path <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>path to save the output wav file</dd>
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,) or (2,n), dtype=np.float]</span></dt>
<dd><p class="first">audio time series (mono or stereo).</p>
<p class="last">Note that only floating-point values are supported.</p>
</dd>
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd>sampling rate of <cite>y</cite></dd>
<dt>norm <span class="classifier-delimiter">:</span> <span class="classifier">boolean [scalar]</span></dt>
<dd>enable amplitude normalization.
For floating point <cite>y</cite>, scale the data to the range [-1, +1].</dd>
</dl>
<p>Trim a signal to 5 seconds and save it back</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">(),</span>
<span class="gp">... </span>                     <span class="n">duration</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">write_wav</span><span class="p">(</span><span class="s1">&#39;file_trim_5s.wav&#39;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
<p>soundfile.write</p>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3>Versions</h3>
<ul>
    <li><a href="../master/index.html">master</a></li>
    <li><a href="../0.4.1/index.html">0.4.1</a></li>
    <li><a href="../0.4.2/index.html">0.4.2</a></li>
    <li><a href="../0.4.3/index.html">0.4.3</a></li>
    <li><a href="../0.5.0/index.html">0.5.0</a></li>
    <li><a href="../0.5.1/index.html">0.5.1</a></li>
    <li><a href="../0.6.0/index.html">0.6.0</a></li>
    <li><a href="../0.6.1/index.html">0.6.1</a></li>
    <li><a href="../0.6.2/index.html">0.6.2</a></li>
    <li><a href="../0.6.3/index.html">0.6.3</a></li>
    <li><a href="../0.7.0/index.html">0.7.0</a></li>
    <li><a href="../0.7.1/index.html">0.7.1</a></li>
    <li><a href="index.html">v0.1.0</a></li>
    <li><a href="../v0.4.0/index.html">v0.4.0</a></li>
</ul>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">librosa 0.1.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2013, Dawen Liang, Brian McFee, Matt McVicar, Colin Raffel.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.9.
    </div>
  </body>
</html>